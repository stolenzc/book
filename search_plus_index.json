{"./":{"url":"./","title":"简介","keywords":"","body":"STOLENZC 的个人笔记网站 期待着彩虹，所以开了窗 窗外只有灼热闪光 所谓的彩虹，不过就是光 只要心还透明，就能折射希望 Copyright © book.stolenzc.com 2021-2023 all right reserved，powered by GitbookFile Modify: 2023-06-27 07:48:51 "},"AlgorithmNote.html":{"url":"AlgorithmNote.html","title":"算法","keywords":"","body":"算法基础知识 Big O 时间：随着数据规模的增加，需要进行的时长变化规律 不考虑必须要做的操作：循环、赋初值、程序初始化 不考虑常数项：2n -> n 不考虑低次项：n^2 + n -> n^2 空间：随着数据规模增加，需要额外开辟的空间 遍历使用的临时变量不计算 排序算法 中文名称 英文名称 平均时间复杂度 最坏时间复杂度 最好时间复杂度 空间复杂度 稳定性 选择排序 Selection n^2 n^2 n^2 1 不稳定 冒泡排序 Bubble n^2 n^2 n 1 稳定 插入排序 Insertion n^2 n^2 n 1 稳定 快速排序 Quick nlog(2, n) n^2 nlog(2, n) log(2, n) 不稳定 归并排序 Merge nlog(2, n) nlog(2, n) nlog(2, n) n 稳定 堆排序 Heap nlog(2, n) nlog(2, n) nlog(2, n) 1 不稳定 希尔排序 Shell n^1.3 n^2 n 1 不稳定 桶排序 Bucket n + k n^2 n n + k 稳定 计数排序 Counting n + k n + k n + k n + k 稳定 基数排序 Radix n * k n * k n * k n + k 稳定 不稳定：相同的值经过排序后相对位置可能会发送变化 口诀：选泡插，快归堆希桶计基，恩方老恩恩一三，对恩加k恩乘k，不稳稳稳不稳稳，不稳不稳稳稳稳。 选择排序 原理：从第一个数开始，往后遍历，找到最小的数，记录最小值的位置，将该值和第一个位置的值进行交换 python go 冒泡排序 原理：从第一个数开始，往后遍历，如果遍历的数比后一个位置的数大，则俩数交换位置，使最大的数到之后位置 冒泡排序是从后往前遍历 python go 插入排序 原理：从第二个数开始，往前遍历，如果遍历的数比前一个位置的数小，则将该数与前一个数位置交换 python go 快速排序 归并排序 堆排序 希尔排序 原理：希尔排序是基于插入排序的一种排序方法，先将数组分成若干个子数组，每个子数组再进行插入排序 桶排序 计数排序 基数排序 KMP算法 动态规划 Morris遍历 二叉树 链表 贪心算法 Copyright © book.stolenzc.com 2021-2023 all right reserved，powered by GitbookFile Modify: 2023-06-27 07:48:51 "},"DataAnalysis.html":{"url":"DataAnalysis.html","title":"数据分析","keywords":"","body":"一. Anaconda windows环境变量 C:\\ProgramData\\Anaconda3 C:\\ProgramData\\Anaconda3\\Library\\mingw-w64\\bin C:\\ProgramData\\Anaconda3\\Library\\bin C:\\ProgramData\\Anaconda3\\Scripts 启动jupyter notebookjupyter notebook 要新建⼀个notebook，点击按钮New，选择“Python3”或“conda[默认项]”。如果是第⼀次，点击空格，输⼊⼀⾏Python代码。然后按Shift-Enter执⾏。 当保存notebook时（File⽬录下的Save and Checkpoint），会创建⼀个后缀名为.ipynb的⽂件。 要加载存在的notebook，把它放到启动notebook进程的相同⽬录内。 在变量前后使⽤问号？，可以显示对象的信息 键盘快捷键 快捷键 说明 Ctrl-P或↑箭头 用当前输入的文本搜索之前的命令 Ctrl-N或↓箭头 用当前输入的文本搜索之后的命令 Ctrl-R Readline方式翻转历史搜索（部分匹配） Ctrl-Shift-V 从剪贴板粘贴文本 Ctrl-C 中断运行的代码 Ctrl-A 将光标移动到一行的开头 Ctrl-E 将光标移动到一行的末尾 Ctrl-K 删除光标到行尾的文本 Ctrl-U 删除当前行所有的文本 Ctrl-F 光标向后移动一个字符 Ctrl-B 光标向前移动一个字符 Ctrl-L 清空屏幕 魔术命令 命令 说明 命令? 在变量前后使⽤问号？，可以显示对象的信息 %timeit 测量python语句的运行时间 %quickref 显示IPython的快速参考 %magic 显示所有魔术命令的详细文档 %debug 在出现异常的语句进入调试模式 %hist 打印命令的输入（可以选择输出）历史 %pdb 出现异常时自动进入调试 %paste 执行剪贴板中的代码 %capaste 开启特别提示，手动粘贴待执行代码 %reset 删除所有命名控件中的变量和名字 %page OBJECT 美化打印对象，分页显示 %run scrpy.py 运行代码 %prun statement 用CProfile运行代码，并报告分析器输出 %time statement 报告单条语句的执行时间 %timeit statement 多次运行一条语句，计算平均执行时间，适合执行时间短的代码 %who,%who_Is, %whos 显示命名控件中的变量，三者显示的信息级别不同 %xdel variable 删除一个变量，并清空任何对它的引用 %load 将脚本导⼊到⼀个代码格中 二. Matplotlib import matplotlib.pyplot as plt # 画曲线图，k--表示画虚线 plt.plot([3,1,5,4,7,3,3,1,1], 'k--') # 画散点图 plt.scatter(x=[1,3,5,7,9], y=[2,4, 6,8,10]) # 创建画布 fig = plt.figure() # 向指定画布中添加画图对象 ax1 = fig.add_subplot(2, 2, 1) # 创建一个指定画布布局的画图区域 fig, axes = plt.subplots(2, 3) # 直⽅方图 plt.hist(np.random.randn(100), bins=20, color='k', alpha=0.3) # 设置x轴下标的区域 plt.xticks([0, 250, 500, 750, 1000], ['one', 'two', 'three', 'four', 'five'], rotation=30, fontsize='small') # 设置标题 plt.title('My first matplotlib plot') # 设置x轴标题 plt.xlabel('Stages') # 图表保存为本地图片 plt.savefig('figpath.png', dpi=400, bbox_inches='tight') pandas绘图 DataFrame的plot方法会在一个subplot中为各列绘制一条线，并自动创建图例 plot.bar()和plot.barh()分别绘制水平和垂直的柱状图。这时，Series和DataFrame的索引将会被⽤用作X（bar）或Y（barh）刻度 设置stacked=True即可为DataFrame⽣生成堆积柱状图 # 绘制直方图 tips['tip_pct'].plot.hist(bins=50) # 绘制密度图，通过计算“可能会产生观测数据的连续概率分布的估计”而产⽣ tips['tip_pct'].plot.density() seaborn绘图 import seaborn as sns # 绘制水平柱状图，绘制在柱状图上的黑线代表95%置信区间 sns.barplot(x='tip_pct', y='day', data=tips, orient='h') # 绘制密度图，通过计算“可能会产生观测数据的连续概率分布的估计”而产⽣ sns.distplot(values, bins=100, color='k') #做一个散布图，并加上一条线性回归的线 sns.regplot('m1', 'unemp', data=trans_data) # 制作网格分面图 sns.factorplot(x='day', y='tip_pct', hue='time', col='smoker', kind='bar', data=tips[tips.tip_pct matplotlib.pyplot.figure() 三. Numpy 说明： ndarray中数据类型必须一致 大小相同的数组比较会生成布尔值数组 ndarray属性 ndarray.ndim - 数组的轴（维度）的个数 ndarray.shape - 数组的维度。这是一个整数的元组，表示每个维度中数组的大小ndarray.size - 数组元素的总数。这等于 shape 的元素的乘积ndarray.dtype - 一个描述数组中元素类型的对象ndarray.astype() - 传入一个类型，返回一个新数据类型的ndarrayndarray.itemsize - 数组中每个元素的字节大小ndarray.data - 该缓冲区包含数组的实际元素。通常，我们不需要使用此属性，因为我们将使用索引访问数组中的元素 >>> import numpy as np >>> a = np.arange(15).reshape(3, 5) >>> a array([[ 0, 1, 2, 3, 4], [ 5, 6, 7, 8, 9], [10, 11, 12, 13, 14]]) >>> a.shape (3, 5) >>> a.ndim 2 >>> a.dtype.name 'int64' >>> a.itemsize 8 >>> a.size 15 >>> type(a) >>> b = np.array([6, 7, 8]) >>> b array([6, 7, 8]) >>> type(b) 数组创建 numpy.array() - 传入一个python容器，将输入的数据转换为ndarray，自动推断出dtype或者自定义 numpy.range() - 传递一个python数据容器转换为数组，容器中嵌套容器则会创建多维数组，dtype=int64指定数据类型 numpy.zeros() - 传递一个数或者一个元组指定数组的维度，数组值以零填充，dtype=int64指定数据类型 numpy.ones() - 传递一个数或者一个元组指定数组的维度，数组值以一填充，dtype=int64指定数据类型 numpy.emptys() - 传递一个数或者一个元组指定数组的维度，数组值随机填充，dtype=int64指定数据类型，默认为float64 numpy.full() - 根据指定的值填充传入的数组numpy.arange() - 类似于python中的array，传入起始值，结束值(不包含)，步长。返回一个一维数组numpy.linspace() - 传入起始值，结束值(不包含)，返回数据个数。返回一个一维数组numpy.zeros_like()，numpy.ones_like()，numpy.emptys_like() - 传入一个数组，返回一个和传入数组相同维度的数组，数组元素按照各自方法填充numpy.random.rand() - 传入多个值，用传入值表示维度，返回一个元素值在(0, 1)之间随机的数组numpy.random.randn() - 传入多个值，用传入值表示维度，返回一个元素值具有正态分布的数组numpy.random.normal(a, b, size=()) - 传入多个值，a和b表示正态分布的参数，size为数组大小numpy.random.randint(low[, high, size]) - 返回随机的整数，位于半开区间 [low, high)，size可以传递一个元组表示维度numpy.random.random([size]) - 返回随机的浮点数，在半开区间 [0.0, 1.0)，传入列表指定大小numpy.random.permutation(x) - 返回一个从0到x的序列，序列顺序随机排序 >>> import numpy as np >>> a = np.array([2,3,4]) >>> a array([2, 3, 4]) >>> a = np.array(1,2,3,4) # WRONG >>> a = np.array([1,2,3,4]) # RIGHT >>> b = np.array([(1.5,2,3), (4,5,6)]) >>> b array([[ 1.5, 2. , 3. ], [ 4. , 5. , 6. ]]) >>> c = np.array( [ [1,2], [3,4] ], dtype=complex ) >>> c array([[ 1.+0.j, 2.+0.j], [ 3.+0.j, 4.+0.j]]) >>> np.empty((2,3)) array([[ 3.73603959e-262, 6.02658058e-154, 6.55490914e-260], [ 5.30498948e-313, 3.14673309e-307, 1.00000000e+000]]) >>> np.arange(0, 2, 0.3) array([0. , 0.3, 0.6, 0.9, 1.2, 1.5, 1.8]) >>> np.linspace( 0, 2, 9 ) array([ 0. , 0.25, 0.5 , 0.75, 1. , 1.25, 1.5, 1.75, 2.]) 基本操作 算术运算符+-*/ - 按元素进行运算A@B / A.dot(B) - 矩阵乘积运算类型不同的数组运算 - 结果显示类型为更精确的数据类型+=、-=、*=、/= - 直接更改被操作的矩阵数组而不创建新的数组names != 'Bob' data[~(names == 'Bob')] - 均表示非的运算[:] - 给数组中的所有值赋值，只用冒号表示整个轴 >>> a = np.array( [20,30,40,50] ) >>> b = np.arange( 4 ) >>> b array([0, 1, 2, 3]) >>> c = a-b >>> c array([20, 29, 38, 47]) >>> b**2 array([0, 1, 4, 9]) >>> A = np.array( [[1,1], ... [0,1]] ) >>> B = np.array( [[2,0], ... [3,4]] ) >>> A * B # elementwise product array([[2, 0], [0, 4]]) >>> A @ B # matrix product array([[5, 4], [3, 4]]) >>> A.dot(B) # another matrix product array([[5, 4], [3, 4]]) >>> a = np.ones((2,3), dtype=int) >>> b = np.random.random((2,3)) >>> a *= 3 >>> a array([[3, 3, 3], [3, 3, 3]]) >>> b += a >>> b array([[ 3.417022 , 3.72032449, 3.00011437], [ 3.30233257, 3.14675589, 3.09233859]]) >>> a = np.ones(3, dtype=np.int32) >>> b = np.linspace(0,pi,3) >>> b.dtype.name 'float64' >>> c = a+b >>> c array([ 1. , 2.57079633, 4.14159265]) >>> c.dtype.name 'float64' 通函数 常用函数 numpy.all(a, axis=None, out=None) - 测定a的指定轴上所有的元素是否都为True，不指定axis轴则计算全部元素返回一个布尔值，out为放置返回值的数组numpy.any(a, axis=None, out=None) - 测定a的指定轴上是否有任意一个元素为True，不指定axis轴则计算全部元素返回一个布尔值，out为放置返回值的数组numpy.average(a, axis=None, weights=None, returned=False) - 计算指定数组在指定轴上的加权平均值，weight为权重numpy.mean(a, axis=None, dtype=None, out=None) - 计算指定数组在指定轴上的算术平均数numpy.sort(a, axis=None, kind=None, order=None) - 返回数组排序后的数组，不改变原始数组，kind为排序类型，默认为快速排序(quicksort)，order为排序方式，可以指定字段，类型为str或str列表numpy.where(condition[, x, y]) - 当值为True时，取x，否则取ynumpy.cumsum(a, axis=None, dtype=None, out=None) - 返回沿给定轴的元素的累积总和numpy.cumprod(a, axis=None, dtype=None, out=None) - 返回沿给定轴的元素的累积总和numpy.maximum(x, y) - 传入两个数组，两个数组的元素按位置进行比较，返回将大的值放在返回数组的对应位置中numpy.add(x, y) - 传入两个数组，两个数组的元素按位置进行相加，将结果放在返回数组的对应位置中numpy.modf(x) - 传入一个数组，返回两个数组，第一个数组为原数组的小数部分，第二个数组为原数组的整数部分numpy.meshgrid(x, y) - 传入两个一维数组，返回两个二维数组，第一个数组为x以行进行排列生成的多维数组，第二个数组为y以列进行排列生成的多维数组numpy.sort(arr) - 传递一个数组，返回一个排序后的数组ndarray.sort(axis=0) - 将自身按照指定轴进行排序numpy.unique(arr) - 传递一个数组，找出数组中的唯⼀值并返回已排序的结果numpy.in1d(arr1, arr2) - 传递两个数组，判断arr1中的元素是否在arr2中，返回一个布尔型数组numpy.union1d(a,b) - 计算数组的并集numpy.intersect1d(a,b) - 计算数组的交集numpy.setdiff1d(a,b) - 计算数组的差集numpy.setxor1d(a,b) - 计算数组的异或结果 文件读写 numpy.save(filename, arr) - 传入两个参数，第一个参数为文件的名字，第二个参数为数组numpy.load(filename) - 传入文件的名字，返回一个数组numpy.savez(filename, a=arr, b=arr) - 传入多个参数，第一个参数为文件的名字，后面为数组，可以将多个数组保存到⼀个未压缩⽂件中numpy.savez_compressed(filename, a=arr, b=arr) - 传入多个参数，第一个参数为文件的名字，后面为数组，可以将多个数组保存到⼀个压缩⽂件中 数学函数 numpy.abs()丶numpy.fabs() - 计算整数丶浮点数或复数的绝对值。对于非复数值，可以使用更快的fabsnumpy.sqrt() - 计算各元素的平方根numpy.square() - 计算各元素的平方numpy.exp() - 计算各元素的指数(e^x)numpy.linalg.solve(a, b) - 传入两个数组，计算多元方程组的解numpy.log()丶numpy.log10()丶numpy.log2()丶numpy.log1p() - 分别为自然对数(底数为e)丶底数为10的log丶底数为2的log丶log(1+x)numpy.sign() - 计算各元素的正负号：1(正数)丶0(零)丶-1(负数)numpy.ceil() - 计算各元素的ceiling值，即向上取整numpy.floor() - 计算各元素的floor值，即向下取整numpy.rint() - 将各元素四舍五入到最接近的整数，保留dtypenumpy.modf() - 将数组的小数和整数部分以两个独立数组的形式返回numpy.isnan() - 返回一个表示“哪些值是NaN（这不是一个数字）”的布尔型数组numpy.isfinite()丶numpy.isinf() - 分别返回一个表示“哪些元素是有穷的（非inf，非NaN）”或“哪些元素是无穷的”的布尔型数组numpy.cos()丶numpy.cosh()丶numpy.sin()丶numpy.sinh() - 普通型和双曲型三角函数numpy.tan()丶numpy.tanh()丶numpy.arccos()丶numpy.arccosh()丶numpy.arcsin()丶numpy.arcsinh()丶numpy.arctan()丶numpy.arctanh() - 反三角函数numpy.logical_not() - 计算各元素not x的真值。相当于-arr 索引、切片、迭代 一维数组 - 索引、切片、迭代和python列表一样 多维数组索引 - 每个轴可以有一个索引。这些索引通过逗号分隔的元组进行表示，提供的索引少于轴的数量时，缺失的索引被认为是完整的切片，使用...来表示完整索引所缺失的部分，如：x[4,...,5,:] 等效于 x[4,:,:,5,:] 多维数组迭代 - 相对于第一个轴进行的，flat为对所有元素进行迭代 使用负数表示从后往前选取 形状操作 ndarray.reshape() - 传入一个多个数值，以逗号分隔，返回一个以传入值为大小的多维数组ndarray.ravel() - 传入一个多维数组，返回一个一维数组ndarray.transpose() - 传入一个元组，元组内容为轴的索引，顺序为需要调整后的顺序ndarray.swapaxes() - 传入多个数，以逗号隔开，返回传入的轴所以交换后的数组numpy.resize(a, (size)) - 将a的维度改变为size大小numpy.vstack() - 传入一个元组，将元组中的数组以列的方式组装numpy.hstack() - 传入一个元组，将元组中的数组以行的方式组装numpy.column_stack() - 传入一个元组，元组元素为一维数组，将一维数组拆分以列的形式组装numpy.concatenate((a1, a2, ...), axis=0, out=None) - 将传入的数组以指定轴的方式连接numpy.stack(a, axis=0, out=None) - 将原始数组沿新轴连接 >>> arr array([[[ 0, 1, 2, 3], [ 4, 5, 6, 7]], [[ 8, 9, 10, 11], [12, 13, 14, 15]]]) >>> arr.transpose((1, 0, 2)) array([[[ 0, 1, 2, 3], [ 8, 9, 10, 11]], [[ 4, 5, 6, 7], [12, 13, 14, 15]]]) >>> arr array([[[ 0, 1, 2, 3], [ 4, 5, 6, 7]], [[ 8, 9, 10, 11], [12, 13, 14, 15]]]) >>> arr.swapaxes(1, 2) array([[[ 0, 4], [ 1, 5], [ 2, 6], [ 3, 7]], [[ 8, 12], [ 9, 13], [10, 14], [11, 15]]]) >>> a = np.floor(10*np.random.random((2,2))) >>> a array([[ 8., 8.], [ 0., 0.]]) >>> b = np.floor(10*np.random.random((2,2))) >>> b array([[ 1., 8.], [ 0., 4.]]) >>> np.vstack((a,b)) array([[ 8., 8.], [ 0., 0.], [ 1., 8.], [ 0., 4.]]) >>> np.hstack((a,b)) array([[ 8., 8., 1., 8.], [ 0., 0., 0., 4.]]) >>> a = np.array((1,2,3)) >>> b = np.array((2,3,4)) >>> np.column_stack((a,b)) array([[1, 2], [2, 3], [3, 4]]) >>> a = np.array([[1, 2], [3, 4]]) >>> b = np.array([[5, 6]]) >>> np.concatenate((a, b), axis=0) array([[1, 2], [3, 4], [5, 6]]) >>> np.concatenate((a, b.T), axis=1) array([[1, 2, 5], [3, 4, 6]]) >>> np.concatenate((a, b), axis=None) array([1, 2, 3, 4, 5, 6]) 四. Pandas 概要 维数 名称 描述 1 Series 带标签的一维同构数组 2 DataFrame 带标签的，大小可变的，二维异构表格 3 Panel 三维数组，DataFrame的容器 对DataFrame和Series的描述和汇总统计都有⼀个level选项，它⽤于指定在某条轴上求和的级别。 Pandas pandas.to_datetime() - 传入一个Series，返回一个Series对象，对象值格式为datetime。其对象可以使用.dt.year来获取年pd.date_range('1900/1/30', periods=df.shape[0]) - 返回一个日期ndarray，periods表示生成周期，即从开始日期开始，在几天中循环 导入数据 pandas.read_csv(filename, header=None,names, index_col, skiprows, na_values) - 从文件、URL、文件型对象中导入带分隔符的数据，默认分隔符为逗号，默认用第一行数据做列名，header=None表示自动生成列名；names可以自定义列名，index_col可以指定哪一列作为行索引，多个行索引用数组表示；pandas.read_table(filename, sep) - 从文件、URL、文件型对象中导入带分隔符的数据，默认分隔符为制表符(\\t)；sep为指定分隔符，可以使用正则匹配pandas.fwf(filename) - 读取指定宽列的数据(没有分隔符)pandas.read_excel(filename) - 从Excel文件导入数据，第一个参数为文件名，第二个参数为sheet表名，默认为第一个sheetpandas.hdf(filename) - 读取pandas写的HDF5文件pandas.HDFStore(filename) - 读取HDF5文件pandas.read_sql(query, connection_object) - 从SQL表/库导入数据，query为sql语句，connection_object为连接对象pandas.read_json(json_string) - 从JSON格式的字符串导入数据pandas.read_html(url) - 解析URL、字符串或者HTML文件，抽取其中的tables表格pandas.read_clipboard() - 从你的粘贴板获取内容，并传给read_table()pandas.DataFrame(dict) - 从字典对象导入数据，Key是列名，Value是数据pandas.msgpack(binary) - 二进制格式编码的pandas数据pandas.pickle(pickle_string) - 从python pickle的字符串导入数据pandas.options.display.max_rows - 设置DataFrame显示间距read_csv、read_table函数的参数： | 参数 | 说明 | | -------------- | ------------------------------------------------------------ | | path | 表示文件系统位置、url、文件型对象的字符串 | | sep或delimiter | 用于对行中各字段进行拆分的字符序或正则表达式 | | header | header=None表示自动生成列名，不填默认用第一行数据做列名 | | index_col | 指定哪一列作为行索引，多个行索引用数组表示 | | names | 指定列名，结合header=None | | skiprows | 跳过原文件哪些行，从文件开始处算起，从0开始，多行用数组表示 | | na_values | 一组用于替换Na的值，可以⽤⼀个列表或集合的字符串表示缺失值 | | comment | 用于将注释信息从行尾拆分出去的字符(一个或多个) | | parse_dates | 尝试将数据解析为日期，设置为True则解析所有列，可以指定列名，多个列用列表，如果列表元素为元组，则先组合多个列后解析 | | keep_date_col | 如果连接多列解析日期，则标尺参与连接的列，默认为False | | converters | 由列号/列名根函数之间的映射关系组成的字典。例如：{'foo': f}会对foo列的所有值应用函数f | | dayfirst | 当解析有歧义的日期时，将其看作国际格式，默认为False | | date_parser | 用于解析日期的函数 | | nrows | 需要读取的行数(从文件开始处开始算) | | iterator | 返回一个TextParser以便逐块读取文件 | | chunksize | 文件块的大小(用于迭代) | | skip_footer | 需要忽略的行数(从文件末尾处算起) | | verbose | 打印各种解析器的输出信息， 比如\"非数字列中缺失的数量\"等 | | encoding | 用于unicode的文本编码格式，用'utf-8'表示UTF-8格式编码 | | squeeze | 如果数据经解析后仅含一列，则返回Series | | thousands | 千分位分隔符，如\",\"或\".\" | Series pandas.Series(data, index=index, name=None) - 用于创建一维数组，默认生成整数索引 参数说明： data - python数据容器，如果为字典，则key为索引，value为值 index - 自定义索引值 name - 设置数组name属性(仅在打印时显示) Series对象属性和方法： .values - 返回Series的值 .index - 返回Series的索引 in 方法 - 判断索引是否在对象中，返回布尔值。如：b in SeriesObj .name - 获取Series对象的name属性，可以直接进行赋值 .rename() - 更改Series的name属性，返回一个新的Series .index.name - 获取Series对象的索引name属性，类似于索引列的列名，可以直接进行赋值操作 .map() - 传入一个函数，该函数返回原Series的每个元素应用于该函数后的Series .sort_index(ascending=True) - 返回一个用索引排序的新对象；默认为升序，ascending=False为降序 .sort_values(ascending=True) - 返回一个用值排序的新对象；默认为升序，ascending=False为降序。排序时，任何缺失值默认都会被放到Series的末尾 .rank(ascending, method) - 返回该值对应排序后的排名，默认为升序排名，method='first'表示按照排序后出现的位置排名。ascending可以排序方式 如果某个索引对应多个值，则返回⼀个Series；⽽对应单个值的，则返回⼀个标量值 .index.is_unique - 判断索引是否唯一 .unique() - 返回一个值唯一的Series .value_counts(dropna=False) - 计算Series中各值出现的次数 .isin() - 传入一个值或一个python容器，返回一个布尔数组，如果数组内容在传入的容器中则为True，否则为False .dropna() - 滤除缺失数据(删除所有NaN数据) .str - 将对象转换为字符串，后面跟一个字符串操作后返回Series .replace(value1, value2) - 将Series中值为value1的内容替换为value2的内容，传多个值用列表，会按照位置进行对应替换 .array - 用于提取 Series 数组 .astype(float) - 将Series中的数据类型更改为float类型 .iloc[0] - 按位置选取数据 .loc['index_one'] - 按索引选取数据 >>> d = {'b': 1, 'a': 0, 'c': 2} >>>pd.Series(d) b 1 a 0 c 2 >>>pd.Series(d, index=['b', 'c', 'd', 'a']) b 1.0 c 2.0 d NaN a 0.0 DataFrame pandas.DataFrame(data, index=None, columns=None) - 用于创建多维数组 参数说明： data - 传入数据，如果为嵌套字典，则外层字典的键作为列，内层键则作为⾏索引，也可为ndarray index - 行索引 columns - 列索引 DataFrame对象属性及方法： .columns - 取出列索引，可以直接进行赋值修改 .index - 获取行索引，不可进行赋值操作 .index.name - 取出行索引名，可以直接进行赋值 .columns.name - 取出列索引名，可以直接进行赋值 .values - 以二维ndarry形式返回数据(数组) [] - 以列的形式获取数据，可以直接进行赋值，可以进行切片操作，末端包含，使用[[]]返回一个DataFrame del df['列索引'] - 删除列 .T - 进行转置 .reindex(data, method, columns) - 传入索引，格式通常为列表，返回一个新的DataFrame对象；method为填充方式，值为'ffill'向前填充，'bfill'向后填充。如果传入的索引中有原对象中没有的，则索引对应的值使用该填充方法；columns为返回新对象的列索引 .drop(data, axis) - 传入一个值或者一个列表，默认删除指定索引的行，axis设置为1或'columns'可以删除列 如果DataFrame对象相加，没有共⽤的列或⾏标签，结果都会是空 df1.add(df2, fill_value=0) - df1与df2相加，fill_value表示没有匹配的位置填充值 .sort_index(axis, ascending, level) - 返回一个用索引排序的新对象，默认为行索引排序，axis=1改为列索引排序，ascending=False为降序；当有多层索引时，用level指定按照哪一层排序，0为最外层 .sort_values(by, ascending) - 返回一个用值排序的新对象，by为指定索引名，如果有多个用列表表示，ascending=False为降序，返回一个新的DataFrame .rank(axis) - 返回一个排序的DataFrame，默认以列排序，axis='columns'改为以行排序 .sum(axis, skipna) - 返回⼀个含有列的和的Series，传⼊axis=‘columns’或axis=1将会按⾏进⾏求和运算，skipna表示跳过NaN值，改为False表示不跳过 .mean(axis, skipna) - 返回⼀个含有列的平均值的Series，传⼊axis=‘columns’或axis=1将会按⾏进⾏求平均值运算，skipna表示跳过NaN值，改为False表示不跳过 .dropna(axis, how, thresh) - 滤除缺失数据；默认丢弃行，axis=1改为丢弃列；默认丢弃任何含有缺失值的行，how='all'为丢弃全为NaN的行；thresh=n为⼩于n个⾮空值的⾏ .fillna(data, inplace, method, limit) - 传入一个值，将所有NaN的位置用传入的值代替，传入一个字典则对不同的列填充不同的值；默认返回一个新对象，inplace=True对现有对象就地修改，method为填充方式，值为'ffill'向前填充，'bfill'向后填充。如果method被指定，对于连续的空值，这段连续区域，最多填充前 limit 个空值，如果method未被指定， 在该axis下，最多填充前 limit 个空值。 .duplicated(keep) - 返回⼀个布尔型Series，表示各⾏是否是重复⾏，重复行标True；默认是第⼀个出现的值组合为True。传⼊keep=‘last’则保留最 后⼀个 .drop_duplicates(keep) - 返回⼀个DataFrame，重复的数组行会标为False，传入一个数组表示根据指定的字段进行重复过滤；默认保留的是第⼀个出现的值组合。传⼊keep=‘last’则保留最 后⼀个 .rename(index, columns, inplace) - 修改索引名，index、columns如果传入字典，则表示将key的索引修改为value，inplace=True表示就地修改 .swaplevel() - 传入一个列表，列表中两个元素，表示两个索引交换位置 .set_index(data, drop) - 传入一个值，表示设置哪一列为行索引，如果有多个值用列表传入；默认设置为行索引后原列被删除了，drop=False可以将原列保留 .reset_index() - 层次化索引的级别会被转移到列⾥⾯作为普通数据 导出数据 DataFrame.to_csv(filename, sep, na_rep, index=True, header=True, columns) - 导出数据到CSV文件，sep表示分隔符，na_rep表示缺失值填充内容，默认为空字符串；默认会输出行索引和列索引，用index和header为False改为禁止输入索引；用columns指定输入哪些列，并且按照指定的顺序排列DataFrame.to_excel(filename) - 导出数据到Excel文件，第一个参数为文件名，第二个参数为sheet，默认为第一个sheetDataFrame.to_sql(table_name, connection_object) - 导出数据到SQL表DataFrame.to_json(filename) - 以Json格式导出数据到文本文件DataFrame.to_pickle(filename) - 以pickle格式导出数据到文本文件 查看、检查数据 DataFrame.head(n) - 查看DataFrame对象的前n行DataFrame.tail(n) - 查看DataFrame对象的最后n行DataFrame.shape() - 查看行数和列数DataFrame.info() - 查看索引、数据类型和内存信息DataFrame.apply(pd.Series.value_counts) - 查看DataFrame对象中每一列的唯一值和计数DataFrame.apply(f, axis) - 传入一个函数，函数的默认参数为一个数组；axis默认传入列，axis='columns'传入行DataFrame.applymap() - 传入一个函数，函数的默认参数为一个值，返回一个DataFrame中每个元素都经过该函数计算后的DataFrame 数据选取 DataFrame[col] - 根据列名，并以Series的形式返回列DataFrame[[col1, col2]] - 以DataFrame形式返回多列DataFrame.iloc[0,:] - 以行的形式获取数据，传入索引值，可以传入行索引后再传入列索引，用逗号分隔，如：data.loc['Colorado', ['two', 'three']]DataFrame.iloc[] - 按位置获取行数据，可以传入行索引后再传入列索引，用逗号分隔 数据清理 pandas.isnull() - 检查DataFrame对象中的空值，并返回一个Boolean数组pandas.notnull() - 检查DataFrame对象中的非空值，并返回一个Boolean数组pandas.cut(data, bins, right, labels) - data为原始数据，bins为划分的区间列表，表示将data的值按照bins进行划分；默认区间为左开右闭，right=False表示左闭右开；可以传入一个labels列表表示划分区间的名称，labels元素必须比bins中少一个pandas.cut(data, num, precision) - data为原始数据，num处应该为一个数，(形参名不为num)表示将范围均分为几份， precision=n表示保留小数点后n位pandas.qcut(data, num) - data为原始数据，num处应该为一个数，(形参名不为num)表示将落在区间的数量均分为几份DataFrame.unstack() - 将行索引的内层索引转换为列索引DataFrame.stack() - 将列索引转换为行索引的内层索引 数据处理：Filter、Sort和GroupBy DataFrame[df[col] > 0.5] - 选择col列的值大于0.5的行DataFrame.groupby(col) - 返回一个按列col进行分组的Groupby对象DataFrame.groupby([col1,col2]) - 返回一个按多列进行分组的Groupby对象DataFrame.groupby(col1)[col2] - 返回按列col1进行分组后，列col2的均值DataFrame.pivot_table(index=col1, values=[col2,col3], aggfunc=max) - 创建一个按列col1进行分组，并计算col2和col3的最大值的数据透视表DataFrame.groupby(col1).agg(np.mean) - 返回按列col1分组的所有列的均值 数据合并 DataFrame1.append(DataFrame2) - 将DataFrame2中的行添加到DataFrame1的尾部DataFrame.concat([df1, df2],axis=1) - 将df2中的列添加到df1的尾部DataFrame1.join(DataFrame2,on=col1,how='inner') - 对DataFrame1的列和DataFrame2的列执行SQL形式的joinpandas.merge(df1, df2, on, how, suffixes) - 根据⼀个或多个键将不同DataFrame中的⾏连接起来，它实现的就是数据库的join操作；不指定列则自动使用重叠的列名作为键，用on可以自定义合并列，多个列使用列表，如果列名不一样，则使用left_on，right_on进行指定；默认为内连接，用how指定outer、left、right连接；suffixes来指定重复列名的名字，传入的是元组；连接键位于其索引中用left_index=True或right_index=True来说明索引作为连接键pandas.concat(data, axis, join, key, names, ignore_index) - 可以沿着⼀条轴将多个对象堆叠到⼀起。data为列表，axis=1表示沿列进行连接(不断添加列)，join为连接方法，inner、outer...；key指定每个连接字段的外层索引名。类似给连接进来的数据取别名，区分数据来源；names给key和内层索引添加名字(name属性)；ignore_index=True表示⾏索引不包含任何相关数据df1.combine_first(df2) - 以df1为基础，如果df1中没有数据，df2中有数据，则将df2的数据填入到df1中，如果都有，则保留df1中的数据 数据统计 DataFrame.describe() - 查看数据值列的汇总统计，结果包括总个数，平均值，最小值，最大值，标准差等DataFrame.mean() - 返回所有列的均值DataFrame.corr() - 返回列与列之间的相关系数DataFrame.count() - 返回每一列中的非空值的个数DataFrame.max() - 返回每一列的最大值DataFrame.min() - 返回每一列的最小值DataFrame.median() - 返回每一列的中位数DataFrame.std() - 返回每一列的标准差 五. 机器学习 监督学习：算法必须知道⽬目标变量量的分类信息，分类和回归 ⽆无监督学习：算法不不知道⽬目标变量量，没有类别信息 聚类：将数据集合分成由类似的对象组成的多个类的过程 密度估计：寻找描述数据统计值的过程 k-近邻法 一种基本分类与回归⽅方法 存在一个样本数据集合，也称作为训练样本集，并且样本集中每个数据都存在标签，即我们知道样本集中每一个数据与所属分类的对应关系。输入没有标签的新数据后，将新的数据的每个特征与样本集中数据对应的特征进行比较，然后算法提取样本最相似数据(最近邻)的分类标签 原理公式 两个特征值公式 多个特征值公式： 实现步骤 计算训练集和测试集之间特征值的距离 将计算的结果进行排序 选取最近的k个距离，统计这k个中出现次数最多的标签 得到的标签就是k近邻算法的结果 纯python实现 def knn(train_data, train_category, test_item, k): a = [] for i,train_item in enumerate(train_data): result = ((train_item[0]-test_item[0])**2 + (train_item[1]-test_item[1])**2)**0.5 a.append(([train_category[i]], result)) a.sort(key=lambda item: item[1]) result2 = {} for i in range(k): if a[i][0][0] in result2: result2[a[i][0][0]] = result2[a[i][0][0]] + 1 else: result2[a[i][0][0]] = 1 return max(result2,key=result2.get) numpy实现 def knn(train_features, train_category, test_data, k): distance_arr = (train_features - test_data) ** 2 distance_arr = distance_arr.sum(axis=1) ** 0.5 sort_index_arr = distance_arr.argsort()[:k] category_arr = train_category.take(sort_index_arr) c = Counter(category_arr) return c.most_common(1)[0][0] Scikit learn/sklearn实现 Classification 分类 Regression 回归 Clustering 非监督分类 Dimensionality reduction 数据降维 Model Selection 模型选择 Preprocessing 数据与处理理 from sklearn.neighbors import KNeighborsClassifier as kNN # 构建kNN分类器，n_neighbors为k值，即近邻值，algorithm为算法选择，auto为自动选择 neigh = kNN(n_neighbors = 3, algorithm = 'auto') # 拟合模型, trainingMat为测试矩阵,hwLabels为对应的标签 neigh.fit(trainingMat, hwLabels) # 传入测试集，返回预测结果 classifierResult = neigh.predict(vectorUnderTest) 决策树 决策树(decision tree)是一种基本的分类与回归方法 流程图就是一个决策树，通常使用递归方法产生决策树，决策树本质是一个字典，通过不同的键的选择走向不同的分支，最后得到不同的值 构建过程：特征选择、决策树的生成和决策树的修剪 决策树算法 通过集合D的经验熵H(D)与特征A给定条件下D的经验条件熵H(D|A)之差得到信息增益g(D,A) 递归地构建决策树，将信息增益最大的放在最外层，然后剔除掉该特征值计算剩下的信息增益 决策树使用公式 经验熵 |D| 为样本的数量 k 表示有k个类 ck为属于k类的样本的个数 经验条件熵 |D| 为样本的总数量 n 为特征A中不同值的数量(有几个不同的取值) Di 为i类样本的数量 Dik 为Di中属于K类样本的数量 信息增益 H(D) 为经验熵 H(D|A)为经验条件熵 代码实现 # 算经验熵H(D) def calc_hd(dataSet): \"\"\" 传入一个列表嵌列表，二层列表中为训练集特征值和标签 返回一个数值 \"\"\" data_arr = np.array(dataSet) i = data_arr.shape[1] - 1 u_category = np.unique(data_arr[:,i]) D = data_arr.shape[0] c = Counter(data_arr[:,i]) result = 0 for u in u_category: a = c[u] / D result -= a *math.log2(a) return result # 算条件熵H(D|A) def calc_hda(dataSet, i): \"\"\" 传入一个列表嵌列表，二层列表中为训练集特征值和标签，i为第i列作为条件 返回一个数值 \"\"\" data_arr = np.array(dataSet) feature_set = np.unique(data_arr[:, i]) c = Counter(data_arr[:,i]) D = data_arr.shape[0] result = 0 for value in feature_set: di_count = c[value] sub_data = data_arr[data_arr[:, i] == value] result += (di_count / D * calc_hd(sub_data)) return result # 算信息增益值 info gain = H(D) - H(D|A) def calc_g(dataSet, i): return calc_hd(dataSet) - calc_hda(dataSet, i) # 首先要把i这列特征去掉，同时要去掉值是value的行 def sub_data(data, i ,value): rows = data[data[:, i] == value] sub = np.concatenate([rows[:, :i], rows[:, i+1:]], axis=1) return sub # 创建决策树 labels = ['年龄', '有工作', '有房子', '信贷情况'] def create_decision_tree(dataSet): data_arr = np.array(dataSet) # 递归结束条件 # 分类只有一种的情况 label_arr = np.unique(data_arr[:, -1]) category_count = label_arr.shape[0] if category_count == 1: return label_arr[0] # 没有特征可用了 if data_arr.shape[1] == 1: c = Counter(data_arr[:, -1]) return c.most_common(1)[0][0] # 计算信息增益值 feature_count = data_arr.shape[1] - 1 g_list = [] for i in range(feature_count): # 取最大信息增益值的特征 g = calc_g(data, i) g_list.append(g) g_arr = np.array(g_list) max_index = g_arr.argmax() max_label = labels[max_index] # 构建字典 tree_dict = {max_label:{}} # 找特征值有几种 feature_arr = data_arr[:, max_index] unique_feature_arr = np.unique(feature_arr) for feature_value in unique_feature_arr: sub = sub_data(data_arr, max_index, feature_value) tree = create_decision_tree(sub) tree_dict[max_label][feature_value] = tree return tree_dict # 通过递归进行测试集的运算 def choose(data, result_dict=None): labels = ['年龄', '有工作', '有房子', '信贷情况'] data_arr = np.array(data) if result_dict == None: result_dict = load() # 从pickle文件中读取labels this_key = list(result_dict)[0] this_value = list(result_dict.values())[0] index = labels.index(this_key) this_category = str(data_arr[index]) if isinstance(this_value[this_category], str): if this_value[this_category] == 'yes': return '放贷款' else: return '不放贷款' else: return choose(data, this_value[str(this_category)]) 朴素贝叶斯 朴素⻉贝叶斯算法是有监督的学习算法，解决的是分类问题 实现步骤 计算训练集每个单独的元素是哪一个分类的概率 统计计算测试集中每个元素的概率进行相加，判断属于哪个分类 实现公式 贝叶斯公式 P(A|B)表示B属于A类的概率P(B|A)表示A属于B类的概率 P(A)表示A发生的概率 P(B)表示B发生的概率 代码实现 def trainNB0(trainMatrix,trainCategory): numTrainDocs = len(trainMatrix) #计算训练的文档数目 numWords = len(trainMatrix[0]) #计算每篇文档的词条数 pAbusive = sum(trainCategory)/float(numTrainDocs) #文档属于侮辱类的概率 p0Num = np.zeros(numWords); p1Num = np.zeros(numWords) #创建numpy.zeros数组,词条出现数初始化为0 p0Denom = 0.0; p1Denom = 0.0 #分母初始化为0 for i in range(numTrainDocs): if trainCategory[i] == 1: #统计属于侮辱类的条件概率所需的数据，即P(w0|1),P(w1|1),P(w2|1)··· p1Num += trainMatrix[i] p1Denom += sum(trainMatrix[i]) else: #统计属于非侮辱类的条件概率所需的数据，即P(w0|0),P(w1|0),P(w2|0)··· p0Num += trainMatrix[i] p0Denom += sum(trainMatrix[i]) p1Vect = p1Num/p1Denom p0Vect = p0Num/p0Denom return p0Vect,p1Vect,pAbusive def testingNB(): listOPosts,listClasses = loadDataSet() #创建实验样本 myVocabList = createVocabList(listOPosts) #创建词汇表 trainMat=[] for postinDoc in listOPosts: trainMat.append(setOfWords2Vec(myVocabList, postinDoc)) #将实验样本向量化 p0V,p1V,pAb = trainNB0(np.array(trainMat),np.array(listClasses)) #训练朴素贝叶斯分类器 testEntry = ['love', 'my', 'dalmation'] #测试样本1 thisDoc = np.array(setOfWords2Vec(myVocabList, testEntry)) #测试样本向量化 if classifyNB(thisDoc,p0V,p1V,pAb): print(testEntry,'属于侮辱类') #执行分类并打印分类结果 else: print(testEntry,'属于非侮辱类') #执行分类并打印分类结果 testEntry = ['stupid', 'garbage'] #测试样本2 thisDoc = np.array(setOfWords2Vec(myVocabList, testEntry)) #测试样本向量化 if classifyNB(thisDoc,p0V,p1V,pAb): print(testEntry,'属于侮辱类') #执行分类并打印分类结果 else: print(testEntry,'属于非侮辱类') 为防止下溢出，需要修改代码： def testingNB(): listOPosts,listClasses = loadDataSet() #创建实验样本 myVocabList = createVocabList(listOPosts) #创建词汇表 trainMat=[] for postinDoc in listOPosts: trainMat.append(setOfWords2Vec(myVocabList, postinDoc)) #将实验样本向量化 p0V,p1V,pAb = trainNB0(np.array(trainMat),np.array(listClasses)) #训练朴素贝叶斯分类器 testEntry = ['love', 'my', 'dalmation'] #测试样本1 thisDoc = np.array(setOfWords2Vec(myVocabList, testEntry)) #测试样本向量化 if classifyNB(thisDoc,p0V,p1V,pAb): print(testEntry,'属于侮辱类') #执行分类并打印分类结果 else: print(testEntry,'属于非侮辱类') #执行分类并打印分类结果 testEntry = ['stupid', 'garbage'] #测试样本2 thisDoc = np.array(setOfWords2Vec(myVocabList, testEntry)) #测试样本向量化 if classifyNB(thisDoc,p0V,p1V,pAb): print(testEntry,'属于侮辱类') #执行分类并打印分类结果 else: print(testEntry,'属于非侮辱类') 线性回归 对连续型的数据做出预测 实现步骤 计算出特征系数，通过特征系数对未来值进行预测 实现公式 直线拟合： 加权拟合： 参数说明： X为特征向量 y为结果集 w为权重值 k为高斯核,自定义参数 代码实现 # 求回归系数 def get_w(x, y): x = np.mat(x) y = np.mat(y) return (x.T * x).I * x.T * y # 计算局部加权线性回归系数 def lwlr(test_point, x_arr, y, k=1): xmat = np.mat(x_arr) ymat = np.mat(y).T n = xmat.shape[0] # 对角线为1的权重矩阵 weights_arr = np.mat(np.eye((n))) for i in range(n): diff_mat = test_point - xmat[i, :] weights_arr[i, i] = np.exp(diff_mat * diff_mat.T / (-2 * k ** 2)) xTx = xmat.T * (weights_arr * xmat) w = xTx.I * (xmat.T * (weights_arr * ymat)) return test_point * w Logistic Logistic回归进⾏行行分类的主要思想是：根据现有数据对分类边界线建⽴立回归公式，以此进⾏行行分类。Sigmoid函数，我们也可以称它为Logistic函数 实现步骤 先随机选取k个点 按照这k个点对所有点进行分类 分类后重新选择最中心的点再进行分类 以此类推，当重新计算的点和现使用的点距离小于某个阈值时结束 代码实现 # sigmoid函数 def sigmoid(inx): return 1 / (1 + np.exp(-inx)) # 加载数据 def loadDataSet(): dataMat = []#创建数据列列表 labelMat = [] #创建标签列列表 fr = open('examples/testSet.txt')#打开⽂文件 for line in fr.readlines():#逐⾏行行读取 lineArr = line.strip().split()#去回⻋车，放⼊入列列表 dataMat.append([1.0, float(lineArr[0]), float(lineArr[1])])#添加数据 labelMat.append(int(lineArr[2]))#添加标签 fr.close()#关闭⽂文件 return dataMat, labelMat # 计算回归 def plotDataSet(): dataMat, labelMat = loadDataSet()#加载数据集 dataArr = np.array(dataMat)#转换成numpy的array数组 n = np.shape(dataMat)[0]#数据个数 xcord1 = []; ycord1 = []#正样本 xcord2 = []; ycord2 = []#负样本 for i in range(n): #根据数据集标签进⾏行行分类 if int(labelMat[i]) == 1: xcord1.append(dataArr[i,1]); ycord1.append(dataArr[i,2])#1为正样本 else: xcord2.append(dataArr[i,1]); ycord2.append(dataArr[i,2])#0为负样本 fig = plt.figure() ax = fig.add_subplot(111)#添加subplot ax.scatter(xcord1, ycord1, s = 20, c = 'red', marker = 's',alpha=.5)#绘制正样本 ax.scatter(xcord2, ycord2, s = 20, c = 'green',alpha=.5)#绘制负样本 plt.title('DataSet')#绘制title plt.xlabel('x'); plt.ylabel('y')#绘制label plt.show k-means聚类算法 聚类是一种无监督学习算法 用处：将相似的对象归到同一个簇中 k均值聚类算法(k-means)可以发现k个不同的簇，每个簇的中心采用簇中所含值的均值计算而成 步骤 随机选取k个点作为初始质心。 对于样本中每一个点，分别求与k点的距离。距离最小者就属于该类。 此时对得到的k各类，重新计算新的质心。 当第3步得到的质心与之前的质心误差很小时，分类结束。 代码实现 # 随机选取k个点作为质心 k = 2 def get_random_center_index(row_count, k): while True: centers = np.random.choice(row_count, k) if np.unique(centers).shape[0] == k: return centers # 求两点距离 def get_distance(p1, p2): p1arr = np.array(p1) p2arr = np.array(p2) return (np.sum((p1arr - p2arr) ** 2, axis=0)) ** 0.5 # 求单个点跟k个中心点的距离 def get_point_distance(point, k_center_points): return list(map(lambda kpoint: get_distance(kpoint, point), k_center_points)) # 求所有的点与k个中心点的距离 def get_points_distance(points_arr, k_center_points): return np.array(list(map(lambda point:get_point_distance(point, k_center_points), points_arr))) # 用循环找出新质心与旧质心误差很小的时候的质心作为最终质心进行分蔟 def get_clustered_index_arr(points_arr, k_center_points, cluster_index_arr, k): # 放中心点 mean_center_arr = np.full((k, points_arr.shape[1]), np.nan) old_mean_arr = k_center_points.copy() while not np.allclose(old_mean_arr, mean_center_arr): old_mean_arr = mean_center_arr.copy() for i in range(k): # 对点进行分蔟 cluster_points = points_arr[cluster_index_arr == i] # 对蔟重新计算质心 mean_center = cluster_points.mean(axis=0) # 计算所有点 mean_center_arr[i] = mean_center # 算所有点与中心点的距离 mean_distance = get_points_distance(points_arr, mean_center_arr) # 每个点蔟的索引号 cluster_index_arr = mean_distance.argmin(axis=1) return (cluster_index_arr, mean_center_arr) 六. sklearn 特征工程 # 两个特征值分类 from sklearn.preprocessing import Binarizer bz = Binarizer(threshold=0) # threshold表示大于为1，小于等于为0 music_df['bz-listen'] = bz.transform([music_df['listen_count']])[0] # 多项式生成 from sklearn.preprocessing import PolynomialFeatures pl = PolynomialFeatures(degree=2, interaction_only=False, include_bias=False) arr = pl.fit_transform(atc_def) # 生成一个二次多项式的特征组合 dxs = pd.DataFrame(arr, columns=['Attack', 'Defense', 'Attack^2', 'Attack*Defense', 'Defense^2']) # 测试集据使用transform poke_test_arr = pl.transform(poke_test_df) poke_test_df2 = pd.DataFrame(poke_test_arr, columns=['Attack', 'Defense', 'Attack^2', 'Attack*Defense', 'Defense^2']) # 连续数据离散化 fcc_df['Income'].hist(bins=30) quantile_list = [0, 0.25, 0.5, 0.75, 1] quantiles = fcc_df['Income'].quantile(quantile_list) # 添加别名 pv = plt.axvline(quantile, color='red') # 分割处竖线标记 # 对数据正太分布调整(求对数或box-cox) from sklearn.preprocessing import LabelEncoder label_encoder = LabelEncoder() vg_df['genre_code'] = label_encoder.fit_transform(vg_df['Genre']) sample_df = df.sample(random_state=2, frac=1) # random_state为分步因子，frac为数据百分比 gen_map = {'Gen 1':1,'Gen 2':2,'Gen 3':3,'Gen 4':4,'Gen 5':5,'Gen 6':6} df['gen_code'] = sample_df['Generation'].map(gen_map) from sklearn.preprocessing import OneHotEncoder ge_label = LabelEncoder() ge_one_hot = OneHotEncoder() df['gen_code'] = ge_label.fit_transform(df['Generation']) ge_arr = ge_one_hot.fit_transform(df[['gen_code']]).toarray() ge_label.classes_ 图像特征提取 先把图片读进来 from skimage import io;io.imread() 将图片转换成相同的大小PIL Image resize thumb 将图片转换成灰度图片（三维变成二维，降维） mahotas.color.rgb2gray 用mahotas surf.dense将灰度图片进一步取点，减少数量 用kmeans聚类算法生成可视化词袋，用np.bincount计算每个可视化词（颜色蔟）的个数 用cosin_similarity计算新的图片的相似度。新图片也需要词袋化处理。 文本特征提取 先创建一个分词器 jieba 定义停用词(就是忽略的词) TFIDVector把所有训练集文本处理成词条矩阵 用cosin_similary计算相似度 用kmeans算法进行聚类 七. Spark 1. 安装 下载 https://spark.apache.org/downloads.html下载.tar文件后进行解压 Windows还需要下载https://github.com/steveloughran/winutils/blob/master/hadoop-2.7.1/bin/winutils.exe放在解压后的bin目录下 spark的运行基于Java，java安装参考：https://www.cnblogs.com/xuliangxing/p/7279662.html 配置环境变量 HADOOP_HOME为spark解压目录 SPARK_HOME也为spark解压目录 PYSPARK_DRIVER_PYTHON=jupyter PYSPARK_DRIVER_PYTHON_OPTS=notebook 将spark bin配置到PATH环境变量中 安装后使用 安装pip install findspark，在程序中使用findspark init()来找到spark pip install pyarrow==0.14.0来保证正常使用 spark的图形化界面在http://127.0.0.1:4040/jobs/ 2. spark.sql 创建应用 from pyspark.sql import SparkSession spark = SparkSession.builder.appName('sparkdata').getOrCreate() 创建DataFrame from pyspark.sql.types import StructType # 创建字段 schema = StructType().add('order_id', 'string').add('goods_name', 'string'). df = spark.createDataFrame([('T001', '米家电饭煲', 2000.0), ('T002', '格力空调', 2000.0), ('T003', '佳洁士牙膏', 15.5)], schema=schema) 显示 # 显示字段结构 df.printSchema() # 显示字段内容，括号指定数量，默认显示20条；truncate=False为不截断数据，全部显示出来 df.show() # 查看数据数量 df.count() # 查看字段数量 len(df.columns) # 查看数据详情(均值，分位数等)，以列进行统计 df.summary().show() 填充空值 # 按照数据类型填充：整型填充为0，字符型填充为Missing df.fillna(0).show() df.fillna('Missing').show() # 按照字段填充空值 df.fillna({'goods_name':'missing', 'quantity': 0}).show() 删除值 # 删除所有含空值的行 df.na.drop().show # 值删除某个字段为空的整行数据 df.na.drop(subset='quantity').show() # 删除指定字段 df.drop('order_time').show() 替换值 # 将格力空调全部替换为美的空调 df.replace('格力空调', '美的空调').show() # 指定字段进行替换值 df.replace(2000.0, 1999.0, subset='quantity').show() 条件选择 # 选列，显示指定的列 customer_df.select(['Customer_subtype', 'label']).show() # 条件选择 customer_df.filter(customer_df['Number_of_houses']>2).filter(customer_df['Avg_Salary']>50000).select(['Number_of_houses', 'Avg_Salary']).show() # 条件选择 and 用 &， or 用 | customer_df.where((customer_df['Number_of_houses']>2) & (customer_df['Avg_Salary']>50000)).select(['Number_of_houses', 'Avg_Salary']).show() 分组聚合排序 # 分组聚合 customer_df.groupby(['Number_of_houses', 'Avg_Salary']).count().show() # 分组聚合排序 customer_df.groupby(col).count().orderBy('count', ascending=False).show(truncate=False) F函数计算 from pyspark.sql import functions as F # mean求平均，max求最大值，min求最小值，count统计数量，sum求和，collect_set统计所有出现的值去重，collect_list统计所有出现的值不去重；alias给结果字段命名 customer_df.groupBy('Avg_age').agg(F.mean('Avg_Salary').alias('mean_salary')).show() 添加字段 # 添加一个常量字段 customer_df = customer_df.withColumn('married', F.lit('已婚')) 用户自定义函数 # 用户自定义函数(user defined functions)UDF from pyspark.sql.functions import udf from pyspark.sql.types import StringType def age_label(age): if age == '20-30 years': return '非常年轻' if age == '30-40 years': return '中青年' if age == '40-50 years': return '中年' else: return '老年' age_udf = udf(age_label, StringType()) customer_df = customer_df.withColumn('age_label', age_udf(customer_df['Avg_age'])) # 使用pandas自定函数UDF from pyspark.sql.functions import pandas_udf, PandasUDFType salary_min = customer_df.select(['Avg_Salary']).agg(F.min('Avg_Salary')).first()[0] salary_max = customer_df.select(['Avg_Salary']).agg(F.max('Avg_Salary')).first()[0] def min_max_scale(col_value): return (col_value - salary_min) / (salary_max - salary_max) pd_udf = pandas_udf(min_max_scale, DoubleType()) customer_df = customer_df.withColumn('salary_scale', pd_udf(customer_df['Avg_Salary'])) 联表 # on表示联表字段，how表示方式：inner，left， right，outer customer_df.join(age_dict_df, on='Avg_age', how='inner').show(10) 透视表 # groupby表示行索引，pivote表示列索引， all_df.groupby('age_name').pivot('Number_of_houses').agg(F.count('Number_of_houses')).fillna(0).fillna('其他').show() 跳到最后 Copyright © book.stolenzc.com 2021-2023 all right reserved，powered by GitbookFile Modify: 2023-06-27 07:48:51 "},"GoNote.html":{"url":"GoNote.html","title":"Go笔记","keywords":"","body":"安装及配置 安装包下载地址: Go安装包下载 go 模块包查找位置: Go package Windows 安装和环境变量配置 下载 go 安装包 msi 文件，按照提示进行按照 安装完成后重启所有终端或命令行 Linux 或 MacOS 安装和配置环境变量 下载go包 wget -c https://go.dev/dl/go1.19.5.linux-amd64.tar.gz 删除之前的go安装包 rm -rf /usr/local/go 将安装包解压到指定目录 tar -C /usr/local -xzf go1.19.5.linux-amd64.tar.gz 配置环境变量 export PATH=$PATH:/usr/local/go/bin 卸载 删除 go 的安装目录，通常为 /usr/local/go 删除 go 的环境变量，通常为 /etc/profile 或者 ~/.bash_profile 中的 /usr/local/go/bin 目录 配置 使用go命令配置： go env -w GOPROXY=https://goproxy.cn,direct - 配置proxy go env -w GO111MODULE=\"on\" - 配置使用go module，1.13版本后默认开启 使用环境变量配置 export GO111MODULE=\"on\" - 配置使用go module，1.13版本后默认开启 export GOPROXY=https://goproxy.io - 配置proxy 相关命令 go version - 查看go的版本 go build - 项目目录下编译，在该项目目录下生成可执行文件 go build 路径名 - 在其他路径下执行go build，路径名从工程目录的scr开始往下写，在当前目录下生成可执行文件 go build -o 自定义文件名 - 自定义可执行文件文件名 go run 源码文件名 - 以脚本文件执行，不生成可执行文件 go install - 类似分两步执行，第一步为执行go build，第二步为将可执行文件移动到GOPATH/bin文件夹下 go env - 查看所有go的环境配置 -w - 可以以 NAME=VALUE 的方式修改环境变量，例如：go env -w GO111MODULE=on -u - 将用 -w 设置的变量恢复为默认值，例如：go env -u GO111MODULE -json - 以json格式输出 go get - 下载安装第三方包 -t - 让命令程序同时下载并安装指定的代码包中的测试源码文件中依赖的代码包。 -u - 让命令利用网络来更新已有代码包及其依赖包。默认情况下，该命令只会从网络上下载本地不存在的代码包，而不会更新已有的代码包。 go mod - 使用go module管理三方包 go clean - 命令会删除掉执行其它命令时产生的一些文件和目录 跨平台编译 命令格式 SET CGO_ENABLED=0 // 禁用CGO，使用cgo不支持跨平台，默认值为1 SET GOOS=linux // 目标平台是linux，windows写windows，mac写drawin SET GOARCH=amd64 // 目标处理器架构是amd64 runtime.GOOS - 获取当前操作系统平台 注意事项 注释： // - 行注释 /* */ - 块注释 大括号：Go语言规定，左括号必须与关键字在一行，不能放在其他位置。 for {// 错误，无法通过编译 xxx } 注意：{必须和关键字在同一行，如果有类似else的语句，else必须和上一个语句块的}在一行 go mod管理包 使用 go mod init 项目名称 初始化项目，如 go mod init github.com/stolenzc/hello_world vscode配置以下内容使用vendor依赖 \"go.toolsEnvVars\": { \"GOFLAGS\": \"-mod=vendor\" } 使用 go mod tidy 维护go.mod文件。 使用 go build -mod=vendor 使用vendor目录的依赖进行编译 常量变量和标识符 标识符规则 数字、字母、下划线组成，数字不能开头 变量和函数命名规范遵循驼峰原则 可见性 声明在函数内部，是函数的本地值，仅在函数内部可用 声明在函数外部，对当前包可见，同一个包的所有.go文件均可见 声明在函数外部且首字母是大写，对所有包可见，是全局值 关键字 25个关键字 break default func interface select case defer go map struct chan else goto package switch const fallthrough if range type continue for import return var 37个保留字 Constants: true false iota nil Types: int int8 int16 int32 int64 uint uint8 uint16 uint32 uint64 uintptr float32 float64 complex128 complex64 bool byte rune string error Functions: make len cap new append copy close delete complex real imag panic recover 变量 GO声明的四种方式 var（声明变量） const（声明常量） type（声明类型） func（声明函数） 变量声明 var name string // 默认声明 var ( name string age int ) // 批量声明 var name string = \"大锤\" // 声明并初始化 var age = 18 // 自动识别补足类型 name := \"大锤\" // 短变量声明，不能用于全局变量 var name, age = \"大锤\", 18 _ - 匿名变量不需要声明，不分配内存，可以重复使用 注意 默认初始化值：int(0), float(0), string(\"\"), boolean(false), 切片、函数、指针(nil) GO语言中局部变量声明后必须使用 匿名变量不会分配内存空间，可以重复声明 常量 常量声明用const，常量在声明时必须赋值： 声明 const pi = 3.14259265 //不需要类型声明，自动推导，必须赋值 const ( pi = 3.14 e = 2.7182 n ) // 多个常量声明，不写值默认等于上一行的值 iota - 常量计数器，const出现被置为零，每新增一行，iota值加1 // 遇到const就置零 const n5 = iota //0 const ( a, b = iota + 1, iota + 2 //1,2 c, d //2,3 e, f //3,4 ) 数据类型 值类型和引用类型 值类型： int, int8, int16, int32, int64 uint, uint8, uint16, uint32, uint64 float32, float64 complex64, complex128 string, bool, array 引用类型： slice, map, chan 整型 类型 描述 uint8 无符号 8位整型 (0 到 2^8-1) uint16 无符号 16位整型 (0 到 2^16-1) uint32 无符号 32位整型 (0 到 2^32-1) uint64 无符号 64位整型 (0 到 2^64-1) int8 有符号 8位整型 (-2^7 到 2^7-1) int16 有符号 16位整型 (-2^15 到 2^15-1) int32 有符号 32位整型 (-2^31 到 2^31-1) int64 有符号 64位整型 (-2^63 到 2^63-1) uint 32位操作系统上就是uint32，64位操作系统上就是uint64 int 32位操作系统上就是int32，64位操作系统上就是int64 uintptr 无符号整型，用于存放一个指针 len(v Type) int - 返回数据类型占用的字节数 0b开头表示二进制数，0o开头表示八进制数，0x开头表示十六进制数 123_456 允许用_分割数字，等同于123456 浮点型 类型 描述 float32 最大范围3.4e38，可以使用math.MaxFloat32查看 float64 最大范围1.8e308，可以说使用math.MaxFloat64查看 复数 类型 描述 complex64 complex64的实部和虚部为32位 complex128 complex128的实部和虚部为64位 real(c ComplexType) FloatType - 返回complex的实部 imag(c ComplexType) FloatType - 返回complex的虚部 布尔 类型 描述 bool 有true和false两个值，不可参与其他类型运算，无法转换为其他类型 字符 类型 描述 byte uint8类型，代表了ASCII码的一个字符。 rune int32类型，代表一个 UTF-8字符。 字符串 注意：字符串不可变，修改字符串通常需要转换为字符的切片类型，[]byte或[]rune，然后进行修改。会重新进行内存分配。 类型 描述 string 需要用\"\"包裹，多行字符串使用反引号`包裹，使用UTF-8编码 字符串转义 转义符 含义 \\r 回车符（返回行首） \\n 换行符（直接跳到下一行的同列位置） \\t 制表符 \\' 单引号 \\\" 双引号 \\\\ 反斜杠 字符串常用操作 方法 介绍 len(str) 求长度，获得的是字节长度 +或fmt.Sprintf 拼接字符串 字符串 str 的第 1 个字节：str[0] 第 i 个字节：str[i-1] 最后 1 个字节：str[len(str)-1] 类型转换 类型(表达式) - 将表达式的结果转换为所指定的类型 格式化占位符号 符号 含义 %d %b %o 表示 十/二/八 进制数 %x %X 表示十六进制数，字母用 小/大 写 %f %.nf 表示浮点数，n为保留小数位数 %U Unicode格式 %s %q 输出字符串表示（string或[]byte)，q为%s外加双引号围绕 %p 指针，格式为0x开头的十六进制数 %t 布尔值 %T 相应值的类型 %v 相应值的默认格式 %+v 打印结构体会添加字段名 %#v 相应值的go语法表示，类型+值 运算符 +、-、*、/、%、 - 加减乘除余 注意：++（自增）和--（自减）在Go语言中是单独的语句，并不是运算符 ==、!=、>、>=、、 - 关系运算符 &&、||、! - 逻辑运算符 &、|、^、>>、 - 位运算符（与、或、异或、右移、左移） =、+=、-=、*=、\\=、%=、、>>=、&=、|=、^= - 赋值运算符（等、加等、减等、乘等、除等、余等、左移等、右移等、与等、或等、异或等） 指针 Go 语言的取地址符是 &，放到一个变量前使用就会返回相应变量的内存地址。 var intP *int - 定义一个指向整型的指针 intP = &i1 - 给指针变量赋值 *intP - 获取i1的值 指针的一些特点： 指针的格式化标识符为 %p 空指针值为nil go语言中无法进行指针运算 数组 注意：数组是定长的 声明： //类型是[5]int，是一个数组类型，函数调用会进行拷贝操作，不会修改实参 var arr1 [5]int //类型是*[5]int，是一个指针，函数调用会修改实参 var arr1 = new([5]int) //创建并初始化 var arrAge = [5]int{18, 20, 15, 22, 16} var arrLazy = [...]int{5, 6, 7, 8, 22} //实际为切片 var arrKeyValue = []string{3: \"Chris\", 4: \"Ron\"}//给指定下标赋值 for-range操作数组 //获取的分别是下标和值 for index, value := range arr{} 切片 切片是引用类型，长度可变 声明： //不需要说明长度，未初始化之前默认为 nil，长度为 0 var identifier []type //初始化 var slice1 []type = arr1[start:end] var x = []int{2, 3, 5, 7, 11} //用make创建一个切片，cap可不填。默认为len的长度 var slice1 []type = make([]type, len, cap) var slice2 []int = new([100]int)[0:50] 注意： make(T)返回一个类型为T的初始值，适用于切片，map和channel new(T)返回一个类型为*T的内存地址，指向T，使用于数组和结构体 切片的方法： len() - 计算切片的长度 cap() - 切片的最长长度。等于切片的长度 + 数组除切片之外的长度 copy(dst, src []T) - 将类型为 T 的切片从源地址 src 拷贝到目标地址 dst，覆盖 dst 的相关元素，并且返回拷贝的元素个数 slice1 = append(slice1, silce2...) - 将切片2追加到切片1后 a = append(a[:i], a[i+1:]...) - 删除位于索引 i 的元素 a = append(a[:i], a[j:]...) - 切除切片 a 中从索引 i 至 j 位置的元素 a = append(a, make([]T, j)...) - 为切片 a 扩展 j 个元素长度 a = append(a[:i], append([]T{x}, a[i:]...)...) - 在索引 i 的位置插入元素 x a = append(a[:i], append(make([]T, j), a[i:]...)...) - 在索引 i 的位置插入长度为 j 的新切片 a = append(a[:i], append(b, a[i:]...)...) - 在索引 i 的位置插入切片 b 的所有元素 x, a = a[len(a)-1], a[:len(a)-1] - 取出位于切片 a 最末尾的元素 x a = append(a, x) - 将元素 x 追加到切片 a Map map是引用类型，用:=需要用make来分配内存， map是无序的 声明： var map1 map[keytype]valuetype var map1 map[string]int //map可以不固定大小，也可以设定cap标明map的最大容量 var map2 := make(map[string]int, cap) 注意： 数组、切片和结构体不能作为 key，string、int、float、指针、接口类型可以 map排序需要先把key取出来进行排序，在根据排序后的key来取value map的方法： len(map1) - 获取map的键值对数量 val1, isPresent = map1[key1] - 判断map1是否存在key1这个键，isPresent为true表示存在，为false表示不存在 delete(map1, key1) - 删除key1，不存在不会报错 for key, value := range map1{} - for-range循环得到的是key和value，只取一个值得到的是key 流程控制 if if condition1 { // do something } else if condition2 { // do something else } else { // catch-all or default } condition1 处可以包含多条语句 for for 初始语句;条件表达式;结束语句{ 循环体语句 } 初始语句和结束语句都可以省略，但是分号不能省略 当初始语句和结束语句同时省略时，可以省略分号 当for后没有条件时，为死循环 for循环可以通过break、goto、return、panic语句强制退出循环 for-range for 值1, 值2 := range 值3{ 循环体语句 } for range遍历数组、切片、字符串、map 及通道（channel） 数组、切片、字符串返回索引和值 map返回键和值 通道（channel）只返回通道内的值 switch-case func switchDemo1() { finger := 3 switch finger { case 1: fmt.Println(\"大拇指\") case 2: fmt.Println(\"食指\") case 3: fmt.Println(\"中指\") case 4: fmt.Println(\"无名指\") case 5: fmt.Println(\"小拇指\") fallthrough default: fmt.Println(\"无效的输入！\") } } case执行后不会继续向后执行 使用fallthrougt来继续向后执行，实现C语言默认的switch-case模式 switch后面也可以不写任何值，默认为True进行case判断 标签与goto 标签：大写字母后面连接冒号。HERE: goto加标签可以跳到标签处继续执行。goto HERE Break break语句可以结束for、switch和select的代码块。 break语句还可以在语句后面添加标签，表示退出某个标签对应的代码块，标签要求必须定义在对应的for、switch和 select的代码块上。 Continue continue语句可以结束当前循环，开始下一次的循环迭代过程，仅限在for循环内使用。 在 continue语句后添加标签时，表示开始标签对应的循环。 十. 常用包介绍 1. bytes bytes.Buffer - 一种长度可变的bytes，提供Read和Write方法 通过buffer串联字符串: var buffer bytes.Buffer buffer.WriteString(s)//s追加到buffer后面 s = buffer.String()//将buffer转换为字符串 2. sort Ints(x []int) - 对int类型对切片排序 IntsAreSorted(x []int) bool - 检查数组是否已经排序 Float64s(x []float64) - 对float64元素排序 Strings(x []string) - 排序字符串元素 SearchInts(a []int, x int) int - 搜索n在a中的位置。使用的是二分法，先排序后搜索 SearchFloat64s(a []float64, x float64) int - 搜索float64 SearchStrings(a []string, x string) int - 搜索字符串 3. strings HasPrefix(s, prefix string) bool - 判断s是否以prefix开头 HasSuffix(s, suffix string) bool - 判断s是否以suffix结尾 Contains(s, substr string) bool - 判断s是否包含substr Index(s, substr string) int - 获取substr在s中第一次出现的索引，-1表示不存在 LastIndex(s, substr string) int - 获取substr在s中第最后出现的索引，-1表示不存在 IndexRune(s string, r rune) int - 查询非ASCII字符在s中的位置 Replace(s, old, new string, n int) string - 将s中的old替换为new，n为替换次数，-1为全部替换 Count(s, substr string) int - 计算substr在s中出现的非重叠次数 Repeat(s string, count int) string - 返回s重复count次的字符串 ToLower(s string) string - 将s中所有字符转为小写 ToUpper(s string) string - 将s中所有字符转为大写 Trim(s, cutset string) string - 剔除字符串开头和结尾的cutset字符 TrimLeft(s, cutset string) string - 剔除字符串开头的cutset字符 TrimRight(s, cutset string) string - 剔除字符串结尾的cutset字符 TrimSpace(s string) string - 剔除字符串开头和结尾的空白符号 Fields(s string) []string - 将s用连续的空格进行分割，返回字符串切片 Split(s, sep string) []string - 将s用sep进行分割，返回字符串切片 Join(elems []string, sep string) string - 将切片元素通过sep进行连接 NewReader(str) - 生成一个Reader并读取字符串中的内容，返回一个指向该Reader的指针 Read() - 实现io.Reader接口 ReadByte() - 从字符串中读取下一个byte ReadRune() - 从字符串中读取下一个rune 4. strconv Itoa(i int) string 返回数字 i 所表示的字符串类型的十进制数。 FormatFloat(f float64, fmt byte, prec, bitSize int) string - 将浮点型转为字符串，fmt表示格式(b、e、f、g)，prec表示精度，bitSize 32表示float32，64表示float64 Atoi(s string) (i int, err error) - 将字符串转换为 int 型 ParseFloat(s string, bitSize int) (f float64, err error) - 将字符串转换为 float64 型 5. time Now() Time - 获取当前时间 Sleep(d Duration) - 暂停当前的goroutine，负值或零值会导致立即返回 func (t Time) Year() int - 返回t的年份 func (t Time) Month() Month - 返回t的月份 func (t Time) Day() int - 返回t的日期 func (t Time) Hour() int - 返回t的小时，[0, 23] func (t Time) Minute() int - 返回t的分钟，[0, 59] func (t Time) Second() int - 返回t的秒，[0, 59] func (t Time) UTC() Time - 将时间转换为UTC时间 func (t Time) Add(d Duration) Time - 返回t加上d后的时间 func (t Time) Sub(d Duration) Time - 返回t减去d后的时间 6. unicode/utf8 RuneCount(p []byte) int - 返回p的rune数量 RuneCountInString(s string) (n int) - 返回s中rune的数量 四. 函数 类型：普通函数，匿名函数，方法 1. 定义 func g() { } 调用：pack1.Function(arg1, arg2, …, argn) 注意： go不支持函数重载 切片（slice）、字典（map）、接口（interface）、通道（channel）这样的引用类型都是默认使用引用传递。修改形参会影响实参的值 2. 命名返回值 func funcname(input int) (return1 int, return2 int){ //计算过程 return } 注意：命名返回值return后不需要写返回内容，只有一个返回值时，命名返回值也需要括起来 3. 变长参数 func myfunc(a ...int){} 调用： slice := []int{1, 2, 3, 4} myfunc(slice...) 4. defer 将某个语句推迟到函数最后执行（return之后）。多个defer会以栈的形式执行（先进后出） func f() { for i := 0; i 5. 内置函数 名称 说明 close 用于管道通信 len、cap len 用于返回某个类型的长度或数量（字符串、数组、切片、map 和管道）；cap 是容量的意思，用于返回某个类型的最大容量（只能用于切片和 map） new、make new 和 make 均是用于分配内存：new 用于值类型和用户定义的类型，如自定义结构，make 用于内置引用类型（切片、map 和管道）。它们的用法就像是函数，但是将类型作为参数：new(type)、make(type)。new(T) 分配类型 T 的零值并返回其地址，也就是指向类型 T 的指针。它也可以被用于基本类型：v := new(int)。make(T) 返回类型 T 的初始化之后的值，因此它比 new 进行更多的工作new() 是一个函数，不要忘记它的括号 copy、append 用于复制和连接切片 panic、recover 两者均用于错误处理机制 print、println 底层打印函数，在部署环境中建议使用 fmt 包 complex、real imag 用于创建和操作复数 6. 匿名函数 func(x, y int) int { return x + y } 注意：匿名函数必须进行赋值或者被调用。否则会编译失败 7. 闭包 func main() { var f = Adder() fmt.Print(f(1), \" - \") fmt.Print(f(20), \" - \") fmt.Print(f(300)) //1 - 21 - 321 } func Adder() func(int) int { var x int return func(delta int) int { x += delta return x } } 五. 包 1. 标准库 unsafe: 包含了一些打破 Go 语言“类型安全”的命令，一般的程序中不会被使用，可用在 C/C++ 程序的调用中。 syscall-os-os/exec os: 提供给我们一个平台无关性的操作系统功能接口，采用类Unix设计，隐藏了不同操作系统间差异，让不同的文件系统和操作系统对象表现一致。 os/exec: 提供我们运行外部操作系统命令和程序的方式。 syscall: 底层的外部包，提供了操作系统底层调用的基本接口。 archive/tar 和 /zip-compress：压缩(解压缩)文件功能。 fmt-io-bufio-path/filepath-flag fmt: 提供了格式化输入输出功能。 io: 提供了基本输入输出功能，大多数是围绕系统功能的封装。 bufio: 缓冲输入输出功能的封装。 path/filepath: 用来操作在当前系统中的目标文件名路径。 flag: 对命令行参数的操作。 strings-strconv-unicode-regexp-bytes: strings: 提供对字符串的操作。 strconv: 提供将字符串转换为基础类型的功能。 unicode: 为 unicode 型的字符串提供特殊的功能。 regexp: 正则表达式功能。 bytes: 提供对字符型分片的操作。 index/suffixarray: 子字符串快速查询。 math-math/cmath-math/big-math/rand-sort: math: 基本的数学函数。 math/cmath: 对复数的操作。 math/rand: 伪随机数生成。需要设置随机种子才能实现不同的随机 sort: 为数组排序和自定义集合。 math/big: 大数的实现和计算。 　　 container-/list-ring-heap: 实现对集合的操作。 list: 双链表。 ring: 环形链表。 time-log: time: 日期和时间的基本操作。 log: 记录程序运行时产生的日志,我们将在后面的章节使用它。 encoding/json-encoding/xml-text/template: encoding/json: 读取并解码和写入并编码 JSON 数据。 encoding/xml:简单的 XML1.0 解析器,有关 JSON 和 XML 的实例请查阅第 12.9/10 章节。 text/template:生成像 HTML 一样的数据与文本混合的数据驱动模板（参见第 15.7 节）。 net-net/http-html:（参见第 15 章） net: 网络数据的基本操作。 http: 提供了一个可扩展的 HTTP 服务器和基础客户端，解析 HTTP 请求和回复。 html: HTML5 解析器。 runtime: Go 程序运行时的交互操作，例如垃圾回收和协程创建。 reflect: 实现通过程序运行时反射，让程序操作任意类型的变量。 2. regexp 正则表达式 ok, _ := regexp.Match(pat, []byte(searchIn)) - 简单模式匹配，ok返回true或flase ok, _ := regexp.MatchString(pat, searchIn) - 简单匹配字符串 re, _ := regexp.Compile(pat) - 将正则表达式编译为一个regexp对象 str := re.ReplaceAllString(searchIn, \"##.#\") - 将匹配到的部分替换为\"##.#\" str2 := re.ReplaceAllStringFunc(searchIn, f) - 参数为函数，匹配内容传入函数，替换为函数的返回内容 3. 锁和sync import \"sync\" type Info struct { mu sync.Mutex // ... other fields, e.g.: Str string } func Update(info *Info) { //函数想要改变这个变量可以这样写 info.mu.Lock() // critical section: info.Str = // new value // end critical section info.mu.Unlock() } //通过 Mutex 来实现一个可以上锁的共享缓冲器 type SyncedBuffer struct { lock sync.Mutex buffer bytes.Buffer } 4. 精密计算和big包 import ( \"math\" \"math/big\" ) im := big.NewInt(n)//构造大的整型数字 rm := big.NewRat(n, d)//构造大的有理数（n为分子，d为分母） 5. 自定义包和导入 导包格式 import \"包的路径或 URL 地址\" //用点作为别名可以直接使用包内的项目不需要通过包名.项目名 import . \"./pack1\" 使用go install来安装外部包 6. 使用godoc godoc -http=:6060 -goroot=\".\"访问自动生成的doc网页 六. 结构和方法 1. 结构体 定义： type identifier struct { field1 type1 tag(可忽略，只有reflect可以使用tag内容) field2 type2 ... } 声明结构体变量并赋值 type T struct {a, b int} var s T s.a = 5 s.b = 8 //new(Type)和&Type{}是等价的 ms := &struct1{10, 15.5, \"Chris\"} //&不是必须的，没有&获取的时一个值类型，有&得到的是一个指针类型 intr := T{0, 3} intr := T{b:5, a:1} intr := T{b:5} var ms struct1 ms = struct1{10, 15.5, \"Chris\"} 用new创建结构体返回新分配的内存的指针 var t *T = new(T) var t *T t = new(T) t := new(T) 可以使用点给结构体字段赋值(选择器):structname.fieldname = value 结构体或指针都能使用选择器，但用new和&创建但对象本质还是指针。 type myStruct struct { i int } var v myStruct // v是结构体类型变量 var p *myStruct // p是指向一个结构体类型变量的指针 v.i p.i 结构体嵌套，如双向链表 type Node struct { pr *Node data float64 su *Node } 查看结构体的内存占用：unsafe.Sizeof(T{}) 注意：make只能用于slice、map、channels，不能用于结构体 匿名字段和内嵌结构体 结构体如果不设置字段名，那么默认使用结构体名称.变量类型来获取值，在一个结构体中对于每一种数据类型只能有一个匿名字段 结构体中包含结构体，其结构类似继承。 type A struct { ax, ay int } type B struct { A bx, by float32 } func main() { b := B{A{1, 2}, 3.0, 4.0} fmt.Println(b.ax, b.ay, b.bx, b.by) fmt.Println(b.A) } 变量名相同，类型相同会冲突。类型不同需要使用子结构体名来获取 type A struct {a int} type B struct {a, b int} type C struct {A; B} var c C //无法获取c.a type D struct {B; b float32} var d D //可以获取d.b，因为类型不同，d.B.b获取整型b 2. 方法 定义： func (recv receiver_type) methodName(parameter_list) (return_value_list) { ... } recv类似self或this，recv不能是接口类型，不能是指针类型，但是它可以是任何其他允许类型的指针。 方法和类型必须在同一个包里，所以不能在int、float等类型上定义方法。 如果结构体内的字段是私有的，外部包要访问该字段，需要写getter和setter方法,对于 setter 方法使用 Set 前缀，对于 getter 方法只使用成员名。 type Person struct { firstName string lastName string } func (p *Person) FirstName() string { return p.firstName } func (p *Person) SetFirstName(newName string) { p.firstName = newName } 内存状态 var m runtime.MemStats runtime.ReadMemStats(&m) fmt.Printf(\"%d Kb\\n\", m.Alloc / 1024) //获取以kb为单位的内存总量 //释放内存 runtime.GC() //对象在释放前执行的函数 runtime.SetFinalizer(obj, func(obj *typeObj)) 七. 接口与反射 1. 接口 定义 接口定义了一组方法（方法集），但是这些方法不包含（实现）代码：它们没有被实现（它们是抽象的）。接口里也不能包含变量。只包含一个方法的接口的名字由方法名加 [e]r 后缀，不适用于er时以 able 结尾，或者以 I 开头 type Namer interface { Method1(param_list) return_type Method2(param_list) return_type ... } 接口特性： 类型不需要显式声明它实现了某个接口：接口被隐式地实现。多个类型可以实现同一个接口。 实现某个接口的类型（除了实现接口方法外）可以有其他的方法。 一个类型可以实现多个接口。 接口类型可以包含一个实例的引用， 该实例的类型实现了此接口（接口是动态类型）。 即使接口在类型之后才定义，二者处于不同的包中，被单独编译：只要类型实现了接口中的方法，它就实现了此接口。 实现了接口类型的变量可以赋值给 接收者值 //接上段程序 type Person struct { side float32 } func (p *Person) Method1(param_list){ return return_value } func (p *Person) Method2(param_list){ return return_value } func main(){ p := new(Person) var ai Namer //实现了接口类型的变量可以赋值给接口接收者，此处相当于变量引用 ai = p } 可以创建接口数组 //Shaper是接口，r、q是实现了该接口类型的变量。r、q类型可以不同 shapes := []Shaper{Shaper(r), Shaper(q)} shapes := []Shaper{r, q} 接口的嵌套 一个接口可以包含一个或多个其他的接口，这相当于直接将这些内嵌接口的方法列举在外层接口中一样。 接口类型的断言 //varI是一个接口变量，T是类型指针，v是varI转换到类型T的值。ok表示是否转换成功 if v, ok := varI.(T); ok { // ... } 也可以使用type-switch来检测 //type这儿是固定关键字，T1和T2是不同的类型，不允许使用fallthrough switch t := varI.(type){ case *T1: //do something case *T2: //do something } 判断值是否实现了某个接口 //v表示值，Stringer表示接口名。 sv, ok := v.(Stringer); 显式声明实现了某个接口 type Fooer interface { Foo() ImplementsFooer() } type Bar struct{} func (b Bar) ImplementsFooer() {} func (b Bar) Foo() {} 空接口实现函数重载 //最后一个参数设置为空接口，允许传任何参数，即可实现函数重载 fmt.Printf(format string, a ...interface{}) (n int, errno error) 接口继承 一个类型包含（内嵌）另一个类型（实现了一个或多个接口）的指针时，这个类型就可以使用（另一个类型）所有的接口方法。 type Task struct { Command string *log.Logger } 2. 反射 var x float64 = 3.4 reflect.TypeOf(x)//float64 reflect.ValueOf(x)// //进行拷贝赋值 v := reflect.ValueOf(x) //Kind总是返回最底层类型 v.Kind() == reflect.Float64//true v.Type()//float64 v.Float()//3.4 v.Interface()//3.4 //是否可以赋值，返回false v.CanSet() //设置其为可以赋值 v = v.Elem() //赋值操作 v.SetFloat(3.1415) //反射结构类型，遍历结构内的字段 value := reflect.ValueOf(secret)//secret为结构体 value.NumField()//用for循环进行遍历 包的使用 unsafe unsafe.Pointer(x) - Pointer类型用于表示任意类型的指针，Pointer类型允许程序绕过类型系统读写任意内存 http func NewServeMux() *ServeMux - 多路复用处理函数 func (mux *ServeMux) Handle(pattern string, handler Handler) - 注册给定匹配字符串的处理程序 gorm.io/gorm go的数据库处理包 注意：需要_ \"github.com/go-sql-driver/mysql\" 和 \"gorm.io/driver/mysql\" 驱动支持 定义数据模型: type Product struct { gorm.Model Code string Price uint } protocol-buffers grpc的格式定义方法 message SearchRequest { required string query = 1; optional int32 page_number = 2; optional int32 result_per_page = 3; // required表示必填，optional可选项，repeated可重复项 // 使用repeated的效率不高，需要添加packed=true来提高效率 // repeated int32 samples = 4 [packed=true]; // 消息需要有唯一编码，reserved 编号或字段名表示保留该字段。 } message SearchResponse { // 定义消息的回复格式 } 五. Array数组 定义 var 数组变量名 [元素数量]元素类型 注意：数组的长度必须是常量，并且长度是数组类型的一部分。一旦定义，长度不能变。不同长度的数组也是不同的类型。 不赋值的变量默认为类型的默认值：int为0，bool为false，string为\"\" 示例： var intArray [3]int; // [0, 0, 0] var numArray = [3]int{1, 2} // 用固定的值初始化变量 var numArray = [...]int{1, 2} // 自动推断数组长度 a := [...]int{1: 1, 3: 5} // 使用指定索引值的方式来初始化数组 遍历 用for循环 var a = [...]string{\"北京\", \"上海\", \"深圳\"} for i := 0; i 用for-range循环 var a = [...]string{\"北京\", \"上海\", \"深圳\"} for index, value := range a { fmt.Println(index, value) } 注意：如果用for i := range a获取到的i是索引 方法 len(数组) - 获取数组的长度 注意 数组是值类型，赋值和传参会复制整个数组。因此改变副本的值，不会改变本身的值。 数组支持 “==“、”!=” 操作符，因为内存总是被初始化过的。 [n]*T表示指针数组，*[n]T表示数组指针 。 六. 切片 注意：切片是引用类型，内部结构包含地址、长度和容量，底层指向一个数组，使用前需要先开辟内存 定义 var 变量名 []类型 var a []string //声明一个字符串切片 var b = []int{} //声明一个整型切片并初始化 var c = []bool{false, true} //声明一个布尔切片并初始化 a[low : high : max] - 可以使用从数组切片的方式获得切片类型 方法 len(slice) - 获取切片的长度 cap(slice) - 获取切片底层的最大长度（注意：计算的是从切片开始位置到指向数组的最后的长度） make([]类型, size, cap) - size表示切片中元素的数量，cap表示切片的容量，size和cap都可以不填。当切片的无法存放跟多的值会自动重新分配内存 len(s) == 0 - 判断切片是否为空 copy(slice1, slice2) - 将slice2的元素拷贝到slice1 append(slice1, slice2...) - 将slice2添加到slice1后面 append(slice1, int1, int2, int3) - 将后面的值添加到slice1后面 append(slice[:i], slice[i+1:]) - 将slice删除指定下标的方法 七. map 注意：map是一种无序的基于key-value的数据结构，Go语言中的map是引用类型，必须初始化才能使用。 定义 map[KeyType]ValueType // 定义 make(map[KeyType]ValueType, [cap]) //分配空间，cap userInfo := map[string]string{ \"username\": \"user\", \"password\": \"password\", } // 定义并赋值 scoreMap := make(map[string]int, 8) scoreMap[\"张三\"] = 90 // 创建键值或修改键的值 遍历 使用for-range for key, value := range map1 { // 执行语句 } 注意： 使用for key := range map1只能获取到map1的key 方法 value, ok := map1[key] - 判断key是否在map1中，如果在，ok返回true，不在返回false delete(map1, key) - 删除map1中的key 八. 函数 定义 func 函数名(参数)(返回值){ 函数体 } 参数和返回值 参数简写 func intSum(x, y int) int { return x + y } 可变参数 func funcName(x1 int, x2 int, x ...int) int { // 函数体 } 注意：可变参数是指函数的参数数量不固定。Go语言中的可变参数通过在参数名后加...来标识。 可变参数通常要作为函数的最后一个参数。 多参数返回： func calc(x, y int) (int, int) { sum := x + y sub := x - y return sum, sub } 注意：多个返回值时参数后面的返回值必须用()将所有返回值包裹起来。 返回值命名： func calc(x, y int) (sum, sub int) { sum = x + y sub = x - y return } 注意：返回值命名相当于函数的开头就定义了这两个变量，不需要再次进行定义 返回值补充： func someFunc(x string) []int { if x == \"\" { return nil // 没必要返回[]int{} } ... } 变量作用域： 局部变量和全局变量冲突了。优先使用局部变量 函数类型与变量 定义一个函数类型 type calculation func(int, int) int 凡是满足该参数和返回值的函数都是该类型的函数，该类型的实例可以接受实现了该类型函数的赋值 func add(x, y int) int { return x + y } var c calculation c = add 高阶函数 高阶函数分为函数作为参数和函数作为返回值两部分。 函数作为参数 func add(x, y int) int { return x + y } func calc(x, y int, op func(int, int) int) int { return op(x, y) } func main() { ret2 := calc(10, 20, add) fmt.Println(ret2) //30 } 函数作为返回值 func do(s string) (func(int, int) int, error) { switch s { case \"+\": return add, nil case \"-\": return sub, nil default: err := errors.New(\"无法识别的操作符\") return nil, err } } 匿名函数 没有函数名的函数称为匿名函数 func(参数)(返回值){ 函数体 } 匿名函数执行需要复制给变量调用或者定义时执行 func main() { // 将匿名函数保存到变量 add := func(x, y int) { fmt.Println(x + y) } add(10, 20) // 通过变量调用匿名函数 //自执行函数：匿名函数定义完加()直接执行 func(x, y int) { fmt.Println(x + y) }(10, 20) } 闭包 Gin框架 基础概念 源码地址：gin 优点： 速度快，类似python中的flask，小而快 中间件，支持中间件处理 路由，非常简单实现路由解析功能，支持路由组 内置渲染，支持JSON，XML和HTML的格式渲染 安装gin框架： go get -u github.com/gin-gonic/gin 简单的gin程序 func main(){ engine := gin.Default() engine.handle(\"GET\", \"/hello\", func(context *gin.Context){ context.Writer.Write([]byte(\"hello, world\")) }) engine.run(\":8090\") } 异常 os.Exit(1): 程序立即退出 defer函数不会执行 log.Fatal(): 打印日志 退出程序 defer不会被执行 panic(): 函数立刻停止 defer函数执行 调用者收到panic 调用者执行defer函数 重复3、4步骤到最上层函数 执行panic行为 2. Go内置类型和函数 2.2 内置函数 append // 追加元素到数组、切片中，返回修改后的数组、切片 close // 主要用来关闭channel delete // 从map中删除key对应的value panic // 停止常规的goroutine （panic和recover：通常做错误处理） recover // 允许程序定义goroutine的panic动作 real // 返回complex的实部 imag // 返回complex的虚部 make // 用来分配内存，返回Type本身（只能用于slice，map，channel） new // 用来分配内存，主要用来分配值类型，如int，struct，返回指向type的指针 cap // 返回某个类型的最大容量（只能用于slice，map） copy // 用于复制和连接slice，返回复制的数目 len // 求长度，如string，array，slice，map，channel，返回长度 print/println // 底层打印函数，部署环境中建议用fmt包 2.3 内置接口 error接口 type error interface{ // 只要实现了Error()函数，返回值为string的都实现了err接口 Error() string } 3. init 和 main函数 3.1 init函数 init函数用于包（package）的初始化，主要有以下特征 init函数是用于程序执行前做包的初始化的函数，比如初始化包里的变量 每个包可以拥有多个init函数 包的每个源文件可以拥有多个init函数 同一个go文件的init调用顺序是从上到下的 同一个包中不同文件是按照文件名字符串比较从小到大顺序调用各文件中的init函数 不同包的init函数按照包导入的依赖关系决定该初始化函数的执行顺序 init函数不能被其他函数调用，而是在main函数执行之前自动调用 3.2 main函数 main函数是Go语言程序的默认入口函数（主函数） func main(){ // 函数体 } 3.3 init和main的异同 相同点： 两个函数在定义时不能有任何的参数和返回值，且Go程序自动调用 不同点： init可以应用于任意包中，且可以重复定义多个 main函数只能用于main包中，且只能定义一个 4. 命令 go env - 用于打印Go语言的环境信息。 go run - 命令可以编译并运行命令源码文件。 go get - 可以根据要求和实际情况从互联网上下载或更新指定的代码包及其依赖包，并对它们进行编译和安装。 go build - 命令用于编译我们指定的源码文件或代码包以及它们的 go install - 用于编译并安装指定的代码包及它们的依赖包。 go clean - 命令会删除掉执行其它命令时产生的一些文件和目录。 go doc - 命令可以打印附于Go语言程序实体上的文档。我们可以通过把程序实体的标识符作为该命令的参数来达到查看其文档的目的。 go test - 命令用于对Go语言编写的程序进行测试。 go list - 命令的作用是列出指定的代码包的信息。 go fix - 会把指定代码包的所有Go语言源码文件中的旧版本代码修正为新版本的代码。 go vet - 是一个用于检查Go语言源码中静态错误的简单工具。 go tool pprof - 命令来交互式的访问概要文件的内容。 5. 运算符 算术运算符： +、-、*、/、% - 加减乘除余 注意：++（自增）和--（自减）在Go语言中是单独的语句，并不是运算符 关系运算符： ==、!=、>、>=、 逻辑运算符： &&、||、! - 与、或、非（返回bool值） 位运算符： &、|、^、>>、 赋值运算符： =、+=、-=、*=、\\=、%=、>=、&=、|=、^= - 等、加等、减等、乘等、除等、余等、左移等、右移等、与等、或等、异或等 6. 下划线 _是特殊标识符，用来忽略结果。不需要提前定义，可以接受任何类型，不占用内存空间 在import中，使用_命名包表示只调用该包的init函数 在代码中，_表示忽略变量或者占位使用 9. 数组 9.1 定义 var 数组变量名 [元素数量]元素类型 示例： var intArray [3]int; // [0, 0, 0] var numArray = [3]int{1, 2} // 用固定的值初始化变量 var numArray = [...]int{1, 2} // 自动推断数组长度 a := [...]int{1: 1, 3: 5} // 使用指定索引值的方式来初始化数组 9.2 遍历 用for循环 var a = [...]string{\"北京\", \"上海\", \"深圳\"} for i := 0; i 用for-range循环 var a = [...]string{\"北京\", \"上海\", \"深圳\"} for index, value := range a { fmt.Println(index, value) } 9.3 方法 len(数组) - 获取数组的长度 cap(数组) - 获取数组的长度（元素的数量） 9.4 注意 如果用for i := range a获取到的i是索引 数组的长度必须是常量，并且长度是数组类型的一部分。一旦定义，长度不能变。不同长度的数组也是不同的类型。 不赋值的变量默认为类型的默认值：int为0，bool为false，string为\"\" 数组是值类型，赋值和传参会复制整个数组。因此改变副本的值，不会改变本身的值。 数组支持 “==“、”!=” 操作符，因为内存总是被初始化过的。 [n]*T表示指针数组，*[n]T表示数组指针 。 10. 切片 10.1 定义 var 变量名 []类型 var a []string //声明一个字符串切片 var b = []int{} //声明一个整型切片并初始化 var c = []bool{false, true} //声明一个布尔切片并初始化 10.2 方法 a[low : high : max] - 可以使用从数组切片的方式获得切片类型 len(slice) - 获取切片的长度 cap(slice) - 获取切片底层的最大长度（注意：计算的是从切片开始位置到指向数组的最后的长度） make([]类型, len, cap) - len表示切片中元素的数量，cap表示切片的容量，len和cap都可以不填。当切片的无法存放跟多的值会自动重新分配内存 len(s) == 0 - 判断切片是否为空 copy(slice1, slice2) - 将slice2的元素拷贝到slice1 append(slice1, slice2...) - 将slice2添加到slice1后面 append(slice1, int1, int2, int3) - 将后面的值添加到slice1后面 append(slice[:i], slice[i+1:]) - 将slice删除指定下标的方法 10.3 注意 切片是引用类型，内部结构包含地址、长度和容量，底层指向一个数组，使用前需要先开辟内存 string底层就是一个byte的数组，也可以进行切片操作 s := []byte(str) // 中文字符使用[]rune(str) 跳到最后 Copyright © book.stolenzc.com 2021-2023 all right reserved，powered by GitbookFile Modify: 2023-06-27 07:48:51 "},"JavaScriptNote.html":{"url":"JavaScriptNote.html","title":"前端","keywords":"","body":"前端笔记总结 一. HTML 1. 简单标签 注释: 网页结构: 网页标题及常规配置 网页显示内容 换行: 水平线: 空格: &nbsp; &emsp; nbsp表示一个一个空格，emsp表示一个字符长。 标题: 标题内容 标题标签为h1到h6 字体加粗: 内容 内容 strong有语气加强的作用 字体倾斜: 内容 内容 em有语气加强的作用 大于符号: &gt; 小于符号: &lt; 大于等于: &gte 小于等于: &lte 引号: &quot; 版权符号: &copy; 2. 图像标签 src - 图片的链接alt - 图片加载失败显示title - 为鼠标悬停显示文字width - 为宽度height - 为高度 3. 链接标签 内容 href - 链接的地址，#name值为当前页面锚点跳转target - 打开网页的位置 _blank - 空白页打开_self - 当前页打开 name - 定义锚点 4. 列表 无序列表: li标签内容 type - 无序列表前符号样式 disc - 实心圆，默认square - 实心框circle - 空心圆 有序列表: li标签内容 type - 有序列表前符号样式 1 - 数字a/A - 字母大小写i/I - 罗马数字大小写 自定义列表: dl - 声明定义列表dt - 声明列表项dd - 定义列表项内容 示例: 所属学院 计算机学院 专业 计算机软件工程 5. 表格 border - 设置表格边框宽度cellspacing - 边框宽度，html5不支持align - 水平对齐方式 left - 居左center - 居中right - 居右 valign - 垂直对齐 top - 顶部对齐middle - 中部对齐bottom - 底部对齐baseline - 基线对齐 表格标题: 表格页眉: 表格页脚: 表格主题: 如果使用thead、tbody、tfoot元素，就必需使用全部元素，他们的顺序是thead、tfoot、tbody 表格行: 表格头: 单元格: colspan - 跨行rowspan - 跨列 第一个单元格 第二个单元格 第三个单元格 第四个单元格 第五个单元格 6. 表单 原始内容 name='值' - 规定表单的名称action='值' - 提交表单的URLmethod='get/post' - 提交方式enctype='值' - 提交表单前进行编码，使用MIMO类型target='_blank/_self/_parent/_top' - 何处打开表单urlautocomplete='on/off' - 是否启动表单自动完成novalidate='novalidate' - 不验证表单 文本框: 密码框: 提交按钮: 重置按钮: 单选框/单选按钮: 按钮: 复选框: 下拉菜单: 菜单内容 多行文本框: 上传文件框: 图像域: 提示信息标签: 表单字段集: 字段级标题: html5 新增 datalist datalist 元素用于为文本框提供一个可供选择的列表 black blue green autocomplete autocomplete 属性规定表单是否应该启用自动完成功能：自动完成允许浏览器预测对字段的输入，浏览器基于之前键入过的值，应该显示出在字段中填写的选项。可选项为on和off autofocus autofocus 属性规定在页面加载时，域自动地获得焦点。适用于所有 标签的类型。 form form 属性规定输入域所属的一个或多个表单。form 属性适用于所有 标签的类型。form 属性必须引用所属表单的 id。 First name: Last name: multiple multiple 属性规定输入域中可选择多个值，适用于以下类型的 标签：email 和 file。 novalidate novalidate 属性规定在提交表单时不应该验证 form 或 input 域，适用于form和部分input类型 pattern pattern 属性规定用于验证 input 域的模式（pattern）。模式（pattern） 是正则表达式。pattern 属性适用于以下类型的 标签：text, search, url, telephone, email 以及 password。 placeholder placeholder 属性提供一种提示（hint），描述输入域所期待的值。适用于以下类型的 标签：text, search, url, telephone, email 以及 password required required 属性规定必须在提交之前填写输入域（不能为空）。适用于以下类型的 标签：text, search, url, telephone, email, password, date pickers, number, checkbox, radio 以及 file。 新增input类型 email, url, number, range number和range属性： max: 最大值 min: 最小值 value: 默认值 step: 数字间隔 时间日期选择器： date - 选取日、月、年 month - 选取月、年 week - 选取周和年 time - 选取时间（小时和分钟） datetime - 选取时间、日、月、年（UTC 时间）注意：此类型已被弃用，目前大多数浏览器都不再支持。 datetime-local - 选取时间、日、月、年（本地时间） color 类型用于选择颜色 7. 菜单 size: 表示下拉框展示的数据长度，更多数据使用滚动条 选项内容: 展示值 8. 文本域 clos 表示列数 rows: 表示行数 9. 框架 src: 地址 width: 宽 height: 高 frameborder: 边框宽度 将a标签的target设置为和iframe的name属性值一致，则可以点击a标签在iframe中加载网页 10. HTML5标签 section 表示文档中的一个区域（或节）。比如章节、页眉、页脚或文档中的其他部分，一般来说会包含一个标题。 article 标签定义独立的内容。常常使用在论坛帖子，报纸文章，博客条目，用户评论等独立的内容项目之中。article 可以嵌套，内层的 article 对外层的 article 标签有隶属关系。 nav 标签定义导航链接的部分：描绘一个含有多个超链接的区域，这个区域包含转到其他页面，或者页面内部其他部分的链接列表。 header 标签定义文档的页眉，通常是一些引导和导航信息。它不局限于写在网页头部，也可以写在网页内容里面。 footer 标签定义 section 或 document 的页脚，包含了与页面、文章或是部分内容有关的信息，比如说文章的作者或者日期。 它和 header 标签使用基本一样，可以在一个页面中多次使用，如果在一个区段的后面加入了 footer 标签，那么它就相当于该区段的页脚了。 aside 标签表示一个和其余页面内容几乎无关的部分，被认为是独立于该内容的一部分并且可以被单独的拆分出来而不会使整体受影响。其通常表现为侧边栏或者嵌入内容。他们通常包含在工具条，例如来自词汇表的定义。也可能有其他类型的信息，例如相关的广告、笔者的传记、web 应用程序、个人资料信息，或在博客上的相关链接。 11. Web Storage localStorage localStorage.setItem(key,value) - 在本地客户端存储一个字符串类型的数据。 localStorage.setItem.key=value - 也可以像这样直接存储。 localStorage.getItem(key) - 读取已存储在本地的数据，获取键值。 localStorage.key - 也可以像这样直接获取值。 localStorage.removeItem(key) - 移除已存储在本地数据，通过键名作为参数删除数据。 localStorage.clear() - 也可以一次性清除 sessionStorage用法和localStorage用法类似 二. CSS 1. 基本信息 注释: /* */ 2. 选择器 标签选择器 语法: 元素名称{属性:属性值;} 例句: p{background:red;} id选择器 语法: #id名称{属性:属性值;} 例句: #para1{text-align:center;} class选择器 语法: .class类名{属性:属性值;} 例句: .top{width:200px;} *通配符（全局选择器） 语法: *{属性:属性值;} 例句: *{padding:0;margin:0;} 交集选择器 语法: 选择器1选择器2{属性:属性值;} 例句:h1#center{color:red;} 注意: 两个选择器中不能有空格，必须连续书写 并集选择器 语法: 选择器1,选择器2{属性:属性值;} 例句: h1,div,#ppp{background:red;} 后代选择器 语法: 选择器1 选择器2{属性:属性值;} 例句: p div{color:red;} 子选择器 语法: 选择器1>选择器2{属性:属性值;} 例句: p>div{属性:属性值;} 伪类选择器 语法: a:link{属性:属性值;} - 超链接的初始状态 a:visited{属性:属性值;} - 超链接被访问后的状态 a:hover{属性:属性值;} - 鼠标悬停,即鼠标滑过超链接的状态 a:active{属性:属性值;} - 超链接被激活的状态,即鼠标按下时超链接的状态 3. 显示和隐藏 display:none; - 隐藏元素,该方式隐藏在页面中不占位 visibility:hidden; - 隐藏元素,该方式隐藏的元素在页面中占位 4. 背景 background - 简写属性，作用是将背景属性设置在一个声明中 background-attachment - 背景图像是否固定或者随着页面的其余部分滚动 scroll - 默认,滚动 fixed - 不滚动 inherit - 继承父元素设置 background-color - 设置元素的背景颜色 可以使用颜色的单词,也可以使用rgb来表示颜色(#000000) background-image - 把图像设置为背景(url(floder/img.gif)) 默认值是none,如果需要设置背景色,需要设置一个url值. background-position - 设置背景图像的起始位置 top/bottom/left/right/center/100px/5cm background-repeat - 设置背景图像是否及如何重复 no-repeat/repeat/repeat-x/repeat-y 5. 文本 文本样式的font属性 font-size - 文本大小 xx-small/x-small/small/medium/large/x-large/xx-large font-family - 文本字体 font-weight - 文本粗细:(400对应默认字体) font-style - 文本倾斜 normal - 默认,正常字体 italic - 倾斜字体 oblique - 倾斜字体 inherit - 继承父元素样式 color - 文本颜色 line-heigh - 文本行高 normal - 默认值 number - 设置数字,与当前字体相乘 length - 固定的行间距 文本样式的text属性 text-align - 水平对齐方式 left/right/center/justify(两端对齐) vertical-align - 垂直对齐方式 top/buttom/middle 文本样式修饰的运用规范 text-decoration - 文本修饰 none/underline(下划线)/overline(上划线)/line-through(添加删除)/blink(删除) text-indent - 文本缩进 value(数值,可以取负值,缩进在左边,只对首行起作用) letter-spacing - 字符间距 value(英文字母之间的间距) word-spacing - 字间距 value(英文单词之间的间距) white-space - 元素空白的处理方式 normal - 空白被浏览器忽略 pre - 空白会被浏览器保留 nowrap - 文本不会换行 pre-wrap - 保留空白符序列，但是正常地进行换行 pre-line - 合并空白符序列，但是保留换行符 text-transform - 控制元素中的字母 capitalize - 文本中的每个单词以大写字母开头 uppercase - 所有字母转大写 lowercase - 所有字母转小写 text-shadow - 文字添加阴影 h-shadow - 必需,水平阴影的位置,允许负值 v-shadow - 必需,垂直阴影的位置,允许负值 blur - 可选,模糊的距离 color - 阴影的颜色 word-wrap - 自动换行 normal - 默认,只允许在断字典换行 break-word - 在长单词或url内部进行换行 6. 列表 list-style - 简写属性,用于把所有用于列表的属性设置在一个声明中 list-style-image - 将图像设置为列表项标志 list-style-position - 设置列表中列表项标志的位置 inside - 列表项目标记放置在文本以内，且环绕文本根据标记对齐 outside - 默认值，保持标记位于文本的左侧 list-style-type - 设置列表项标志的类型 none - 无标记 disc - 默认，标记是实心圆 circle - 标记是空心圆 square - 标记是实心方块 list-style-type:url(floder/img.gif) - 图片作为列表符号 7. 盒子模型 overflow - 控制内容溢出元素框时在对应的元素区间内添加滚动条 visible - 默认值。内容不会被修剪，会呈现在元素框之外。 hidden - 内容会被修剪，并且其余内容是不可见的。 scroll - 内容会被修剪，但是浏览器会显示滚动条以便查看其余的内容。 auto - 如果内容被修剪，则浏览器会显示滚动条以便查看其余的内容。 text-overflow - 针对文本(必需和overflow:hidden;white-space:nowrap;一起使用) clip - 修剪文本 ellipsis - 显示省略号来代表被修剪的文本 string - 使用给定的字符串来代表被修剪的文本 width:值 - 盒模型的宽 height:值 - 盒模型的高 background-color:值 - 盒模型的背景 background-image:url(图片地址) - 盒模型的背景图片 border:线型(solid/dashed/dotted/double) 粗细(数值＋单位) 颜色; - 盒模型的边框 border-style - 设置样式 border-width - 边框宽度 border-color - 设置颜色 border-bottom - 下边框 border-top - 上边框 border-left - 左边框 border-right - 右边框 三. JavaScript基础语法 1.基本介绍 js是javascript的缩写，是web标准中的行为标准，主要负责网页中内容的改变 js是编程语言，是脚本语言。主要针对脚本开发 注意:js中严格区分大小写 1)内联 -> js代码写在标签事件相关属性中,例如:onclick 2)内部 -> js代码写在script标签中(script标签放在html中任何位置都有效) 3)外部 -> js代码写在js文件中,然后通过script标签在html中导入（导入相当于执行） 2.注释(同C) 单行注释:// 多行注释:/* */ 3.数据类型 3.1 关键字 break else new var typeof case finally return void catch for switch while default if throw delete in try do instanceof 3.2 数据类型 Number:数字类型 String:字符串 Boolean:布尔值 Array:数组 Object:对象 Map:map对象(同python中的字典)(ES6) Set:set对象(同python中的集合,(元素不重复))(ES6) NaN:not a number,注意:NaN===NaN结果为false,判断是否为NaN用isNaN() NaN === NaN //false isNaN(NaN) //true null:表示空 undefined:表示未定义 判断数据类型的方法用typeof typeof 123; //number 3.3 变量 3.2.1 变量名命名规范 数字 字母 _ $组成,数字不能开头 使用驼峰命名方式 3.2.2 直接赋值 变量名 = 值 注意:不管声明在什么地方,都是全局的 3.2.3 var 变量名 var 变量名 = 值 注意:如果声明在函数中,那么这个变量只能在函数中使用 3.2.4 let 变量名 let 变量名 = 值 注意:let声明的变量的作用域是当前{}中,如果没有声明在{}中就没有约束效果 3.2.5 多个变量同时赋值 ES6中新增了构析方法,可以同时对多个变量进行赋值 var [x, y, z] = ['hello', 'JavaScript', 'ES6'] 3.4 常量 声明方法:const 常量名 = 值 4.运算符 4.1 数学运算符 +, -, *, /, %, **(幂运算) ++自增加运算 4.2 比较运算符 >, =, ==\\!= -> 先自动转换类型,再进行比较 ===\\!== -> 不自动转换类型,直接比较 4.3 逻辑运算符 逻辑与&& 逻辑或|| 逻辑非! 5.判断\\循环结构 5.1 选择结构 5.1.1 if语句 1) if(条件语句){ ​ 代码段 } 2) if(条件语句){ ​ 代码段1 }else{ ​ 代码段2 } 3) if(条件语句1){ ​ 代码段2 }else if(条件语句2){ ​ 代码段2 }else if(条件语句3){ ​ 代码段3 }else{ ​ 代码段N } 5.1.2 switch语句 switch(表达式){ ​ case 值1:{ ​ 代码段2 ​ } ​ case 值2:{ ​ 代码段2 ​ } ​ ...... ​ default:{ ​ 代码段N ​ } } 5.1.3 三目运算符 表达式?表达式1:表达式2 5.2 循环结构 5.2.1 while循环 语法一: while(条件语句){ ​ 循环体 } 语法二: do{ ​ 循环体 }while(条件语句) 5.2.2 for循环 语法一: for(变量 in 序列){ ​ 循环体 } 注意:变量取到的不是元素,是下标或者属性名 语法二: for(表达式1;表达式2;表达式3){ ​ 循环体 } 5.2.3 循环中的关键字 break,continue用法同C语言和Python语言 6.函数 6.1 函数的声明 function 函数名(参数名1,参数名2,...){ ​ 函数体 ​ return 返回值 } 说明: 无返回值其实是返回undefined 6.2 函数的参数 6.2.1 关键字参数无效 function stu(name,age){ console.log('我是'+name+',我今年'+age) } stu(age=18,name=’小明’) //我是18,我今年小明 6.2.2 arguments js中所有的函数,都可以接收不定长的参数.除了通过形参以外,可以通过函数中的arguments去获取实参 6.2.3 rest ES6中新定义了一个函数参数rest,rest主要是接受除了赋值意外多余的传入参数,以数组的形式保存,rest只能写在最后面,前面用三个点隔开 function foo(a, b, ...rest) { console.log('a = ' + a); console.log('b = ' + b); console.log(rest); } foo(1, 2, 3, 4, 5); // 结果: // a = 1 // b = 2 // Array [ 3, 4, 5 ] 6.2 匿名函数 变量 = function (参数名1,参数名2,...){ ​ 函数体 } 6.3 箭头函数 (参数列表)=>{函数体} 箭头函数的this始终指向外层调用这的object //写法一 func3 = (x, y)=>x+y console.log(func3(10, 20)) //写法二 func3 = (x, y)=>{ return x+y } 6.4 迭代器 和python中一样,定义方法为function后面加*号 function* fib(max) { a = 0, b = 1, n = 0; while (n 7.字符串 7. 1 字符串相关属性 字符串.length 7. 2 字符串相关方法 用arr = new Array方式创建后用console.log(arr)打印,然后在浏览器中展开就能看到全部的方法 字符串.toUpperCase() - 把一个字符串全部变为大写 字符串.toLowerCase () - 把一个字符串全部变为小写 字符串.indexOf (字符串2) - 搜索字符串2在字符串中出现的位置,成功返回位置下标,失败返回-1 字符串.lastIndexOf(字符串) - 从右查找str中是否有括号中的字符串,有返回第一个字符的下标,没有返回-1 字符串.substring(下标1,下标2) - 返回字符串下标1到下标2的字符串,不包含下标2 字符串.substr(起始下标,截取长度) - 从起始下标开始,截取指定长度的字符串 字符串.charAt(下标) - 获取下标对应的值 字符串.charCodeAt(下标) - 获取对应下标值的ASCII码值 字符串.localCompare(另一个字符串) - 如果字符串大得1,另一个字符串大得-1,相同得0 字符串.replace(原来字符,新字符) - 返回一个替换后的字符串,(不是改str的内容)全部替换用正则 字符串.split(字符) - 用指定字符对原字符串进行分割 String.fromChatCode(编码) - 获取编码对应的字符(类方法) 7. 3 获取字符:字符串[下标] 注意:js中的下标只有正值0~长度-1 字符无法进行赋值操作 7. 4 相关运算 + -> js中字符串支持加运算,运算方法是只要加运算中有字符串,就把其他所有参与运算的变量都转换为字符串参与运算 7.5 转义字符 \\n – 换行 \\t – 制表 \\ - 反斜杠 \\x## - 用十六进制表示ASCII \\u#### - 用十六进制表示Unicode ES6用反引号表示多行字符串 console.log(`多行 字符串 测试`); 7.6 格式化字符串 用反引号可以进行格式化字符串 name = ‘小明’ console.log(\\`你好,${name}\\`) //你好,小明 8.数组 8.1 查 - 获取元素 1)获取单个元素:数组[下标] 2)遍历 方法一: for(变量 in 数组) ->遍历拿到下标 方法二 数组.forEach(function(元素,下标){ ​ 遍历后做的事情 }) // 同时遍历取到元素和下标 3)用属性查: 数组名.indexOf(元素) – 返回元素在字符串中的位置 数组名.indexOf(下标) – 返回字符串指定下标中的元素 数组名.lastIndexOf(值) - 从数组结尾往前寻找，返回第一个匹配的位置 数组名.slice(起始下标,终止下标) – 截取数组中从起始下标到终止下标(不包含)的字符并返回 8.2 增 – 增加元素 数组名.push(元素) - 在数组的最后添加一个元素 数组名.splice(开始下标, 0, 添加元素或列表) -> 将元素或列表添加到开始下标处 数组名.unshift(元素1,元素2,...) – 在数组开头添加多个元素 8.3 删 – 删除元素 数组名.pop() -> 删除数组的最后一个元素,并返回 数组名.shift() -> 删除数组的第一个元素,并返回 数组名.splice(开始下标,个数) -> 从开始下标开始删除指定个元素 8.4 改 – 修改元素 数组名[下标值] = 值 8.5 排序 数组名.sort(函数) -> 会产生新的数组,也会修改原数组 直接使用数组名.sort() -> 会将元素转换为字符串进行比较 sort可以传入函数对排序进行定制化 var arr = [10, 20, 1, 2]; arr.sort(function (x, y) { if (x y) { return -1; } return 0; }); // [20, 10, 2, 1] 8.6 数组方法 数组名.length – 返回组数的元素个数 数组名. concat(数组2) – 将数组2的元素拼接在数组1后面并返回,不改变数组1 数组名.join(字符) – 将数组元素用字符进行连接,返回一个字符串 数组名.reverse() - 将数组原数组倒置（改变原数组） 8.7 map和reduce 8.7.1 map map定义在Array中,作用是将Array中每一个元素都作用于map内的函数,使数组变为一个新的数组 var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]; console.log(arr.map(String)); // ['1', '2', '3', '4', '5', '6', '7', '8', '9'] 8.7.2 reduce reduce接收两个参数,返回一个参数,使数组以某一种方式运算得到一个值 var arr = [1, 3, 5, 7, 9]; arr.reduce(function (x, y) { return x + y; }); // 25 8.8 filter 用于过滤数组中的元素,后两个参数可以省略,返回true则元素保留,返回false则删除 var arr = ['A', 'B', 'C']; var r = arr.filter(function (element, index, self) { console.log(element); // 依次打印'A', 'B', 'C' console.log(index); // 依次打印0, 1, 2 console.log(self); // self就是变量arr return true; }); 9.对象 9.1 创建对象 1)对象值:{属性名1:属性值1,属性名2:属性名2.....} 2)new创建对象 obj2 = new Object() obj2.name = '张三' 9.2 构造方法 用来创建对象的方法(相当于python中的类) 1)声明构造方法 function 类名(){ ​ this.属性名1 = 属性值1 ​ this.属性名2 = 属性值2 ​ .... ​ return this } 2)通过构造方法创建对象 对象 = new 构造方法名() 注意:this相当于python中的self, 谁调用就指谁 9.3 添加对象属性 1)给一个对象添加属性:对象.属性名 / 对象[属性名] 2)给指定类的所有对象添加属性 类型名.prototype.属性名 = 值 9.4 判断对象中是否有某属性 属性名 in 对象名 10. 迭代对象(iterable) ES6中引入的新的数据类型 Array Map Set都输入iterable 遍历iterable使用for...of...语法 'use strict'; var a = [1, 2, 3]; for (var x of a) { console.log(x) } console.log('你的浏览器支持for ... of'); for...of是遍历元素本身 11. 数学方法 Math.round(数据)四舍五入 Math.ceil(数据)向上取整 Math.floor(数据)向下取整 Math.max(多个数据)取最大值 Math.min(多个数据)取最小值 Math.abs(数据)取绝对值 Math.pow(x,y)x的y次方 Math.sqrt(数据)开平方 parseInt(Math.random() * (y - x + 1) + x):随机生成xy之间的的一个整数,包含xy 12. 时间与日期方法 var d1 = Date() - 得到当前时间,括号中赋值表示得到指定时间对象，如果传入元组注意，月份从零开始数，不传表示为当前时间 var d4 = new Date(2019,0,1,12,13,24) - 表示一月一日 对象方法: d1.getFullYear d1.getMonth d1.getDate//获取日期 d1.getDay//获取星期 d1.getHours d1.getMinutes d1.getSeconds d1.getMilliseconds//获取毫秒 d1.getTime//获取距离1970年的毫秒数 时间计算结果为毫秒。 13. base64/百分号编码 btoa('字符串') - 将字符串转换为base64编码 atob('base64编码') - 将64编码转换为字符串 encodeURIComponent('字符串') - 将字符串转换为百分号编码 decodeURIComponent('百分号编码') - 将百分号编码转换为字符串 四. DOM 1.DOM简介 DOM(document object model) - 文档对象模型 js中默认创建了document对象,表示网页内容.整个document是一个树结构,网页中添加的标签是数结构的节点(又叫元素),如果想要在js中获取网页中的标签,都要通过document去获取 2.DOM获取节点 2.1 直接获取节点 2.1.1 通过id获取标签 document.getElementById('id值') -> 返回当前页面中id是指定值的标签 2.1.2 通过class获取标签 document.getElementsByClassName('class值') -> 返回当前页面中所有class是指定值的标签,返回的是序列(类似数组) 注意:此处不是数组,故不能用for-Each方式进行遍历 2.1.3 通过标签名获取标签 document.getElementsByTagName('标签名') -> 返回当前页面中所有指定类型的标签,返回的是序列(类似数组)(其实返回的是对象,对象的属性是每一个节点对象) 2.1.4 通过name获取 document.getElementsByName('name属性值') 2.1.5 通过选择器获取 document.querySelector('CSS选择器') -> 如果有多个，则返回第一个 document.querySelectorAll('CSS选择器') -> 返回所有匹配对象 2.2 根据节点获取父子节点 2.2.1 获取父节点 节点.parentElement -> 获取指定节点的父节点 2.2.2 获取子节点 节点.children -> 获取指定节点所有的子节点,返回一个序列 节点. firstElementChild -> 获取第一个子节点 节点. lastElementChild -> 获取最后一个子节点 节点.childNodes -> 除了子标签以外,会将标签中的文字信息也作为子标签 3 节点操作 3.1 创建节点 document.createElement(标签名) -> 创建指定标签(创建好的标签不在网页中) 3.2 添加节点 节点1.appendChild(节点2) -> 在节点1中最后添加节点2 节点1.insertBefore(节点2,节点3) -> 在节点1中的节点3前插入节点2 3.3 删除节点 节点1.removeChild(节点2) -> 删除节点1中的节点2 节点.remove() -> 删除指定节点 3.4 拷贝节点 默认浅拷贝,不拷贝子标签 节点.cloneNode() -> 复制指定节点产生一个新的节点,不拷贝子节点, 默认不显示 节点.cloneNode(true) -> 深拷贝,复制指定节点产生一个新的节点,节点中的子节点也会被拷贝 3.5 替换节点 替换标签要用父标签来操作 节点1.replaceChild(节点2(new),节点3(old)) -> 将节点1中的节点3替换为节点2 4 DOM属性 4.1 文本节点 4.1.1 innerText 节点.innerText - 获取节点内容;只获取整个节点中所有的文本信息（包括子标签内的文本）,不获取子标签信息 节点.innerText = 值 - 修改节点内容;如果内容中有标签语法,不会有效 4.1.2 innerHTML 节点.innerHTML - 获取节点内容;获取整个节点中所有的文本信息和子标签信息 节点.innerHTML = 值 - 修改节点内容;如果内容中有标签语法,会有效 4.1.3 outerText 节点.outerText - 获取包含自己在内的节点内容，如果有子标签，子标签的内容也获取，但不获取标签本身。 4.1.4 outerHTML 节点.outerHTML - 获取包含自己在内的节点内容，包括所有的标签。 4.2 获取\\修改属性值 4.2.1 普通属性 节点.属性名 - 获取节点属性 节点.属性名 = 值 - 修改节点属性 节点变量名.getAttribute('属性名') - 获取节点属性 节点变量名.setAttribute('属性名', '新的属性值') - 修改节点属性 节点变量名.attributes - 获取当前节点的所有属性节点 4.2.2 特殊属性 class属性 节点.className window.getComputedStyle(节点变量名, null).属性名 - 获取外部样式表属性 节点变量名.style.属性名 - 操作行间样式表 节点变量名.style['属性名'] - 操作行间样式表 4.3 删除节点属性 节点变量名.removeAttribute('属性名') 五. BOM 1.BOM简介 BOM(browser object model) - 浏览器对象模型 js中创建一个window对象,当前浏览器 js中声明的所有的全局变量都是绑定在window对象上的属性 window.document - html页面内容 window.frames - 框架集合 window.navigator - 浏览器描述信息 window.screen - 屏幕信息 2.window基本操作 2.1 打开新的窗口 window.open(url, target, 位置属性) - 打开一个指定窗口，url为空则为空白窗口； target: __self为当前标签页，默认为__black window.open('','','width=?,height=?') - 打开一个新的独立的窗口,并且设定窗口的大小,并且返回窗口对象 2.2 关闭新的窗口 窗口对象.close() window.close() - 关闭当前标签页 2.3 移动窗口 窗口对象.moveTo(x坐标,y坐标) - 将指定的小窗口移动到指定的位置 2.4 获取窗口大小 innerWidth\\innerHeight - 获取浏览用来显示网页内容的有效部分的宽度和高度(HTML中的body标签) outerWidth\\outerHeight - 获取整个浏览器的宽度和高度(HTML中的html标签) 2.5 弹框 2.5.1 alert alert(提示信息) 提示信息+确定按钮 2.5.2 confirm confirm(提示信息) 提示信息+确定\\取消按钮;返回值是布尔值,true代表确认,false代表取消 2.5.3 prompt prompt(提示信息,输入框的默认值) 提示信息+输入框+确定\\取消按钮;点击确认,返回输入框的内容,点击取消,返回null 2.6 网页控制 2.6.1 location 控制网页地址栏和刷新 location.href - 控制浏览器地址栏内容 location.host - 获取当前的域名（不带http） location.origin - 获取当前页面的域名（带http） location.reload() - 刷新页面，括号中放true表示不带缓存 location.assign() - 加载新的页面 location.repalce() - 加载新的页面。不会在浏览器中的历史记录表中留下信息 2.6.2 history 控制网页历史记录和前进后退 window.history.length - 获取历史记录的长度 history.back() - 上一页 history.forward() - 下一页 history.go(num) - 往前(num>0)往后(num 3 定时器 3.1 setInterval()\\clearInterval() setInterval(回调函数,定时时长) - 每隔指定时长(单位毫秒)就调用一次回调函数;返回定时对象 clearInterval(定时器对象) - 停止指定的定时器 3.2 setTimeout()\\clearTimeout() setTimeout(回调函数,定时时长) - 指定时长后调用指定函数(回调函数只会调用一次) clearTimeout(定时器对象) 4 事件绑定 4.1 给标签的事件属性赋值 直接给标签的onclick属性赋值 通过标签的事件属性绑定事件1,事件驱动程序中this是window 按钮1 事件清除使用事件属性名.onclick = null 4.2 给节点的对象属性赋值 用函数名给节点的事件属性赋值;函数中的this是事件源 btnNode2 = document.getElementById('btn2') btnNode2.onclick = action2 4.3 给节点的对象属性赋匿名函数 用匿名函数给节点的事件属性赋值;函数中的this是事件源 document.getElementById('btn4').onclick = function(){ alert('你还在点击按钮') // 此处this代表事件源 console.log(this) } 4.4 使用addEventListener 事件源节点.addEventListener(事件类型名,事件驱动程序对应的函数) 注意:事件类型名是事件名去掉on之后的值;函数中的this是事件源 这种绑定方式可以同时给同一事件源的同一事件绑定不同的事件驱动程序 4.5 常见的事件类型 window.onload: 页面完全加载后触发 window.onunload: 页面完全卸载时触发，只有ie支持 window.onresize: 窗口变动事件 onclick: 鼠标点击事件 ondblclick: 双击事件 onmouseover:鼠标进入事件 onmouseout:鼠标离开事件 onmousedown:鼠标按下事件 onmouseup:鼠标抬起事件 onmousemove: 鼠标移动事件 onkeydown:键盘按下事件 onkeyup:键盘抬起事件 onfocus: 聚焦事件 onblur: 离焦事件 window.onscroll:鼠标滑动事件(滚轮) // 获取滚动条的位置 var a = document.documentElement.scrollTop || document.body.scrollTop // 获取窗口宽高 var w = document.documentElement.clientWidth || document.body.clientWidth || document.Screen.width var h = document.documentElement.clientHeight || document.body.clientHeight || document.Screen.height console.log(w, h) inputNode.onkeydown = pressKey function pressKey(event){ var keynum // 获取按下的键盘ascii码 keynum = event.keyCode } 4.6 事件的冒泡和捕获 事件冒泡:当父标签和子标签都绑定同一个事件时,当点击子节点,不仅会响应子节点的事件,还会响应父节点的事件.这种现象叫做事件冒泡. 捕获: 阻住当前事件传递给父标签 子节点事件.stopPropagation() 5. fetch网络请求 语法: fetch('url',{ 请求参数 }) .then((res)=>res.json()) .then((res)=>{ 获取数据后的操作 }) 说明: fetch获取到的数据为字符串数据，需要先进行格式转换才能使用，可以用res.json()转换，也可使用JSON.parse(字符串)进行转换。 get请求中中文需要以百分号方式显示，转换方法为: encodeURIComponent(中文) decodeURIComponent(百分号参数) 六. jQuery 1.介绍jQuery 1.1 什么是jQuery jQuery就是用js封装的一个库,主要解决原生js中DOM操作复杂\\麻烦的问题 js和jQuery可以混合使用 1.2 如何导入jQuery 1)导入本地jQuery: 2)导入远程的jQuery: 1.3 使用jQuery jQuery中提供了一个$,用来表示jQuery类 $(数据) - 可以创建jQuery对象,jQuery中提供的所有的属性和方法都是绑定在jQuery对象中的 1.4 ready方法 ready方法 - 页面加载完成后会自动调用和它关联的回调函数 $(document).ready(回调函数) 缩写方式:$(回调函数) 2.获取节点 2.1 常见的选择器(同css) 2.1.1 id选择器 $('#id值') 2.1.2 class选择器 $('.class值') 2.1.3 标签选择器 $('标签名') 2.1.4 群组选择器 $('选择器1,选择器2,...') 2.1.5 后代选择器 $('祖先选择器 后代选择器') $('夫选择器>子选择器') 2.2 其他选择器 $('p+a') - 选中紧跟着p标签的a标签 $('#pa~*') - 选中id是p1的标签后面所有的兄弟标签 $('p:first') - 选中第一个p标签 $('p:last') - 选中最后一个p标签 $('div *:first-child') - 选中id是div2中第一个子标签 2.3 节点值 jQuery中不管选择器选中了多少个标签,节点的结果都是一个容器型数据类型的数据,这个数据是jQuery对象.容器中的元素就是js的节点对象 节点jQuery对象和js对象的相互转换 js转jQuery - $(js对象) jQuery转js - 单独取出jQuery对象的元素 3.节点的增删 3.1 创建节点 创建出的节点不在body中,要进行添加才能到body中 $(html创建标签的语法) imgNode = $('') 3.2 添加节点 1)节点1.append(节点2) - 将节点2添加到节点1的最后,节点1和节点2是父子关系 2)节点1.prepend(节点2) - 将节点2添加到节点1的开头,节点1和节点2是父子关系 3)节点1.before(节点2) - 将节点2插入到节点1的前面,节点1和节点2是兄弟关系 4)节点1.after(节点2) - 将节点2插入到节点1的后面,节点1和节点2是兄弟关系 3.3 删除节点 1) 节点.remove() - 删除指定节点 2) 节点.empty() - 删除节点中所有的子标签 4.节点操作属性 4.1 特殊属性 4.1.1 标签内容 innerText(js) - text(jq) innerHTML(js) - html(jq) jq对象.text() - 获取标签内容 jq对象.text(值)- 给标签内容赋值 4.1.2 value属性 value(js) - val(jq) jq对象.val() - 获取标签value值 jq对象.val(值) - 给标签value赋值 4.1.3 样式属性 style(js) - css(jq) jq对象.css(css样式属性名, 属性值) – 给对象的一个属性赋值 jq对象.css({js样式属性名1:属性值1,js样式属性名2:属性值2,...}) – 给对象的多个属性赋值 4.1.4 class属性 节点.addClass(class值) - 给指定节点添加class属性值 节点.removeClass(class值) – 移除指定节点的指定class 4.2 普通属性 节点.attr(属性名) - 获取指定节点中指定属性的值 节点.attr(属性名,属性值) - 给指定节点的指定属性赋值 5.jQuery事件绑定 5.1 直接绑定事件 jq对象.on(事件名,事件驱动程序) 注意:此处的事件名是js中事件名去除on的名字 事件驱动程序中this表示事件源,this是js对象,$(this)才是jQuery对象 5.2 通过父标签去给子标签绑定事件 父标签.on(事件名, 选择器, 事件驱动程序) - 给指定节点中选择器选中的子标签绑定事 this代表事件源,指向所选择到的子标签 6.Ajax使用 6.1 什么是Ajax 什么是Ajax(Asynchronous Javascript And XML) - 异步js(在子线程中完成网络请求) Ajax是jQuery封装的,专门用来解决前端HTTP请求的一个库 相当于python中的requests模块 6.2 post请求 $.post(url, 参数对象, 请求成功的回调函数, 数据类型) post请求是将数据放在参数对象中进行传输,可传输大数据 6.3 get请求 $.get(url, 参数对象, 请求成功的回调函数, 数据类型) Get请求是将数据拼接在url后面进行传输,最大可传输1Kb的数据 注意:调用的时候数据放在参数对象中,在传输中自动拼接 6.4 ajax方法 $.ajax({ ​ url:请求地址, ​ data:请求参数, ​ type:请求方式(GET\\POST) ​ dataType:返回的数据类型 ​ success:请求成功后的回调函数, ​ error:请求失败后的回调函数 }) 6.5 Ajax代码示例 $.ajax({ url:'https://www.apiopen.top/satinApi', data:{type:1,page:1}, type:'GET', success:function(responsData){ console.log(responsData) dataArray = responsData.data for(x=0;x 七. vue.js 1. vue.js简介 Vue是js框架,用来让标签和数据的绑定更加简单 2. 导入方法 开发环境版本，包含了有帮助的命令行警告 生产环境版本，优化了尺寸和速度 3. 使用方法 3.1 创建vue对象语法: 变量 = new Vue({ el:选择器, data:对象 methods:对象 computed:对象 }) 说明: el后面为选择器，主要是用来选择标签的，语法同css选择器 data: 数据提供，所有vue的数据均保存在data对象中 methods: 方法提供，所有绑定vue方法的函数均保存在methods对象中 computed: 计算提供，提供一些计算方法 3.2 使用方法 标签内容: {{Vue中data的属性名\\computed方法名}} 标签属性: v-bind:标签属性名='Vue中的data属性名' 3.3 循环判断 v-if='Vue中data的属性名' - 如果属性为true,标签显示;如果为false,标签不显示 v-for = '变量名 in 序列' - 通过循环用数据决定产生多个标签 3.4 双向绑定 v-model='Vue对象的data属性名' - 只能和input中的value属性绑定 4. 事件绑定 v-on:事件名='Vue中methods中的属性名' - 给标签绑定vue事件，事件中的this指向当前Vue对象 事件捕获: v-on.事件名.stop='methods中的属性名' - 阻止事件冒泡(捕获事件) 计算属性: 计算属性应该有一个返回值，返回值作为数据提供给标签 八.常用js方法 1 判断是否滑倒页面底部 $(window).scrollTop()+$(window).height()>=$('body').height() //滑到页面底部返回true,未滑到返回false form表单中button默认会自动提交表单，设置type为button则会阻止自动提交，设置type为submit或者不设置则不会提交 Copyright © book.stolenzc.com 2021-2023 all right reserved，powered by GitbookFile Modify: 2023-06-27 07:48:51 "},"KubernetesNote.html":{"url":"KubernetesNote.html","title":"K8s","keywords":"","body":"k8s的介绍 1 应用部署方式的演变 1.1 应用部署方式的演变 在部署应用程序的方式上，主要经历了三个时代： 1⃣️ 传统部署 互联网早期，会直接将应用部署在物理机上。 优点：简单，不需要其他的技术参与。 缺点：不能为应用程序定义资源的使用边界，很难合理的分配计算机资源，而且程序之间容易产生影响。 2⃣️ 虚拟化部署： 可以在一台物理机上运行多个虚拟机，每个虚拟机都是独立的一个环境。 优点：程序环境不会相互产生影响，提供了一定程序上的安全性。 缺点：增加了操作系统，浪费了部分资源。 3⃣️ 容器化部署： 和虚拟化类似，但是共享了操作系统。 优点： ①可以保证每个容器拥有自己的文件系统、CPU、内存和进程空间等。 ②运行应用程序所需要的资源都被容器包装，并和底层基础架构解耦。 ③容器化的应用程序可以跨云服务商、跨Linux操作系统发行版进行部署。 1.2 容器化部署方式产生的问题及解决方案 容器化部署方式带来了很多的便利，但是也会带来一些问题，比如： 一旦容器故障停机了，怎么让另外一个容器立刻启动去替补停机的容器。 当并发访问量变大的时候，怎么做到横向扩展容器数量。 …… 这些容器管理的问题统称为容器编排问题，为了解决这些容器编排问题，就产生了一些容器编排的软件： Swarm：Docker自己的容器编排工具。 Mesos：Apache的一个资源统一管控的工具，需要和Marathon结合。 Kubernetes：Google开源的容器编排工具。 2 kubernetes简介 Kubernetes，是一个全新的基于容器技术的分布式架构领先方案，是Google严格保密十几年的秘密武器--Borg系统的一个开源版本，于2014年9月发布第一个版本，2015年7月发布第一个正式版本。 Kubernetes的本质是一组服务器集群，它可以在集群的每个节点上运行特定的程序，来对节点中的容器进行管理。它的目的就是实现资源管理的自动化，主要提供了如下的功能： 自我修复：一旦某一个容器崩溃，能够在1秒左右迅速启动新的容器。 弹性伸缩：可以根据需要，自动对集群中正在运行的容器数量进行调整。 服务发现：服务可以通过自动发现的形式找到它所依赖的服务。 负载均衡：如果一个服务启动了多个容器，能够自动实现请求的负载均衡。 版本回退：如果发现新发布的程序版本有问题，可以立即回退到原来的版本。 存储编排：可以根据容器自身的需求自动创建存储卷。 …… 3 kubernetes组件 3.1 Kubernetes组件介绍 一个kubernetes集群主要由控制节点（master）、工作节点（node）构成，每个节点上都会安装不同的组件。 控制节点（master）：集群的控制平面，负责集群的决策。 API Server：集群操作的唯一入口，接收用户输入的命令，提供认证、授权、API注册和发现等机制。 Scheduler：负责集群资源调度，按照预定的调度策略将Pod调度到相应的node节点上。 ControllerManager：负责维护集群的状态，比如程序部署安排、故障检测、自动扩展和滚动更新等。 Etcd：负责存储集群中各种资源对象的信息。 工作节点（node）：集群的数据平面，负责为容器提供运行环境。 Kubelet：负责维护容器的生命周期，即通过控制Docker，来创建、更新、销毁容器。 KubeProxy：负责提供集群内部的服务发现和负载均衡。 Docker：负责节点上容器的各种操作。 3.2 kubernetes组件调用关系的应用示例 以部署一个Nginx服务来说明Kubernetes系统各个组件调用关系： 1⃣️ 首先需要明确，一旦Kubernetes环境启动之后，master和node都会将自身的信息存储到etcd数据库中。 2⃣️ 一个Nginx服务的安装请求首先会被发送到master节点上的API Server组件。 3⃣️ API Server组件会调用Scheduler组件来决定到底应该把这个服务安装到那个node节点上。此时，它会从etcd中读取各个node节点的信息，然后按照一定的算法进行选择，并将结果告知API Server。 4⃣️ API Server调用Controller-Manager去调用Node节点安装Nginx服务。 5⃣️ Kubelet接收到指令后，会通知Docker，然后由Docker来启动一个Nginx的Pod。Pod是Kubernetes的最小操作单元，容器必须跑在Pod中。 6⃣️ 一个Nginx服务就运行了，如果需要访问Nginx，就需要通过kube-proxy来对Pod产生访问的代理，这样，外界用户就可以访问集群中的Nginx服务了。 4 kubernetes概念 Master：集群控制节点，每个集群要求至少有一个Master节点来负责集群的管控。 Node：工作负载节点，由Master分配容器到这些Node工作节点上，然后Node节点上的Docker负责容器的运行。 Pod：Kubernetes的最小控制单元，容器都是运行在Pod中的，一个Pod中可以有一个或多个容器。 Controller：控制器，通过它来实现对Pod的管理，比如启动Pod、停止Pod、伸缩Pod的数量等等。 Service：Pod对外服务的统一入口，其下面可以维护同一类的多个Pod。 Label：标签，用于对Pod进行分类，同一类Pod会拥有相同的标签。 NameSpace：命名空间，用来隔离Pod的运行环境。 k8s集群环境的搭建 1 环境规划 1.1 集群类型 Kubernetes集群大致分为两类：一主多从和多主多从。 一主多从：一个Master节点和多台Node节点，搭建简单，但是有单机故障风险，适合用于测试环境。 多主多从：多台Master和多台Node节点，搭建麻烦，安全性高，适合用于生产环境。 为了测试方便，本次搭建的是一主多从类型的集群。 1.2 安装方式 kubernetes有多种部署方式，目前主流的方式有kubeadm、minikube、二进制包。 minikube：一个用于快速搭建单节点的kubernetes工具。 kubeadm：一个用于快速搭建kubernetes集群的工具。 二进制包：从官网上下载每个组件的二进制包，依次去安装，此方式对于理解kubernetes组件更加有效。 我们需要安装kubernetes的集群环境，但是又不想过于麻烦，所以选择kubeadm方式。 1.3 主机规划 角色 IP地址 操作系统 配置 Master 192.168.18.100 CentOS7.8+，基础设施服务器 2核CPU，2G内存，50G硬盘 Node1 192.168.18.101 CentOS7.8+，基础设施服务器 2核CPU，2G内存，50G硬盘 Node2 192.168.18.102 CentOS7.8+，基础设施服务器 2核CPU，2G内存，50G硬盘 2 环境搭建 2.1 前言 本次环境搭建需要三台CentOS服务器（一主二从），然后在每台服务器中分别安装Docker（18.06.3）、kubeadm（1.18.0）、kubectl（1.18.0）和kubelet（1.18.0）。 没有特殊说明，就是三台机器都需要执行。 2.2 环境初始化 2.2.1 检查操作系统的版本 检查操作系统的版本（要求操作系统的版本至少在7.5以上）： cat /etc/redhat-release 2.2.2 关闭防火墙和禁止防火墙开机启动 关闭防火墙： systemctl stop firewalld 禁止防火墙开机启动： systemctl disable firewalld 2.2.3 设置主机名 设置主机名： hostnamectl set-hostname 设置192.168.18.100的主机名： hostnamectl set-hostname k8s-master 设置192.168.18.101的主机名： hostnamectl set-hostname k8s-node1 设置192.168.18.102的主机名： hostnamectl set-hostname k8s-node2 2.2.4 主机名解析 为了方便后面集群节点间的直接调用，需要配置一下主机名解析，企业中推荐使用内部的DNS服务器。 cat >> /etc/hosts 2.2.5 时间同步 kubernetes要求集群中的节点时间必须精确一致，所以在每个节点上添加时间同步： yum install ntpdate -y ntpdate time.windows.com 2.2.6 关闭selinux 查看selinux是否开启： getenforce 永久关闭selinux，需要重启： sed -i 's/enforcing/disabled/' /etc/selinux/config 临时关闭selinux，重启之后，无效： setenforce 0 2.2.7 关闭swap分区 永久关闭swap分区，需要重启： sed -ri 's/.*swap.*/#&/' /etc/fstab 临时关闭swap分区，重启之后，无效：： swapoff -a 2.2.8 将桥接的IPv4流量传递到iptables的链 在每个节点上将桥接的IPv4流量传递到iptables的链： cat > /etc/sysctl.d/k8s.conf # 加载br_netfilter模块 modprobe br_netfilter # 查看是否加载 lsmod | grep br_netfilter # 生效 sysctl --system 2.2.9 开启ipvs 在kubernetes中service有两种代理模型，一种是基于iptables，另一种是基于ipvs的。ipvs的性能要高于iptables的，但是如果要使用它，需要手动载入ipvs模块。 在每个节点安装ipset和ipvsadm： yum -y install ipset ipvsadm 在所有节点执行如下脚本： cat > /etc/sysconfig/modules/ipvs.modules 授权、运行、检查是否加载： chmod 755 /etc/sysconfig/modules/ipvs.modules && bash /etc/sysconfig/modules/ipvs.modules && lsmod | grep -e ip_vs -e nf_conntrack_ipv4 检查是否加载： lsmod | grep -e ipvs -e nf_conntrack_ipv4 2.2.10 重启三台机器 重启三台Linux机器： reboot 2.3 每个节点安装Docker、kubeadm、kubelet和kubectl 2.3.1 安装Docker 安装Docker： wget https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo -O /etc/yum.repos.d/docker-ce.repo yum -y install docker-ce-18.06.3.ce-3.el7 systemctl enable docker && systemctl start docker docker version 设置Docker镜像加速器： sudo mkdir -p /etc/docker sudo tee /etc/docker/daemon.json sudo systemctl daemon-reload sudo systemctl restart docker 2.3.2 添加阿里云的YUM软件源 由于kubernetes的镜像源在国外，非常慢，这里切换成国内的阿里云镜像源： cat > /etc/yum.repos.d/kubernetes.repo 2.3.3 安装kubeadm、kubelet和kubectl 由于版本更新频繁，这里指定版本号部署： yum install -y kubelet-1.18.0 kubeadm-1.18.0 kubectl-1.18.0 为了实现Docker使用的cgroup drvier和kubelet使用的cgroup drver一致，建议修改\"/etc/sysconfig/kubelet\"文件的内容： vim /etc/sysconfig/kubelet # 修改 KUBELET_EXTRA_ARGS=\"--cgroup-driver=systemd\" KUBE_PROXY_MODE=\"ipvs\" 设置为开机自启动即可，由于没有生成配置文件，集群初始化后自动启动： systemctl enable kubelet 2.4 查看k8s所需镜像 查看k8s所需镜像： kubeadm config images list 2.5 部署k8s的Master节点 部署k8s的Master节点（192.168.18.100）： # 由于默认拉取镜像地址k8s.gcr.io国内无法访问，这里需要指定阿里云镜像仓库地址 kubeadm init \\ --apiserver-advertise-address=192.168.18.100 \\ --image-repository registry.aliyuncs.com/google_containers \\ --kubernetes-version v1.18.0 \\ --service-cidr=10.96.0.0/12 \\ --pod-network-cidr=10.244.0.0/16 根据提示消息，在Master节点上使用kubectl工具： mkdir -p $HOME/.kube sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config sudo chown $(id -u):$(id -g) $HOME/.kube/config 2.6 部署k8s的Node节点 根据提示，在192.168.18.101和192.168.18.102上添加如下的命令： kubeadm join 192.168.18.100:6443 --token jv039y.bh8yetcpo6zeqfyj \\ --discovery-token-ca-cert-hash sha256:3c81e535fd4f8ff1752617d7a2d56c3b23779cf9545e530828c0ff6b507e0e26 默认的token有效期为24小时，当过期之后，该token就不能用了，这时可以使用如下的命令创建token： kubeadm token create --print-join-command # 生成一个永不过期的token kubeadm token create --ttl 0 --print-join-command 2.7 部署CNI网络插件 根据提示，在Master节点上使用kubectl工具查看节点状态： kubectl get nodes kubernetes支持多种网络插件，比如flannel、calico、canal等，任选一种即可，本次选择flannel，如果网络不行，可以使用本人提供的📎kube-flannel.yml，当然，你也可以安装calico，请点这里📎calico.yaml，推荐安装calico。 在Master节点上获取flannel配置文件(可能会失败，如果失败，请下载到本地，然后安装)： wget https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml 使用配置文件启动flannel： kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml 查看部署CNI网络插件进度： kubectl get pods -n kube-system 再次在Master节点使用kubectl工具查看节点状态： kubectl get nodes 查看集群健康状况： kubectl get cs kubectl cluster-info 3 服务部署 3.1 前言 在Kubernetes集群中部署一个Nginx程序，测试下集群是否正常工作。 3.2 步骤 部署Nginx： kubectl create deployment nginx --image=nginx:1.14-alpine 暴露端口： kubectl expose deployment nginx --port=80 --type=NodePort 查看服务状态： kubectl get pods,svc 4 kubernetes中kubectl命令自动补全 yum install -y bash-completion source /usr/share/bash-completion/bash_completion source > ~/.bashrc vim /root/.bashrc source /usr/share/bash-completion/bash_completion source Copyright © book.stolenzc.com 2021-2023 all right reserved，powered by GitbookFile Modify: 2023-06-27 07:48:51 "},"LinuxNote.html":{"url":"LinuxNote.html","title":"Linux","keywords":"","body":"一.Linux指令(centos) 1. 日常操作 1.1 cd 切换工作目录 全称:change directory cd 目录 - 进入指定目录(相对路径和绝对路径均可) cd .. - 返回上层目录 cd ~ - 回到根目录 cd / - 进入系统根目录 cd - - 进入上次的工作目录 1.2 ls 查看文件信息 全称:list ls - 查看当前文件夹下的内容 -l - 显示文件的详细信息 -a - 显示所有文件(包括隐藏文件) -R - 递归显示所有内容 -S/-t - 按大小/时间排序 -h - 以人性化的方式进行显示(文件大小带单位) -all - 显示所有文件的详细信息,可以简写问ll 注意: 多个功能不冲突的参数可以同时使用，中间用空格隔开, 例如 ls -lh -S 1.3 pwd 显示当前路径 全称:print work directory pwd - 打印当前路径 1.4 touch 创建文件 全称:touch touch 文件名 - 新建文件 1.5 cat 查看文件内容 全称: catenate/concatenate cat 文件名 - 查看文件内容 cat 文件1 文件2>文件3 - 将文件1和文件2的内容放在文件3中 1.6 tail 查看文件内容 tail -f 文件名 - 实时查看文件内容(可以实时看到改动) tail -n 数字 - 查看最后几条数据 1.7 rm 删除文件 全称:remove rm 文件名 - 删除文件(询问是否删除) -i - 询问是否删除(默认) -f - 强制删除文件(不询问) -r - 递归删除(删除文件夹) (注意：cp/mv/rm 后面可以跟： -i询问 -f强制 -n不覆盖) 1.8 cp 复制文件 全称:copy cp 文件名1 文件名2 - 将文件1中的内容拷贝到文件2中 cp 文件 目录 - 将指定文件拷贝到指定目录中 -r 文件名/目录名 目录2 - 将文件/目录拷贝到目录2中 -f - 禁止交互式操作,不会给出提示 (注意：cp/mv/rm 后面可以跟： -i询问 -f强制 -n不覆盖) 1.9 mv 移动文件 全称:move mv 文件名1 文件名2 - 将文件1中的内容移动到文件2中 ,并且删除文件1（文件重命名） mv 文件1路径 文件2路径 - 将文件夹1移动到文件夹2 mv 文件名1 新文件名 - 给文件重命名 -f - 禁止交互式操作,不会给出提示 注意: mv指令不能加-r来操作目录 (注意：cp/mv/rm 后面可以跟： -i询问 -f强制 -n不覆盖) 1.10 mkdir 创建文件夹 全称:make directory mkdir 目录名 - 新建目录 -p - 递归创建目录 -p a/{b,c}/{d,e,f} - 同一层级创建多个 1.11 rmdir 删除文件夹 全称:remove directory rmdir 目录名 - 删除指定空目录 1.12 history 查看历史命令 history - 显示历史指令记录 !历史命令编号 - 执行历史命令 -c - 清除历史命令 bashrc 配置显示时间：export HISTTIMEFORMAT=\"%y‐%m‐%d %H:%M:%S \" 修改bashrc 后使其生效: source ~/.bashrc或 ..bashrc 1.13 ln 链接 全称:link ln 源路径 目标路径 - 给源路径对应的文件在目标路径下创建一个硬链接(看成一个数据的多个引用) -s - 给源路径对应的文件在目标路径下创建一个软链接(快捷方式) 注意: 源文件不存在的时候，软件无效，硬链接变成普通文件 1.14 常用快捷键 ctr + f - 前进一个字符 ctr + b - 后退一个字符 ctr + a - 回到行首 ctr + e - 回到行尾 ctr + w - 向左删除一个单词 ctr + u - 向左删除全部 ctr + k - 向右删除全部 ctr + y - 粘贴上次删除的内容 ctr + l - 清屏 1.15 服务管理 systemctl start mysqld ：启动mysql进程 systemctl stop mysqld ：结束mysql进程 systemctl restart mysqld ： 重启mysql进程 systemctl status mysqld ： 查看进程状态 systemctl enable mysqld ：开机自启动进程 netstat -ntlp 端口名 ：查端口 -n - 以数字显示 -t - tcp端口 -l - 显示监听端口 -p - 显示 PID 和进程名称 2. 进程相关指令 2.1 ps 查看进程 全称: Processes Status ps - 进程状态 -a - 查看所有进程 -u - 显示进程的详细状态 -x - 显示没有控制终端的进程 -w - 显示加宽，以便显示更多的信息 -r - 只显示正在运行的进程 -e - 显示所有进程 -f - 全部列出 常用ps -aux或者ps ex查看进程 ps -aux|grep 进程名 - 查看指定进程 2.2 top 动态查看进程 top - 动态监控进程 -p PID1,PID2,… - 动态监控指定进程 M - 按照内存使用量排序 P - 按照CPU使用量来排序 2.3 free 查看内存 free -单位 - 以指定单位查看内存, 例如 free -m (以Mb为单位显示内存状况), -g, -k等！ 2.4 kill 杀死进程 kill 进程号 - 杀死指定的进程 kill -1/-9/-15 进程号 -1 - (HUP)不间断重启 -9 - (KILL)强制杀死进程 -15 - (TERM)正常终止进程 pkill 进程名 - 按名字处理进程 killall 进程名 - 处理名字匹配的进程 2.5 uptime 查看系统状态 uptime - 查看系统状态 2.6 jobs 查看后台运行 jobs - 查看后台运行程序 命令 & - 进程后台运行 fg %后台进程号 - 将后台进程放在前台运行 bg %后台暂停的进程号 - 将后台任务运行 ctrl z - 将程序暂停后放在后台 2.7 pgrep搜索进程 pgrep 进程名 - 搜索进程 2.8 nohup不接受中断进程 nohup redis-server --requirepass 1qaz2wsx - 表示终端结束后redis不会停止 3. 用户和权限管理 3.1 users 查看用户 users - 查看所有用户 3.2 groups 查看当前用户组 groups - 查看当前分组 3.3 groupadd 添加分组 groupadd 分组名 - 添加分组 (能在/etc/group文件中查看到新的分组, root才有的权限) 3.4 useradd 添加用户 useradd 用户名 - 创建新的用户(还是在home中自动创建这个用户对应的文件夹， root才有的权限) -G - 指定组名 -d - 指定用户登录系统时的主目录，如果不使用该参数，系统自动在/home目录下建立与用户名同名目录为主目录 -m - 自动建立目录 3.5 usermod 修改分组 usermod -G 分组列表 用户名 - 修改分组(root才有的权限) 3.6 passwd 更改用户密码 passwd 用户名 - 修改密码（root才有权限） passwd - 修改当前账号密码 3.7 su 切换用户 su 用户名 - 切换用户身份(root不需要密码，其他用户需要密码) sudo - 以管理员执行其他程序 注意： 在ubuntu需要将用户添加到sudo分组中，才能使用sudo以管理员的身份执行程序 在centOS中需要先执行vi 指令进入/etc/sudoers文件中在指定的位置添加内容 \\## Allow root to run any commands anywhere root ALL=(ALL) ALL xiaoming ALL=(ALL) ALL (自己添加的，xiaoming是用户名) 3.8 chmod 权限更改 chmod 权限值 文件 - 修改指定文件的权限 chmod [a,u,g,o][+,-][r,w,x] 文件 - 为指定文件，给所有用户添加或删除相应的权限 3.9 chown 更改文件所有者 chown 用户名 文件 - 改变文件所有者 4. 日志管理 4.1 cat查看文件内容 cat 文件 - 查看文件内容 cat /proc/version - 查看linux版本和发行版本 cat /proc/cpuinfo - 处理器信息 cat /proc/net/dev - 查看网卡信息 4.2 head/tail 查看部分内容 head –n N 文件 - 查看前N行内容 tail –n N 文件 - 查看后N行内容 4.3 less/more 分页查看 more [-N] 文件 - 和less差不多，这个是尽可能多，less是尽可能少的加载 按 j 向下 按 k 向上 按 f 向下翻屏 按 b 向上翻屏 按 g 到全文开头 按 G 到全文结尾 按 Q 退出 4.4 sotr/uniq/awk/sed结果处理 sort - 排序(cat 文件 |sort) -n - 按照数值大小排序 -r - 以相反的顺序来排序 uniq - 去重 (cat 文件 |uniq) - 只会去重相邻的重复是数据，一般结合sort一起使用|sort|uniq -c - 去重的时候统计每一行内容的重复出现的次数 awk '{print $N}' - 打印第N列的内容(netstat -natp|awk '{print $4}') awk '{print $N1,$N2,$N3,…}' - 打印多列内容,用空格分开 history |awk '{print $4}' |sort |uniq ‐c | sort ‐rnk 1 | head ‐n 3 -获取历史指令中，使用最频繁的三个指令 sort –n - 数值大小从小到大排序 sort - 字符大小从小到大排序(默认) sort –rn - 数值大小从大到小排序 sort –r - 字符大小从大到小排序(默认) 4.5 >和>> 重定向 执行获取数据的指令 > 文件 - (将执行指定的结果存储到文件中 - 覆盖原文件中内容) 执行获取数据的指令 >> 文件 - (将执行指定的结果存储到文件中 - 在原文件的最后追加) 4.6 wc 统计 全称: Word Count wc 文件名 -l - 统计行数 -w - 统计字数,跳过空白符 -c - 统计字节数 -m - 统计字符数(不能和-c一起用) 4.7 grep 文本搜索 grep 查看对象 目录/文件 参数 参数： -i - 忽略大小写: grep you bb.txt -i -n - 显示行标号: grep you bb.txt -n / grep you bb.txt -i –n -r - 递归查找目录: grep –r you ./ (在当前文件夹下中所有文件中去找包行’you’的行) -E - 通过正则表达式匹配: grep -E '正则表达式' 文件 -v - 显示不包含匹配项的所有行,相当于取反: grep you bb.txt -v 注意： Linux中，正则不支持: \\d,\\s,\\w,\\b,\\D,\\S,\\W,\\B 支持：., +, *, ?, {N,M}, [], ^, $, |, () 对文件格式进行约束 —include=‘*.py’ 仅包含 py文件: grep -r you ./ --include=‘*.py' —exclude=‘*.js’ 不包含 js 文件:grep -r you ./ --exclude='*.js' 4.8 find 文件查找 find 路径 -name ‘*.xxx’ - 找到目录下所有名字匹配的文件: find a1 -name '*.txt'(在文件夹a1中找所有txt文件) find 路径 -size +/-文件大小 例如: find ./ +20k (在当前目录下找文件大小大于20k的文件) 例：find ./ -size +20k -size -100k -name '*.txt' (找当前目录下大于20k并且小于100k的所有txt文件) 4.9 which 查指令 which 指令 - 精确查找当前可执行的指令 whereis 指令 - 查找所有匹配的命令(包括安装位置) man 指令 - 使用指令手册 5. 网络管理 scp 本地路径 username@ip:远程路径 - 将本地文件上传到远程主机 ifconfig - 查看网卡状态 netstat -natp - 查看网络连接状态 netstat -natp|grep 端口号 - 查看指定端口的网络连接状态 ping 地址 ping -i 时间 地址 ping -c 次数 地址 telnet ip地址 端口 - 查看远程主机网络连接状况（需要telnet环境） dig 地址 - 查看DNS(看域名对应的IP地址) (需要环境支持) wget 地址 - 下载 6. 使用包管理工具 1.包管理工具：yum yum search：搜索软件包，例如yum search nginx。 yum list installed：列出已经安装的软件包 yum install 安装包名：安装软件包，例如yum install nginx。 -y 所有询问均选择yes yum remove：删除软件包，例如yum remove nginx。 yum erase 包名：卸载软件包，例如yum erase -y mariadb yum update：更新软件包，例如yum update可以更新所有软件包，而yum update tar只会更新tar。 yum check-update：检查有哪些可以更新的软件包。 yum info ：显示软件包的相关信息，例如yum info nginx。 2.包管理工具：rpm rpm -ivh 包名.rpm ：安装软件包 rpm -e 包名 ：移除软件包 rpm -qa ：查询软件包 3.源代码构建安装 wget 安装包的路径 - 下载安装包 gunzip/tar 压缩包 - 解压、解归档 ./configure --prefix /usr/local/ - 设置安装路径 cd 安装包目录 执行: make && make install - 编译安装包程序 给可执行文件添加软连接到usr/bin目录下 - 添加快捷方式 压缩/解压缩和归档/解归档 - gzip /gunzip / xz / tar 7. 其他命令 clock -w - 将日期时间保存到bios df -h - 查看磁盘空间 server iptables stop/start - 关闭/打开防火墙 find . -name \"*.py\" |xargs cat|grep -v ^$|wc -l - linux统计代码行数 du -h 文件夹名 - 显示文件夹占用详情 diff 文件1 文件2 - 比较两个文件的不同 二.VIM 1. vim常用配置 编辑 vim /etc/vimrc 文件 \"设置语法高亮 syntax on \"设置显示行号 set nu \"设置tab对应的空格数量 set tabstop=4 set ts=4 \"设置tab自动变空格 set expandtab \"设置自动缩进 set autoindent \"不高亮选中单词 set nohls \"与当前设备共享粘贴板 set clipboard+=unnamed \"设置光标高亮，cul为当前行，cuc为当前列 set cul set cuc \"vim映射快捷键： \"命令模式按冒号进入末行模式 imap if __name__ == '__main__': \"不递归调用映射 inoremap _main if __name__ == '__main__': 2.保存和退出 w - 只保存(类似快捷键ctr+s) q - 退出（在编辑区的内容全部都保存的情况下才有效） wq - 保存并退出 q! - 强制退出（不保存修改信息） 3.光标操作 ^(shift+6) - 移动到行首 $(shift+4) - 移动到行尾 G(shift+g) - 移动到文件末尾 行号G - 移动到指定行,例如:30G, 让光标直接跳转到行号是30的那一行 gg - 移动到文件开头 4.文本操作 dd - 删除光标所在的行 数字dd - 从光标所在行开始往后面开始删，删除指定数量行内容 :%d - 删除所有 yy - 复制光标所在的行 数字yy - 从光标所在行开始复制指定行数的内容 p - 将复制的内容粘贴到光标所在的位置 u - 撤销 ctr+r - 反撤销 :%!sort - 对内容排序(将一行内容看成一个字符串，然后按字符串大小进行排序) :/正则表达式 - 搜索匹配正则表达式的内容，按回车回到命令模式后按n往前查找，按N往后查找 注意: 正则表达式除了表示次数的符号前需要加\\,别的和python是一样的.例如: :/\\d\\{2} - 查找两个数字 :/a\\+ - 查找a出现一次或者多次 :1,$s/被替换对象/替换内容/参数 - 将正则表达式匹配到的内容替换成指定内容 注意： 参数可以没有 g - 全局匹配 i - 忽略大小写 c - 替换时需要提示 e - 忽略错误 5.高级技巧 vim -d a.txt b.txt - 比较多个文件 vim a.txt b.txt c.txt d.txt - 打开多个文件,可以使用sp(横向分屏)vs(纵向分屏)来进行拆分窗口,然后使用:b num来选择使用当前光标所在屏幕显示哪一个文档 多行注释： ctrl+v - 进入可视化块模式 上下移动光标选中需要注释的代码 I(大i) - 进入插入模式 输入注释符号 按ese键完成 多行取消注释： ctrl+v - 进入可视化块模式 上下移动光标选中需要注释的代码 按小d即可取消注释 6.遇到的坑 当按了#号打开了高亮模式后 :nohlsearch退出高亮模式 7. 录制宏 命令模式按q 给宏取名字a 三.Shell编程 1.shell简介 要写一个shell文件要先创建一个shell文件,给shell文件添加执行权限,选择解释器执行 1.1 创建shell文件 原则上shell程序可以写在任何文件中,但一般会在shell文件后加后缀.sh表示当前文件是shell文件 1.2 添加执行权限 shell需要可执行权限,一般通过:chmod u+x shell文件名 来添加可执行权限 1.3 编译器选择 /bin/sh shell文件 - 通过bash去执行shell程序 ./shell文件 - 通过默认解释器去执行shell程序 #!/bin/bash - 在文件内添加解释器路径 注意:sh是一个指向bash的软链接 1.4 Shell使用Linux命令 命令直接使用: ls ls -lh 获取返回值: # 变量=$(指令) # 变量=`指令` re1=$(ls) re2=`pwd` 1.5 Shell文件执行区别 ./script.sh 必须是可执行文件(文件需要有可执行权限)，产生一个子进程来执行脚本 sh script.sh 或 bash script.sh 产生一个子进程来执行脚本 source script.sh 默认在当前进程执行脚本 1.6 执行shell的参数传递 脚本内获取参数的格式：$n n代表参数位置 其他命令： $# 传递到脚本的参数个数 $* 用一个字符串显示所有传递的参数 $$ 脚本运行的当前进程ID号 $? 显示最后命令的退出状态，0表示没有错误 $0 执行的文件名 2.注释与变量 2.1 注释 单行注释：单行注释就是在一行文字前加# 多行注释： : 2.2 变量声明 变量名=值 注意:=两边不能有空格,变量名由数字字母和下划线组成,数字不能开头,不能是关键字,多个单词用下划线隔开 shell中所有变量的赋值都是字符串 2.3 变量使用 $变量名 ${变量名} - 推荐使用 注意:变量不存在不会报错,会获得一个空值,变量重新赋值不加$,只有使用变量采用$ 2.3 只读变量 readonly 变量名 2.4 删除变量 unset 变量名 3.数组和字符串 3.1 字符串 shell脚本中双引号,单引号和没有引号都表示字符串 只有双引号字符串中可以出现变量和转义字符 字符串:下标:长度 - 获取指定下标开始,指定个数字符,返回一个新的字符串 ${#字符串} - 返回字符串的长度 字符串运算符见4.4 3.2 数组 3.2.1 数组定义 Bash Shell 只支持一维数组(不支持多维数组)，元素用空格分割 数组名=(值1 值2 值3 值4 ...) 用小括号括起来,每个元素之间用一个空格隔开 3.2.2 获取数组元素 数组[下标] - 获取指定下标对应的元素 数组[@]/数组[*] - 获取数组中所有的元素 注意:${数组名}获取的是该数组的第一个元素 ${#数组[@]} / ${#数组[*]} - 获取数组元素个数 ${#数组[下标]} - 获取数组中指定下标的元素的长度 4.Shell运算符 4.1 算术运算符 原生bash不支持数学操作,需要计算数字,需要用expr awk来操作 expr仅支持整数运算: + `` echo 10+20 #10+20 echo `expr 10 + 20` #30 echo `expr 10 \\* 20` #200 # 用乘号的时候需要用转义符号 echo \"scale=3; 1/13\"|bc #.076 注意:结果是true或false的值只能用来做判断,不能保存 4.2 关系运算符 比较的是数字大小 -eq - 判断是否相等 -ne - 判断是否不等于 -gt - 大于 -lt - 小于 -ge - 大于等于 -le - 小于等于 使用语法:[ 值1 关系运算符 值2 ] 注意:中括号内两边都有括号 4.3 布尔运算符(逻辑) ! - 逻辑非运算 -o - 逻辑或运算 -a - 逻辑与运算 4.4 字符串运算符 [ 字符串1 = 字符串2 ] - 判断两个字符串是否相等(等号两边有空格) [ 字符串1 != 字符串2 ] - 判断两个字符串是否不相等 [ -z 字符串 ] - 判断字符串长度是否为0 [ -n \"字符串\" ] - 判读字符串长度是否不为0 [ $ 字符串 ] - 判断字符串是否是空串 5. 循环判断 5.1 if if 条件语句1 then 满足条件1执行的代码 elif 条件语句2 then 满足条件2执行的代码 elif 条件语句3 then 满足条件3执行的代码 else 所有条件都不满足的代码 fi 5.2 for循环 for 变量 in 序列 do 循环体 done # 遍历多个值 for char in \"hello\" \"world\" do echo ${char} done # 遍历数组 array=(10 20 'abc') for x in ${array[@]} do echo ${x} done 5.3 while循环 while 条件语句 do 循环体 done # 计算1+2+...100 sum=0 i=1 while [ ${i} -le 100 ] do sum=`expr ${sum} + ${i}` i=`expr ${i} + 1` done echo ${sum} 5.4 死循环 死循环: while : /while true while : do # read加-p表示后面可以输入提示内容 read -p \"请输入一个数字:\" name done 6.函数 6.1 函数定义 [ function ] 函数名 () { 函数体 [return 返回值] } []的内容可以省略,return只能返回数字,范围为0到255 6.2 函数的调用 调用函数: 函数名 有参数: 函数名 实参1 实参2 实参3... 6.3 函数的参数 声明的时候不需要形参,直接在函数体中通过${N}来获取第N个实参 func2(){ echo 函数2被调用 echo 第一个参数:${1} echo 第二个参数:${2} echo 第三个参数:${3} } func2 10 20 \"abcc\" 6.4 执行shell传参 在执行shell的时候可以传参,在程序中通过${N}来访问传递的参数 echo shell文件执行指令:${0} #/home/stolen/shell/shell文件.sh echo 第一个shell参数:${1} #你好 echo 第二个shell参数:${2} #123 /bin/sh /home/stolen/shell/shell文件.sh 你好 123 7.定时设置 使用crontab -e进入定时设置 格式: * * * * * 命令 前五个星号分别表示:分钟 小时 日 月 周 四. Git 1. 使用准备 1.1 公钥生成:免密登录 本地进入~/.ssh目录 使用命令ssh-keygen生成公钥和私钥 ssh-keygen -t rsa -C 邮箱 -f 文件名 -t 指定密钥类型，默认是 rsa ，可以省略。 -C 设置注释文字，比如邮箱。 -B 密钥长度 -f 指定密钥文件存储文件名。 .pub就是公钥 在Linux中的免密登录位置:~/.ssh/authorized_keys文件中 1.2 linux安装git 源代码构建安装： yum -y install libcurl-devel安装依赖包 wget下载源代码安装包 tar -zxvf解压安装包，并进入该文件夹 ./configure --prefix /usr/local/git设置安装路径 make && make install编译安装 ln -s /usr/local/git/bin/git /usr/local/bin/git 2.git学习(授课) 配置用户名：git config --global user.name \"用户名\" 配置邮箱：git config --global user.email \"邮箱地址\" 2.1 新建文件夹 创建工作区 2.2 本地仓库命令 git init - 创建本地仓库 git add 文件/文件夹 - 将文件添加到本地缓存区 git add -A - 将工作区所有文件添加到缓存区 git status - 查看文件状态 git commit -m 提示信息 - 将缓存区的文件添加到仓库 git log - 查看提交日志 git log --pretty=oneline - 查看提交日志（只包括版本号和备注） git log --graph - 查看分支合并图 git reflog - 查看所有操作日志，包括已删除的版本 git reset --hard 版本号 - 回到指定的版本 git reset --hard HEAD^ - 回到上个版本 git reset --hard HEAD - 让仓库版本和工作区版本一致 git reset --hard HEAD~数字 - 向后回退多少个版本 git checkout 文件名 - 将缓冲区的文件还原到工作区 git rm --cached 文件名 - 将文件从暂存区删除 git stash - 将未做完的事情临时停下来压在栈中,不影响工作区.多次使用先进后出 pop - 继续未做完的事情.将其从栈中区出来 list - 查看栈中所有的事情. 2.3 远程仓库命令 git remote add origin 地址 - 将本地仓库和远程仓库进行关联(远程仓库必须为空) git push -u origin master - 将本地仓库提交到远程仓库(第一次提交需要用-u),提交到master可以直接用git push，-u的全称为--set-upstream git pull = git fetch + git merge git remote -v - 查看当前仓库绑定的远端仓库 git push -u --force origin master - 强行推送代码到远端（远端就会被清空放当前的仓库） git push - 直接将本地仓库的内容提交到远程仓库的当前的分支 --delete 分支名 - 删除远端分支 --tags - 将标签推送到服务器 如果文件内容发送冲突（CONFLICT）时，需要git pull先拉下来，然后和别人商量如何解决再提交 git pull - 将远程的仓库更新到本地仓库后,在将本地仓库更新到工作区 git clone - 将远程仓库克隆到本地,并且自动将本地仓库与远程仓库进行了关联(不用git remote) --depth=1 - 只克隆最新版本 2.4 分支命令 git branch - 查看分支 -a - 查看所有分支 git branch 分支名 基于的分支名 - 创建分支 -d - 删除分支 -D - 强制删除分支 git checkout 分支名 基于的分支名 - 切换分支 -b - 创建并切换分支 git switch 分支名 基于的分支名 - 切换分支 -c - 创建并切换分支 git merge 分支名 - 当前分支去合并其他分支(只会将对方更改添加到自己的分支上) --no-ff - 不使用快速合并(no fast forward),保存历史版本 git rebase 分支名 - 变基操作合并代码,先将开发线变为master线上的几个记录,然后合并.一定会保留历史记录 [develo]>>>git rebase master [develo]>>>git switch master [master]>>>git merge dev git diff 分支1 分支2 - 查看两个分支的差异 2.5 标签 git tag 标签名 - 创建标签 git tag - 查看所有标签 git tag 标签名 commitID - 给指定commit id打标签 git tag -a 标签名 -m '标签信息' - 指定标签信息 git checkout 标签名 - 切换到指定标签 git show 标签名 - 查看说明文字 git tag -d 标签名 - 删除标签 git push origin 标签名 - 推送标签到远端 git push origin --tags - 一次性推送所有标签到远端 git push origin :refs/tags/标签名 - 将本地已经删除的标签推送到远端，删除远端标签 2.6 扩展 git add . - 将所有改动添加到缓存区 git rebase 分支名 - 将其他分支的改动合并到当前分支 git remote add origin http://.... （此处报错remote origin exist时，使用：git remote rm origin） git flow - 使用git-flow流程化开发程序 五. Nginx服务框架 1. 安装与移除 yum -y install nginx 安装 安装完成后: yum info nginx 查看nginx详情 nginx -v 查看nginx版本 yum -y remove nginx 移除 2. 启动nginx服务 systemctl start nginx 启动nginx服务 systemctl restart nginx 重启nginx服务 systemctl stop nginx 停止nginx服务 nginx -s stop 停止nginx服务 云服务器遇到端口报错解决办法: 打开80端口: 在网页控制台找到服务器网络和安全组中的安全组配置 在添加安全组规则中添加80端口就可以了 3. 配置nginx 配置文件目录:/etc/nginx/nginx.conf 在文件中的的location /{}的大括号中进行配置 #配置共享目录 root /home/stolen location / { autoindex on; } # 自定义服务器页面 location / { # 设置网页目录地址 root /home/nginxHTML; # 设置主页html文件名 index index.html index.htm; } 4. uwsgi部署django项目 5. guncorn部署flask项目 六. MySQL 0. 数据库基础知识 0.1 数据库三范式 数据原子性，即数据不可再分（两行表示同一个人的数据） 数据的唯一性，保证有主键存在 数据的冗余性，（有一个学院表，学生信息中就不用写学院信息，只需要写学院编号即可） 0.2 数据库完整性： 实体完整性：每条记录都是唯一的，主键/唯一约束 参照完整性：外键 域完整性：数据库中的数据都是有效数据，数据类型/类型长度/非空约束/默认值约束/检查约束 0.3 数据库一致性：事务 1. 基本命令 启动服务 windows：net start 服务名称 (管理员身份运行) linux：sudo systemctl start mysqld / sudo service mysql start 示例：net start mysql57 / service mysql start 停止服务 windows：net stop 服务名称 (管理员身份运行) linux：systemctl stop mysqld / sudo service mysql stop 示例：net stop mysql57 / sudo service mysql stop 连接数据 格式：mysql -h ip地址 -u 用户名 -p 示例：mysql -u root -p 说明：连接本机-h参数可省略 退出登录 quit或exit 查看版本 select version() 查看帮助方式 格式：? 需要帮助的命令 示例：? data types; 2. 数据库操作(DDL) 2.1 创建数据库 格式：create database 数据库名 charset=utf8; 示例：create database stolen charset=utf8; 2.2 删除数据库 格式：drop database 数据库名; 示例： drop database stolen; drop database if exists stolen 2.3 切换数据库 格式：use 数据库名; 示例：use stolen; 2.4 查看当前选择的数据库 select database(); 2.5 查看所有数据库 show databases; 3. 表操作(DDL) 3.1 查看当前数据库中的所有表 show tables; 3.2 创建表 格式：create table 表名(列及类型); auto_increment - 表明自增长 primary key - 主键 not null - 表示不为空 default - 设置默认值 unique - 值唯一 primary key (sid, cid) - 设置联合主键 unique(sid, cid) - 添加联合唯一约束 示例：create table student(id int auto_increment primary key, name varchar(20) not null, age int not null, gender bit default 1, address varchar(20), isDelete bit default 0); 3.3 删除表 格式：drop table 表名; 示例：drop table student; drop table if exists student; 3.4 清空表中的数据 格式：truncate table 表名 示例：truncate table stolen 说明：此方法会彻底删除表，完全没有机会恢复 3.5 查看表结构 格式：desc 表名; / describe 表名; 示例：desc student; 3.6 查看建表语句 格式：show create table 表名; 示例：show create table student; 3.7 重命名表名 格式：rename table 原表名 to 新表名; 示例：rename table car to newCar; 3.8 修改表 格式：alter table 表名 add|change|modify|drop 列名 类型; 示例：alter table newCar add isDelete bit default 0; alter table tb_student change column straddr foo varchar(100); 说明：change一定需要在column后面加一个旧的列名和新的列名，即使不修改列名都要有两个列名。 3.9 修改表(添加约束) 格式：alter table 表名 add constraint 索引名 约束 (字段名); 示例：alter table tb_student add constraint pk_stu_id primary key (stuid) 3.10 修改表(删除约束) 格式：alter table 表名 drop index 约束索引; 示例：alter table tb_student drop index pk_stu_id 3.11 view视图 创建：create view view_name as select... 更新：create or replace view view_name as select... 删除：drop view view_name 4. 数据操作(DML) 4.1 增加 全列插入 格式：insert into 表名 values(……) 说明：主键列事自动增长，但是再全列插入时需要占位，通常使用0，插入成功后以实际数据为准 示例：insert into student values(0,'tom',19,1,'北京',0); 缺省插入 格式：insert into 表名(列1,列2,……) values(值1,值2,……); 示例：insert into student(name,age,address) values('lilei',19,'上海'); 同时插入多条数据 格式：insert into 表名 values(……),(……),……; 示例：insert into student values(0,'hanmeimei',18,0,'北京',0),(0,'poi',22,1,'海南',0),(0,'wenwen',20,1,'石家庄',0); 4.2 删除 格式：delete from 表名 where 条件; 示例：delete from student where id=4; 注意：没有条件是全部删除，慎用 4.3 修改 格式：update 表名 set 列1=值1,列2=值2,…… where 条件; 示例：update student set age=16 where id=7; 注意：没有条件是全部列都修改，慎用 4.4 查询 4.4.1 基本语法 格式：select * from 表名; 说明： from关键字后面是表名，表示数据来源于这张表 select后面写表格中的列名，如果是*表示在结果集中显示表中的所有列 在select后面的列名部分，可以使用as为列起别名，这个别名显示在结果集中 如果要查询多个列，之间使用逗号分隔 ​示例： select * from student; select name,age from sutdent; 4.4.2 消除重复行 在select后面列前面加distinct可以消除重复的行 示例： select gender from student; select distinct gender from student; 4.4.3 条件查询 语法 select * from 表名 where 条件; 比较运算符 等于: = 大于: > 小于: 大于等于: >= 小于等于: 不等于: !=或<> 示例：select * from student where id>8; 逻辑运算符 and - 并且 or - 或者 not - 非 需求：查询id值大于7的女同学 示例：select * from student where id>7 and gender=0; 模糊查询 like % - 表示多个任意字符 _ - 表示一个任意字符 [charlist] - 字符列中的任何单一字符 [^charlist]或者[!charlist] - 不在字符列中的任何单一字符 示例： select * from student where name like '习%'; select * from student where name like '习_'; 范围查询 in - 表示在一个非连续的范围内 between……and…… - 表示在一个连续的范围内 示例： select * from student where id in(8,10,12); select * from student where id between 6 and 8; 空判断 注意：null与''是不同的 判断空：is null 判断非空：is not null 示例： select * from student where address is null; select * from student where address is not null; 优先级 小括号，not， 比较运算符，逻辑运算符 and比or优先级高，如果同时出现并希望先选or，需要结合()来使用。 做判断显示 需求：查询性别，如果为0则显示女，如果为1则显示男 示例： select stuname as 姓名, case stusex when 1 then '男' else '女' end as 性别 from tb_student; select stuname as 姓名, if(stusex, '男', '女') as 性别 from tb_student; 4.4.4 聚合 为了快速得到统计数据，提供了五个聚合函数 count(*) - 表示计算总行数，括号中可以写*和列名 max(列) - 表示求此列的最大值 min(列) - 表示求此列的最小值 sum(列) - 表示求此列的和 avg(列) - 表示此列的平均值 需求：查询学生的总数 示例： select count(*) from student; select max(id) from student where gender=0; select min(id) from student where gender=0; select sum(age) from student where gender=0; select avg(age) from student; 4.4.5 分组 按照字段分组，表示此字段相同的数据会被放到一个集合中。 分组后，只能查询出相同的数据列，对于有差异的数据列无法显示再结果集中 可以对分组后的数据进行统计，做聚合运算 语法： select 列1,列2,聚合…… from 表名 group by 列1,列2,列3……; select 列1,列2,聚合…… from 表名 group by 列1,列2,列3……having 列1,……聚合…… 需求：查询男生女生总数 示例： select name, gender,count(*) from student group by gender,age; select gender,count(*) from student group by gender having gender=0; where与having的区别： where是对from后面指定的数据进行筛选，属于对原始数据进行筛选 having是对group by的结果进行筛选 4.4.6 排序 语法：select * from 表名 order by 列1 asc|desc, 列2 asc|desc; 说明： 将数据按照列1进行排序，如果某些列1的值相同，则按照列2进行排序 默认按照从小到大的顺序排序 asc升序 desc降序 示例： select * from student where isDelete=0 order by age desc; select * from student where isDelete=0 order by age desc,score asc; 4.4.7 分页 语法： select * from 表名 limit start,count; select * from 表名 limit count offset start; 示例： select * from student limit 0,3; select * from student limit 3,3; select * from student where gender=0 limit 0,3; 4.4.8 内连接 语法： select 列1, 列2, 列3 from 表1 [表1别名], 表2 [表2别名], 表3 [表3别名] where 条件1, 条件2, 条件3; select 列1, 列2, 列3 from 表1 [表1别名] inner join 表2 [表2别名] inner join 表3 [表3别名] on 条件1, 条件2, 条件3 说明：使用inner join后连接条件需要用on，不使用inner join后连接条件使用where 4.4.9 外连接 左外连接语法：select 列1, 列2, 列3 from 表1 [表1别名] left outer join 表2 [表2别名] on 条件1, 条件2, 条件3 右外连接语法：select 列1, 列2, 列3 from 表1 [表1别名] right outer join 表2 [表2别名] on 条件1, 条件2, 条件3 说明：mysql不支持全外连接，其他数据库在不适用outer join时可以使用条件1(+)=条件2表示右外连接，条件1=条件2(+)表示左外连接，条件1(+)=条件2(+)表示全外连接， 4.4.10 交叉查询 select * from 表1名, 表2名; select * from 表1名 cross join 表2名; 4.4.11 union UNION 结果集中的列名总是等于 UNION 中第一个 SELECT 语句中的列名。 UNION ALL 命令和 UNION 命令几乎是等效的，不过 UNION ALL 命令会列出所有的值。 SELECT column_name(s) FROM table_name1 UNION SELECT column_name(s) FROM table_name2 4.5 关联 建表时添加外键语句： create table class(id int auto_increment primary key, name varchar(20) not null,stuNum int not null); create table students(id int auto_increment primary key,name varchar(20) not null,gender bit default 1,classid int not null, foreign key(classid) references class(id)); create table students(id int auto_increment primary key ,name varchar(20) not null,gender bit default 1,classid int not null foreign key(classid) references class(id) ); 建表完成后添加外键： alter table students add constraint 外键索引 foreign key (classid) references class (id) 说明：外键索引为自己命名，后面可以通过外键索引删除外键 关联查询： select students.name as name,class.name as class from class inner join students on class.id=students.classid; select students.name,class.name from class left join students on class.id=students.classid; select students.name,class.name from class right join students on class.id=students.classid; ​​分类： 表A inner join 表B： 表A与表B匹配的行会出现在结果集当中 表A left join 表B： 表A与表B匹配的行会出现在结果集当中，外加表A中独有的数据，未对应的数据用null填充 表A right join 表B： 表A与表B匹配的行会出现在结果集当中，外加表B中独有的数据，未对应的数据用null填充 4.6 函数 字符串函数 函数 描述 实例 ascii(s) 返回字符串 s 第一个字符的 ASCII 码。 select ascii('hello'); -- 104 char_length(s) 返回字符串 s 的长度 select char_length('stolenzc'); -- 8 character_lenght(s) 功能同char_length(s) select character_length(\"stolenzc\"); -- 8 concat(s1,s2...) 连接多个字符串为一个字符串 select concat('a','b','c'); -- abc concat_ws(x,s1,s2...) 用x字符拼接多个字符串 select concat_ws('+','a','b','c'); -- a+b+c field(s,s1,s2...) 返回字符串 s 在字符串列表(s1,s2...)中第一次出现的位置 select field('b','a','b','c'); --2 find_in_set(s1,s2) 功能同field()，s2是列表格式字符串 select find_in_set(\"b\", \"a,b,c\"); --2 format(x,n) 格式化数字x, 保留n位小数，最后一位四舍五入。 select format(1234.1254, 2); -- 1,234.13 insert(s1,x,len,s2) 字符串 s2 替换 s1 的 x 位置开始长度为 len 的字符串 select insert('abcde',3,2,'kkk'); -- abkke locate(s1,s) 从字符串 s 中获取 s1 的开始位置 select locate('cd','abcdcd'); -- 3 position(s1 in s) 从字符串 s 中获取 s1 的开始位置 select position('b' in 'abc') -- 2 lcase(s) 将字符串转换为小写 select lcase('ABCd'); -- abcd lower(s) 将字符串转换为小写 select lower('ABCd'); -- abcd ucase(s) 将字符串转换为大写 select ucase(\"abcD\"); -- ABCD upper(s) 将字符串转换为大写 select upper(\"abcD\"); -- ABCD left(s,n) 返回字符串 s 的前 n 个字符 select left('abcd',2); -- ab right(s,n) 返回字符串 s 的后 n 个字符 select right('abcd',2) -- cd lpad(s1,len,s2) 在字符串 s1 的开始处填充字符串 s2，使长度达到 len select lpad('abc',5,'xx'); -- xxabc rpad(s1,len,s2) 在字符串 s1 的结尾处填充字符串 s2，使长度达到 len select rpad('abc',5,'xx'); -- abcxx ltrim(s) 去掉字符串 s 开始处的空格 select ltrim(\" abc\"); -- abc rtrim(s) 去掉字符串 s 结尾处的空格 select rtrim(\"abc \") ; -- abc trim(s) 去掉字符串 s 开始和结尾处的空格 select trim(' abcd ') -- abcd mid(s,n,len) 从 s 的 n 位置截取长度为 len 的子串 select mid(\"abcd\", 2, 2); -- bc repeat(s,n) 将字符串 s 重复 n 次 select repeat('abc',3); -- abcabcabc replace(s,s1,s2) 将字符串 s2 替代字符串 s 中的字符串 s1 select replace('abc','a','x') --xbc reverse(s) 将字符串 s 的顺序反转 select reverse('abc') -- cba space(n) 返回 n 个空格 select space(10); -- 输出10个空格 strcmp(s1,s2) 比较 s1 和 s2，相等返回 0 ，s1 大 返回 1，s2 大 返回 -1 select strcmp(\"abc\", \"abd\"); -- -1 substr(s,start,len) 从字符串 s 的 start 位置截取长度为 len 的子字符串 select substr(\"RUNOOB\", 2, 3); -- UNO substring() 参数功能同substr select substring(\"RUNOOB\", 2, 3); -- UNO substring_index(s,d,n) 返回从字符串 s 的第 n 个出现的分隔符 d 之前的子串 select substring_index('a*b*c','*',2); -- a*b substring_index(s,d,n) n 是负数，返回第(n 的绝对值(从右边数))个分割符右边的字符串 select substring_index('a*b*c*d*e','*',-3); -- c*d*e Mysql中Date函数 函数 描述 实例 now() 返回当前的日期和时间 select now(); curdate() 返回当前的日期 select curdate(); curtime() 返回当前的时间 select curtime(); date(date) 提取日期或日期/时间表达式的日期部分 select date(created_time) from user; date_format(date,format) 格式化输出日期 select date_format(created_time, '%Y-%m-%d') from user; ifnull(data, result) - mysql中使用ifnull函数，如果data字段为null，则返回result的内容 4.7 变量 局部变量： 只能用在begin/end语句块中，比如存储过程中的begin/end语句块。其作用域仅限于该语句块。 声明：declare age int default 0; 赋值：set age=18; select StuAge into age from demo.student where StuNo='A001'; 用户变量： mysql中用户变量不用提前申明，在用的时候直接用“@变量名”使用就可以了，其作用域为当前连接。 声明：set @age=19 set @age:=20 select @age:=22 会话变量： mysql会话变量，服务器为每个连接的客户端维护一系列会话变量。其作用域仅限于当前连接，即每个连接中的会话变量是独立的。 -- 显示所有的会话变量 show session variables; -- 设置会话变量的值的三种方式 set session auto_increment_increment=1; set @@session.auto_increment_increment=2; set auto_increment_increment=3; -- 当省略session关键字时，默认缺省为session，即设置会话变量的值 -- 查询会话变量的值的三种方式 select @@auto_increment_increment; select @@session.auto_increment_increment; show session variables like '%auto_increment_increment%'; -- session关键字可省略 -- 关键字session也可用关键字local替代 set @@local.auto_increment_increment=1; select @@local.auto_increment_increment; 全局变量： 全局变量影响服务器整体操作，当服务启动时，它将所有全局变量初始化为默认值。要想更改全局变量，必须具有super权限。其作用域为server的整个生命周期。 -- 显示所有的全局变量 show global variables; -- 设置全局变量的值的两种方式 set global sql_warnings=ON; -- global不能省略 set @@global.sql_warnings=OFF; -- 查询全局变量的值的两种方式 select @@global.sql_warnings; show global variables like '%sql_warnings%'; 4.8 补充知识 查询中，别名的as全称为alias，as是可以省略的 在判断1显示男，0显示女中，case语法是数据库通用语法,if语法是mysql独有的方法 floor 意为地板，表示向下取整，ceil意为天花板，表示向上取整 round为四舍五入函数 datediff为计算日期差，可以用来计算生日 查询函数帮助使用? functions concat为字符串连接函数 在数据库通用语言中，不等号用<>表示，!=为mysql中独有 连接查询时，不写条件就会产生卡迪尔积 连接查询如果使用临时表，必须取别名 /*查询的终极格式： select ... from ... where ... group by ... having ... order by ... limit ...offset ... */ 5. 权限用户操作DCL 5.1 创建远程连接的用户： 格式：create user '用户名'@'地址' identified by '密码' 说明：地址为能访问的IP地址，%表示所有用户，localhost表示本机；密码为该用户登录数据库的密码 示例：create user 'root'@'%' identified by '123456'; 5.2 给用户授予指定的权限： 格式：grant 权限说明 on 数据库名.数据表名 to '用户名'@'地址' 该用户是否能操作权限; 说明： 权限说明：all privileges表示添加所有权限，其他具体的权限参照 https://dev.mysql.com/doc/refman/5.7/en/privileges-provided.html ； *表示通配，*.*表示所有数据库的所有表； % 表示所有地址 with grant option表示该用户能够管理其他用户的权限 示例：grant all privileges on *.* to 'root'@'%' with grant option; 5.3 移除用户的权限 格式：revoke 权限类型 on 数据库.对象 from 用户名 示例：revoke all privileges on school.* from 'stolen'; 5.4 查看用户的权限 格式： show grants for '用户名'; select * from mysql.user where user='用户名'\\G; 示例： show grants for 'root'; select * from mysql.user where user='root'\\G; 5.5 刷新权限 格式：flush privileges; 5.6 修改用户名 格式：rename user '旧用户名'@'旧地址' to '新用户名'@'新地址'; 5.7 删除用户 格式：drop user '用户名'@'允许访问的地址'; 6. 数据库导入导出 导出：mysqldump -u 用户名 -p -d --add-drop-table 数据库名 表名 > 导出文件名; 说明：-d表示只导出结构，不导出数据；--add-drop-table每句前面添加drop table；如果不写表名，表示导出整个数据库。 注意：命令在系统命令行执行，不是在mysql中执行 导入：source 文件路径; 说明：在mysql的命令行下执行 加载：load data infile '加载数据文件路径' into table 表名; 7. 其他语法 格式：set global sql_safe_updates=off 说明：将数据库的安全更新模式关闭（celery保存数据库迁移表失败解决办法） 格式：ALTER TABLE user AUTO_INCREMENT = 5; 说明：设置自增字段的起始值 格式：explain 查询语句 说明：查看sql语句执行计划 格式：set foreign_key_checks=0; 说明：当表格有外键关联时，无法使用truncate截断表，可以使用关闭外键检查进行截断表 格式：select @@tx_isolation; 说明：查看事务隔离级别， 事务隔离会出现的问题： 第一类丢失更新：事务A撤销时，把事务B提交是数据覆盖了 第二类丢失更新：事务A提交时，把事务B提交的数据覆盖了 脏读：事务A修改的数据未提交被事务B读走了。 不可重复读：事务A中读取一次数据后，事务B修改了数据，事务A第二次读取数据为修改后的值 幻读：事务A执行一个查询后，事务B插入数据，事务A返回查询结果中包含了B插入的数据 事务隔离级别： none - 未设置，会出现所有的问题 read uncommitted - 读未提交，可以避免第一类更新 read committed - 读提交，可以避免第一类更新，脏读 repeatable read - 可重复读，存在幻读问题 serializable - 所有问题都不会出现，性能最差 格式：set session transaction isolation level read committed 说明：设置事务隔离级别， 格式：update usercourses set exam_progress=floor(rand()*10); 说明：向数据库中插入随机数，rand()表示0到1之间到随机数，floor表示向下取整，向上取整用ceiling 8. 重要说明 sql语言对大小写不敏感 数据库常用的数据类型: int/integer(-128到127) float(size,d)/double(size,d) - 这儿的size和d的值都有约束效果 decimal(m,d) m表示最大长度，不包括小数点，d表示小数位数 char(size)-定长字符 varchar(size)-不定长字符串,size决定的是最大长度 text: 不限长度(最大是255个字符) bit: 只有0和1两个值 date/datetime/time: 值可以是时间函数的结果，也可以时间字符串；计算或者是比较的时候内部是按时间处理的 值的问题: sql中是数字对应的值直接写，字符串需要使用引号引起来，bit类型的值只有0或者1, 时间可以用内容是满足时间格式字符串也可以是通过时间函数获取的值 -- 时间函数: now() - 当前时间包括日期 date(now()) - 当前日期 year(now()) - 当前年 month(now()) - 当前月 .... 左连接：左边表的数据全部显示出来，右边没有匹配的记录用空来代替 右连接：右边表的数据全部显示出来，左边没有匹配的记录用空来代替 内连接：两张表都有的数据才显示出来。 外连接/全连接：两张表的内容全部显示出来，没有匹配的数据用空来代替 9. SQL安全 sql注入攻击： # 某网站的用户验证语句 strSQL = \"SELECT * FROM users WHERE (name = '\" + userName + \"') and (pw = '\"+ passWord +\"');\" # 用户输入： userName = \"1' OR '1'='1\"; passWord = \"1' OR '1'='1\"; # 以上代买会变成 strSQL = \"SELECT * FROM users WHERE (name = '1' OR '1'='1') and (pw = '1' OR '1'='1');\" # 实际执行为 strSQL = \"SELECT * FROM users;\" # 即实现无账号登录 解决办法：不使用字符串拼接，验证用户登录 七. mongoDB 1. 操作mongodb数据库 1.1 创建数据库 语法：use 数据库名 说明：如果数据库不存在，则创建数据库，否则切换到指定的数据库 注意：如果刚刚创建的数据库不在列表内，如果要显示它，我们需要向刚刚创建的数据库中插入的一些数据(db.student.insert({name:'tom',age:18,gender:1,address:'北京',isDelete:0})) 1.2 删除数据库 前提：使用当前数据库(use 数据库名) ​db.dropDatabase() 1.3 查看所有数据库 show dbs 1.4 查看当前正在使用的数据库 ​a、db ​b、db.getName() 1.5 断开连接 exit 1.6 查看命令api help 2. 集合操作 2.1 查看当前数据库下有哪些集合 show collections 2.2 创建集合 a、 语法：db.createCollection('集合名') 示例：db.createCollection('class') b、 语法：db.集合名.insert(文档) 示例：db.student.insert({name:'tom',age:18,gender:1,address:'北京',isDelete:0}) 区别：两者的区别在于前者创建的是一个空的集合，后者创建一个空的集合并添加一个文档 2.3 删除当前数据库中的集合 语法：db.集合名.drop() 示例：db.class.drop() 3. 文档操作 3.1 插入文档 a、使用insert方法插入文档 语法：db.集合名.insert(文档) 插入一个：db.student.insert({name:'lilei',age:19,gender:1,address:'北京',isDelete:0}) 语法：db.集合名.insert([文档1,文档2,……]) 插入多个：db.student.insert([{name:'hanmeimei',age:19,gender:0,address:'北京',isDelete:0},{name:'韩梅梅',age:20,gender=0,address:'北京',isDelete:0}]) b、使用save方法插入文档 语法：db.集合名.save(文档) 说明：如果不指定_id字段，save()方法类似于insert()方法，如果指定_id字段，则会更新_id字段的数据 示例1：db.student.save({name:'pol',age:22,gender:1,address:'石家庄',isDelete:0}) 示例2：db.student.save({_id:ObjectId(\"5d05c234ea833bab0c862e2b\")},age=20) 3.2 文档更新 a、update()方法用于更新已存在的文档 语法： db.集合名.update( , , { upset: multi: writeConcern: } ) 参数说明： query：update的查询条件，类似于sql里update语句内where后面的语句 update：update的对象和一些更新的操作符($set,$inc)等，$set直接更新，$inc在原有基础上累加后更新 upset：可选，如果不存在update的记录，是否当新数据插入，true为插入，False为不插入，默认为false multi：可选，mongodb默认是false，只更新找到的第一条记录，如果这个参数为true，就按照条件查找出来的数据全部更新 writeConcern：可选，抛出异常的级别 需求：将lilei的年龄更新为25 示例：db.student.update({name:'lilei'},{$set:{age:25}}) 累加：db.student.update({name:'lilei'},{$inc:{age:25}}) 全改：db.student.update({name:'hanmeimei'},{$inc:{age:25}},{multi:true}) b、save()方法通过传入的文档替换已有的文档 语法： db.集合名.save( document, { writeConcern: } ) 参数说明： document：文档数据 writeConcern：可选，抛出异常的级别 3.3 文档删除 说明：在执行remove()函数前，先执行find()命令来判断执行的条件是否存在是一个良好习惯 语法： db.集合名.remove( query, { justOne:, writeConcern: } ) 参数说明： query：可选，删除的文档条件 justOne：可选，如果为true或1，则只删除一个文件 writeConcern：可选，抛出异常的级别 示例：db.student.remove({name:'pol'}) 3.4 文档查询 a、find()方法 语法：db.集合名.find() 示例：db.student.find() b、find()方法查询指定列 语法： db.集合名.find( query, { :1 :2 } ) 参数说明： query：查询条件 key：要显示的字段，1表示显示 示例： db.student.find({gender:0},{name:1,age:1}) db.student.find({},{name:1,age:1}) c、pretty()方法以格式化的方式来显示文档 示例：db.student.find().pretty d、findOne()方法查询匹配结果的第一条数据 示例：db.student.findOne({gender:1}) 5、查询条件操作符 作用：条件操作符用于比较两个表达式并从mongodb集合中获取数据 a、大于 $gt 语法：db.集合名.find(:{$gt:}) 示例：db.student.find(age:{$gt:20}) b、大于等于 $gte 语法：db.集合名.find(:{$gte:}) c、小于 $lt 语法：db.集合名.find(:{$lt:}) d、小于等于 $lte 语法：db.集合名.find(:{$lte:}) e、大于等于 和小于等于 $gte 和 $lte 语法：db.集合名.find(:{$gte:},$lte:}) f、等于 : db.集合名.find(:) g、使用_id进行查询 语法：db.集合名.find({\"_id\":ObjectId(\"id值\")}) 示例：db.student.find({\"_id\":ObjectId(\"5d05c234ea833bab0c862e2b\")}) h、查询某个结果集的数据条数 db.student.find().count() i、查询某个字段的值当中是否包含另一个值 语法：db.集合名.find({:/字段内容/}) 示例：db.student.find({name:/ile/}) j、查询某个字段的值是否以另一个值开头 语法：示例：db.集合名.find({:/^字段内容/}) 示例：db.student.find({name:/^li/}) 6、条件查询and 和 or a、AND条件 语法：db.集合名.find({条件1,条件2,……}) 示例：db.student.find(gender:0,age:{$gt:16}) b、OR条件 语法： db.集合名.find( { $or:[{条件1,条件2,……}] } ) 示例：db.student.find({$or:[{age:17,age:{$gte:20}}]}) c、AND和OR联合使用 语法： db.集合名.find( { 条件1, 条件2, $or:[{条件3,条件4,……}] } ) 7、limit、skip a、limit():读取指定数量的数据记录 db.student.find().limit(2) b、skip():跳过指定数量的数据 db.student.find().skip(3) c、skip和limit联合使用 通常使用这种方式来实现分页的功能 示例：db.student.find().skip(3).limit(2) 8、排序 语法：db.集合名.find().sort({:1|-1}) 示例：db.student.find().sort({age:1}) 注意：1表示升序，-1表示降序 八. redis 1. Linux常用的redis命令 redis-server - 启动redis服务 redis-cli - 启动redis命令行客户端 save/bgsave - 手动保存数据 shutdown - 关闭服务器 quit - 退出命令行客户端 auth 密码 - 认证身份 redis-server --requirepass 密码 - 启动redis并设置密码 select 编号 - 切换数据库，默认有16个数据库，[0-15] flushdb - 删除所在数据库的数据 flushall - 删除所有数据库的数据 info - 查看服务器的信息 2. key 2.1 查找键，参数支持正则 keys pattern keys * --> 查看所有键 2.2 判断键是否存在 exists key 说明：如果存在返回1，不存在返回0 2.3 查看键对应的value类型 type key 2.4 删除键及对应的值 del key [key ……] flushdb --> 删除当前数据库所有键 flushall --> 删除所有数据库的键 2.5 设置过期时间 expire key 过期时间 说明：以秒为单位 3. string 概述：string是redis最基本的类型，最大能存储512MB的数据，string类型是二进制安全的，既可以存储任何数据，比如数字、图片、序列化对象等 3.1 设置 a、设置键值 set key value --> 如果键存在，则覆盖原值，不存在则创建并赋值 setnx key value --> 如果键不存在，则创建并赋值，如果存在则不修改 b、设置键值及过期时间 setex key seconds value set key ex value 说明：以秒为单位 c、设置多个键值 mset key value [key value……] d、查看键超时时间 ttl key e、替换字符串 setrange key 开始下标 新字符串 说明：从开始下标开始，将新字符串替换到原字符串 3.2 获取 a、根据键获取值 get key 说明：如果键不存在则返回None（null 0 nil） b、根据多个键获取多个值 mget key [key……] c、获取子串 getrange key 开始下标 结束小标 说明：获取字符串的一部分 3.3 运算 a、将key对应的值加1 incr key b、将key对应的值减1 decr key c、将key对应的值加整数 incrby key 数字 d、将key对应的值减整数 decrby key 数字 3.4 删除 a、删除指定键 del key b、删除所有键 flushdb c、删除所有数据库的内容 flushall 3.5 其他 a、追加值 append key value b、获取键值长度 strlen key c、获取值后赋值 getset key value --> 获取旧值并返回，然后用value替换旧值 4. hash 概述：hash主要用于储存对象 { name:'tom', age:18 } 4.1 设置 a、设置单个值 hset key field value b、设置多个值 mhset key field value [field value……] 4.2 获取 a、获取一个属性的值 hget key field b、获取多个属性的值 hmget key field [field……] c、获取所有属性和值 hgetall key d、获取所有属性 hkeys key e、获取所有值 hvals key f、返回包含数据的个数 hlen key 4.3 其他 a、判断属性是否存在 hexists key field 说明：存在返回1，不存在返回0 b、删除属性及值 hdel key field [field ……] c、返回值的字符串长度 hstrlen key field 5. list 概述：列表的元素类型为string，按照插入顺序排序，在列表的头部或尾部添加元素 5.1 设置 a、在头部插入 lpush key value1 [value2 ……] 说明：value2的值在value1前面 b、在尾部插入 rpush key value [value ……] c、在参考元素的前|后插入新元素 linsert key before|after 参考元素 value d、设置指定索引的元素值 lindex key 索引值 注意：索引值从0开始 注意：索引值可以是负数，表示偏移量是从list的尾部开始，如-1表示最后一个元素 5.2 获取 a、移除并返回key对应的list的第一个元素 lpop key b、移除并返回key对应的list的最后一个元素 rpop key c、返回存储在key的列表中的指定范围的元素 lrange key start end 注意：start end都是从零来数 注意：偏移量可以是负数 d、移除并返回key对应的list的第一个元素，如果不存在则阻塞在此等候 blpop key e、移除并返回key对应的list的最后一个元素，如果不存在则阻塞在此等候 brpop key 5.3 其他 a、裁剪列表，改为原集合的一个子集 ltrim key start end 注意：start end都是从零来数 注意：偏移量可以是负数 b、返回存储在key里的list的长度 llen key c、返回列表中索引对应的值 lindex key index d、删除指定个数值为value的元素 lrem key 个数 value 6. set 概述：无序集合，元素类型为string类型，元素具有唯一性，不重复 6.1 设置 a、添加元素 sadd key member [member……] 6.2 获取 a、返回key集合中所有的元素 smembers key b、返回集合元素个数 scard key 6.3 运算 a、求多个集合的交集 sinter key [key……] b、求多个集合的差集 sdiff key [key……] c、求多个集合的合集 sunion key [key……] d、判断元素是否在集合中，存在返回1，不存在返回0 sismember key member 6.4 删除 a、删除指定的元素 srem key member b、随机取出指定个数个元素 spop key 个数 7. zset 概述： a、有序集合，元素类型为string，元素具有唯一性，不能重复 b、每个元素都会关联一个double类型的score(表示权重)，通过权重的大小排序，元素的score可以相同 7.1 添加 格式：zadd key score member [score member……] 示例：zadd zi 1 a 2 b 3 c 4 d 说明：注意：值在前，元素在后 7.2 获取 a、返回指定范围的元素 zrange key start end --> 升序排序 zrevrange key start end --> 降序排序 b、返回元素个数 zcard key c、返回有序集合key中，score在min和max之间的元素 zcount key min max d、查看score在min和max之间的排行 zrangebyscore key min max e、返回有序集合key中，成员member的score的值 zscore key member f、查看元素的排名 zrank key member --> 升序查看元素的排名 zrevrank key member --> 降序查看元素的排名 7.3 删除 zrem key member --> 删除指定的元素 7.4 计算 zincrby key member 数值 --> 给指定元素的值加上提供的值 8. geo地理位置 8.1 添加 geoadd 集合名 经度 纬度 位置备注 [经度 纬度 位置备注...] 8.2 计算 geodist 集合名 位置备注1 位置备注2 [km] 说明：查看两个位置的距离，后面添加km表示显示单位为千米 georadius 集合名 经度 纬度 距离 [单位] [withdist] 说明：查看集合中距离指定经纬度指定范围的位置点，withdist表示显示距离 9. 事务 mult - 开启事务 exec - 执行（提交） discard - 放弃（回滚） watch - 监控数据，如果被其他程序改变，则提交失败 10. 主从复制 redis-server --slaveof IP地址 端口 - 设置启动的redis是哪个redis的从机 info replication - 查看redis主从状态 九. postgresql 1. 安装 sudo apt-get install postgresql - ubuntu安装方法 安装后会自动创建一个postgres用户，该用户拥有postgresql的最高管理权限，需要切换到该用户下才能进行后续操作 2. 命令行操作 psql --version - 查看版本 psql -l - 列出所有数据库 createdb 数据库名 - 创建数据库 psql 数据库名 - 进入该数据库 dropdb 数据库名 - 删除数据库 createuser 用户名 - 创建用户 dropuser 用户名 - 删除用户 3. 数据库命令 `` 十. 阿里云操作 1.连接云服务器(git bash) ssh root@ip地址 输入密码 注意:更改密码后需要重启 退出登录:logout 2.更改连接超时 vim /etc/ssh/sshd_config中 \\#ClientAliveInterval 0 \\#ClientAliveCountMax 3 修改为: ClientAliveInterval 30 ClientAliveCountMax 86400 客户端每隔多少秒向服务发送一个心跳数据 客户端多少秒没有相应，服务器自动断掉连接 重启sshd服务(centos7+) systemctl restart sshd 3.做免密方法 在本地进入~/.ssh目录 在git bash中使用命令ssh-keygen生成公钥和私钥 .pub就是公钥 在Linux中的公钥放置位置:~/.ssh/authorized_keys文件中 十一. 网络安全 SQL注入攻击：用字符串拼接的方式未对用户输入进行验证导致将用户输入内容部分作为代码执行 XSS跨站脚本攻击：对用户输入未检测或者转义不足导致用户输入部分代码作为命令进行了执行 点击劫持攻击：在网页上防治一个透明的iframe，展示给用户不一样的内容诱导用户点击iframe上的内容。 十二. Docker 1. 安装 yum install -y docker - centos安装docker systemctl start docker - 启动docker windows下更改国内镜像在右下角图标右键settings>Docker Engine中添加以下代码 Linux下更改国内镜像在/etc/docker/daemon.json中添加以下代码 { \"registry-mirrors\": [ \"http://hub-mirror.c.163.com\", \"https://registry.docker-cn.com\" ] } 重新安装docker-ce方法 查看内核版本(centos7 64位要求3.10+，centos6 64位要求2.6+) uname -r 更新底层库文件 yum update 移除可能存在的旧版docker yum erase -y docker docker-common docker-engine 注意: 移除前先删除容器和镜像 安装工具包和依赖项 yum install -y yum-utils device-mapper-persistent-data lvm2 通过yum工具包添加docker-ce源 yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo yum安装并启动docker yum -y install docker-ce systemctl start docker 2. 命令 docker version - 查看docker版本 docker info - 查看详细信息 docker pull 镜像名 - 下载镜像 docker images - 查看所有本地的镜像 docker rmi 镜像id - 删除镜像 docker run -d -p 80:80 --name mynginx --rm nginx:latest - 创建并运行容器， -d - 后台运行 -p port1:port2 - 指定端口 外部端口:内部端口 -v/--volume 外部文件夹:内部文件夹 - 数据卷操作，将外部文件夹映射到容器内部文件夹 --link 容器名:自定义网络别名 - 给容器网络设置别名 --name 容器名字 - 给创建的容器命名 --rm - 为停止容器的时候容器自动删除 镜像名:版本号 - 指定镜像和版本，latest为最新版本，默认不写也为最新版本 docker ps - 查看docker的端口占用 docker start mynginx - 运行已经创建的容器 docker stop mynginx - 停止正在运行的容器 docker container ls -a - 查看所有的容器，不加-a表示正在运行的容器 docker rm mynginx/ docker rm -f mynginx - 删除容器 docker container prune - 清空所有容器 docker exec -i -t mynginx /bin/bash - 进入容器的交互环境并启动bash docker cp - 容器内外拷贝文件 docker inspect --format '{{ .NetworkSettings.IPAddress }}' 容器id - 查看容器IP地址 docker commit 容器id 自定义镜像名字 - 将容器打包成镜像 docker save 镜像名 -o 文件名 - 镜像保存为文件 docker load - 加载镜像 docker login - 登录docker hub docker push - 将自己的镜像上传到docker hub 3. dockerfile构建镜像 3. 常见容器创建 docker run -d -p 6379:6379 --name redis-master redis:latest redis-server --requirepass 1qaz2wsx - 创建redis主机 docker run -d -p 6380:6379 --link redis-master:redis-master --name redis-slave-1 redis:latest redis-server --slaveof redis-master 6379 --masterauth 1qaz2wsx - 创建redis从机 docker run -d -p 3306:3306 -v /root/docker/mysql/conf:/etc/mysql/mysql.conf.d -v /root/docker/mysql/data:/var/lib/mysql --name mysql57 -e \"MYSQL_ROOT_PASSWORD=123456\" mysql:5.7.29 - 创建mysql容器并将数据备份 跳到最后 Copyright © book.stolenzc.com 2021-2023 all right reserved，powered by GitbookFile Modify: 2023-06-27 07:48:51 "},"MysqlNote.html":{"url":"MysqlNote.html","title":"MySQL","keywords":"","body":"MySQL 基础使用 数据表操作 load data infile '加载数据文件路径' into table 表名 - 将文件数据加载到表中 数据查询操作 注意： 进行部分字符匹配应该使用 regexp 或者 not regexp，^$ 表示字符串开始或结束位置，{n} 表示匹配n次 在select可以定义变量，以 @ 开头，以 := 赋值，例：select @max_1:=Max(price), @min_1:=Min(price) from order 过滤重复数据可以使用 bit_count + bit_or 或者 distinct bit_count 是计算二进制中包含1的个数，bit_or 是对两个二进制数进行或运算 select year, month, bit_count(bit_or(1 - 以年和月来分组，查询日期的天数（对日期进行了去重） select distinct 字段名 from 表名; - 用distinct去重 auto_increment 可以使字段值字段递增，alter table 表名 auto_increment=值 可以手动调整增长的开始值 多表查询 交叉连接 select * from 表1名, 表2名; select * from 表1名 cross join 表2名; 交叉连接是对两个表执行笛卡尔积，返回两个表行数据对所有组合，生成表大小为 表1行数 * 表2行数 内连接 SELECT * FROM INNER JOIN ON ; SELECT * FROM , WHERE ; 内连接是先产生笛卡尔积，然后对数据进行过滤，只保留满足条件的数据行 在只有连个表的时候，最好使用 on 进行内连接，会先进行筛选在连接，更高效 外连接 外连接分为左外连接和右外连接 SELECT * FROM LEFT JOIN ON . = .; SELECT * FROM RIGHT JOIN ON . = .; 左外连接表示无论右表是否能匹配，都保留左表的数据 右外连接表示无论左表是否能匹配，都保留右表的数据 MySQL中没有全连接，全连接就是交叉连接 联合查询 两个表要查询的字段一样，就可以使用联合查询用一个表展示结果 SELECT FROM UNION SELECT FROM ; 联合查询可以使用关键字 union 或者 union all ，区别在于union会去除重复数据 子查询 自查询就是在查询中嵌套查询，自查询可以使用 IN、NOT IN、ANY、ALL、EXISTS 和 NOT EXISTS 等关键字，如果自查询结果只有一个值，还可以使用比较运算符来连接子查询， TODO in exists any all 的区别 约束和索引 约束 show create table 表名 - 可以查看哪些表中约束的详情 主键约束 primary key create table 表名 (字段名 字段类型 primary key); alter table 表名 modify 字段名 字段类型 primary key; alter table 表名 drop primary key; 添加数据时主键字段不能为null 唯一约束 create table 表名 (字段名 字段类型 unique); alter table 表名 modify 字段名 字段类型 unique; alter table 表名 drop index 字段名 一个表中可以有多个唯一约束 添加数据时唯一约束字段可以为空 检查约束 create table 表名 (字段名 字段类型 check (检查约束条件)); alter table 表名 add constraint 检查约束名 check (检查约束条件); 注意：mysql中检查约束不会进行报错 默认值约束 create table 表名 (字段名 字段类型 defalut 默认值); alter table 表名 modify 字段名 字段类型 defalut 默认值; alter table 表名 alter column 字段名 DROP DEFAULT 外键约束 create table 表名 (字段名 参照表名 参照表字段名 foreign key (字段名) references 参照表名(参照表字段名)); alter table 表名 add constraint 外键名 foreign key 字段名 references 参照表名(参照表字段名); 索引 普通索引 create index 索引名 on 表名(字段名); alter table 表名 add index 索引名(字段名); drop index 索引名 on 表名; 普通索引通常使用bTree 普通索引找到符合的选项后会继续向下找直到最后 唯一索引 create unique index 索引名 on 表名(字段名); alter table 表名 add unique 索引名 (字段名); 唯一索引找到符合的值后就返回 主键索引 alter table 表名 add primary key (字段名); 主键索引必须唯一，而且非空 添加主键索引其实就是添加主键约束 全文索引 create table 表名 (字段名 字段类型,..., fulltext (字段名, ...)); MySQL 权限与用户管理 delete from 数据库.表名 where host='允许访问的地址' and user='用户名' 限制账户资源 max_questions：用户每小时允许执行的查询操作次数 max_updates：用户每小时允许执行更新操作次数 max_connections：用户每小时允许执行的连接操作次数 max_user_connections：用户允许同时建立的连接次数 grant select on 数据库名.表名 to '用户名'@'允许访问的地址' with max_questions_per_hour 3 max_user_connections 5; alter table '用户名'@'允许访问的地址' with max_queries_per_hour 50; create user '用户名'@'允许访问的地址' identified by '密码' with max_queries_per_hour 20 设置密码 set password for '用户名'@'允许访问的地址'=PASSWORD('新密码'); grant usage on 数据库名.表名 to '用户名'@'允许访问的地址' identified by '新密码'; 事务 事务必须同时满足 ACID 四个条件：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）。 原子性：事务中所有的操作，要么全部执行，要么全不执行，若中途发生异常，会回滚。 一致性：事务从开始到结束，数据库都具有完整性，这是对数据库层面和应用层面的双重保障。 隔离性：用来保证多个并发事务对数据进行操作，不会发生受到干扰。 持久性：用来保证事务提交后，对数据的修改具有永久性。 数据库并发问题主要有以下三类： 脏读：当前事务读到其他事务未提交的数据。 幻读：事务 1 按照某个条件多次查询数据库，但每次查询的结果行数不同。 不可重复读：事务 1 多次读取同一数据资源，与此同时事务 2 对该数据进行了多次修改，这导致事务 1 每次读取的数据显示结果不同。 MySQL事务的隔离级别分为以下四种： 读未提交（READ-UNCOMMITTED）：可能发生脏读、可幻读和不可重复读。 读已提交（READ-COMMITTED）：可能发生幻读、不可重复读，不可能发生脏读。 可重复读（REPEATABLE-READ）：可能发生幻读，但不会发生脏读和不可重复读。 串行化（SERIALIZABLE）：不可能发生幻读、脏读、可重复读。 从事务理论的角度来看，可以把事务分为以下几种： 扁平事务（Flat Transactions）：所有操作处于同一层次，要么都执行，要么回滚。 带有保存点的扁平事务（Flat Transactions with Savepoints）：保存点是用来通知系统应该记住事务当前的状态，以便在发生错误时，可以回滚到保存点的状态。 链事务（Chained Transactions）：在提交一个事务时，释放不需要的数据对象，将必要的处理上下文隐式地传递给下一个开始事务，下一个事务会看到上一个事务的结果。 嵌套事务（Nested Transactions）：是一个层次结构的框架，由一个顶层事务控制着各个层次的事务，顶层之下的事务称为子事务，子事务控制着每一个局面的变化。 分布式事务（Distributed Transactions）：通常是一个在分布式环境下运行的扁平事务，因此需要根据数据所在的位置访问网络中的不同节点。 SELECT @@TX_ISOLATION; - 查看事务隔离级别 事务的控制语句 BEGIN 或 START TRANSACTION - 显式地开启一个事务 COMMIT 或 COMMIT WORK - 提交事务，并使已对数据库进行的所有修改成为永久性的 ROLLBACK 或 ROLLBACK WORK - 结束用户的事务，并撤销正在进行的所有未提交的修改 SAVEPOINT - 允许在事务中创建一个 SAVEPOINT，一个事务中也可以有多个 SAVEPOINT RELEASE SAVEPOINT - 删除一个事务的保存点，当没有指定的保存点时，执行该语句会抛出一个异常 ROLLBACK TO - 把事务回滚到标记点 SET TRANSACTION - 用来设置事务的隔离级别 SET AUTOCOMMIT = 0 或 SET AUTOCOMMIT = 1 - 关闭/开启自动提交 存储引擎 SHOW ENGINES\\G; 或 SELECT * FROM INFORMATION_SCHEMA.ENGINES\\G; - 查看存储引擎 MyISAM存储引擎 .frm 文件存储表的定义数据 .MYD（MYData） 存放表具体记录的数据 .MYI（MYIndex） 文件用来存储索引 数据文件和索引文件可以放置在不同的目录下，获得更快的速度。 当按排序顺序插入行时，比如，使用 AUTO_INCREMENT 列时，索引树将被拆分，以便高级节点仅包含一个键，这样可以提高索引树的空间利用率。 AUTO_INCREMENT 支持每个表对一列数据的内部处理。MyISAM 自动更新此列的 INSERT 和 UPDATE 操作。这使得 AUTO_INCREMENT 列会更快。 当表损坏时，MyISAM 类型的表提供修复工具，可以使用 CHECK TABLE 来检查表的情况，并且可用 REPAIR TABLE 来修复。 MyISAM支持三种存储格式： 静态固定长度表：默认存储格式，存储速度快、易缓存、易修复，但是占空间。 动态可变长度表：由于记录不是固定长度，所以能够节省空间，但发生错误后，不易恢复。 压缩表：占用磁盘空间小，当数据文件发生错误时，可检查也可恢复。 create table 表名(字段名 字段类型,...) engine=MyISAM; - 创建MyISAM存储引擎的表 MEMORY存储引擎 .frm 文件存储表和数据 MEMORY 支持 HASH 和 BTREE 这两种索引的数据结构，默认的是 HASH 索引。 支持的数据类型有限制，例如，不支持 TEXT 和 BLOB 类型，VARCHAR 会被自动存储为 CHAR 类型。 数据存储在内存中，一旦服务器出现故障，数据都会丢失。 create table 表名(字段名 字段类型,...) engine=MyISAM; - 创建MEMORY存储引擎的表 ARCHIVE存储引擎 ARCHIVE 存储引擎将产生大量未索引数据存储在一个小的专用表里。 创建 ARCHIVE 表时，服务器会在数据库目录中创建表格式文件。该文件以表名开头，并具有 .frm 扩展名。存储引擎创建其他文件，所有文件的名称均以表名开头。数据文件的扩展名为 .ARZ。在 .ARN 优化过程中，操作文件可能会出现。 ARCHIVE 存储引擎支持 INSERT，REPLACE 和 SELECT 操作，但是不支持 DELETE 或者 UPDATE 操作。它支持 ORDER BY 操作，BLOB 列以及基本上所有的数据类型，包括空间数据类型。 压缩协议进行数据存储只允许自增 id 列建立索引。 ARCHIVE 存储引擎主要会应用在日志系统或者设备数据中 create table 表名(字段名 字段类型,...) engine=ARCHIVE; - 创建ARCHIVE存储引擎的表 InnoDB存储引擎 MySQL中只有InnoDB支持外键 InnoDB 存储引擎支持事务，它的操作遵守 ACID 原则，并具有提交、回滚和恢复的功能去保护用户的数据。 具有行级锁，提高多用户并发性。 InnoDB 表将数据存放在磁盘上，基于主键优化查询，每个 InnoDB 都有一个称为聚集索引的主键索引。 InnoDB 存储引擎支持外键约束，能够维护数据的完整性，使用外键检查 INSERET，UPDATE 和 DELATE 操作，以确保它们不会导致不同表之间的不一致。 如果服务器因为软件或者硬件问题而崩溃，InnoDB 会自动恢复到崩溃之前已经提交的所有更改处，仅需重启并从上次中断的地方继续即可。 InnoDB 存储引擎会维护它自己的缓冲池，在主内存缓存表和索引数据作为数据被访问，这个缓存适用于多种类型的信息并且加快处理速度。 如果将数据拆分到不同的表里，设置外键去增强完整性。更新或者删除数据，会自动更新或者删除其他表里的相关数据。 创建数据库并在每张表中设置合适的主键后，这些列操作会自动进行优化。 能够压缩表和关联索引。 能够创建和删除索引，对性能的影响很小。 能够通过查询 INFORMATION-SCHEMA 表来监控存储引擎的内部工作情况。 可以通过查询 Performance Schema 表去监控存储引擎的性能详细信息。 能够将 InnoDB 表和其他存储引擎表混合使用，例如，可以使用联接操作在单个查询中合并来自 InnoDB 和 MEMORY 表中的数据。 InnoDB的锁 MySQL中有三种锁： 表级锁：开销大，加锁快，不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度低。 行级锁：开销大，加锁慢，会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度最高。 页面锁：开销和加锁时间界于表锁和行锁之间，会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。 InnoDB支持行级锁和表级锁，默认采用行级锁 InnoDB中两种类型的行锁： 共享锁（S）:允许一个事务读一行数据，阻止其他事务获得相同数据集的排他锁。 排他锁（X）:允许获得排他锁的事务更新数据，阻止其他事务取得相同的数据集的共享锁和排他写锁。 InnoDB中两种意向锁，均为表锁，是为了实现行锁和表锁共存，意向锁锁InnoDB自动添加的 意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的 IS 锁。 意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的 IX 锁。 SELECT * FROM WHERE LOCK IN SHARE MODE; - 给表添加共享锁 SELECT * FROM WHERE FOR UPDATE; - 给表添加排他锁 行锁的实现：通过对索引上对索引项添加锁来实现，如果没有索引，就给主键（或隐藏主键）索引记录加锁 记录锁 (Record Lock)：锁定的是索引记录。 间隙锁（Gap Lock）：对索引之间的间隙锁定，也能对第一个或最后一个索引记录之前的间隙锁定。 临键锁（Next-Key Lock）：间隙锁和记录锁的一个组合，对记录和前面的间隙加锁，用来解决数据库的幻读问题。 行锁是通过索引上对索引项来实现的，只有通过索引条件来检索数据才使用行级锁，否则使用表级锁 SHOW FULL PROCESSLIST\\G; - 查看当前线程处理情况，对处理突发事件非常有用 SHOW ENGINE INNODB STATUS\\G; - 查询 InnoDB 当前锁请求的信息 SELECT * FROM INFORMATION_SCHEMA.INNODB_TRX\\G; - 查看当前运行的事务 SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCKS\\G; - 查看当前出现的锁 SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCK_WAITS\\G; - 查看锁等待的对应关系 MySQL优化 数据表优化 设计表尽量避免NULL出现，可以使用0来代替 尽量使用int而不是bigint 使用枚举或整数代替字符串类型 尽量用timestamp代替datetime 尽量不使用like语句，不要在列上进行运算 不要使用not in，可以用not exists代替 表中数据类型的优化 select * from 表名 procedure analyse()\\G; - 查看表中是否有可以优化的列 analyze table 表名; - 分析和存储表的关键字分布，这个分析结果可以让SQL生成正确的执行计划 check table 表名; - 检查表是否有错误，只对MyISAM有效 optimize table 表名; - 优化表，对MyISAM和InnoDB都有效 索引优化 尽量在where和order by命令涉及的列建索引 通过explain查看是否使用到了索引 避免在where中使用null判断，会放弃使用索引 值分布很少的字段不适合添加索引，字符字段只做前缀索引，字符字段不要做主键，尽量不用unique，由应用约束 查询的性能优化 show session status; - 当前连接的统计结果 show global status; - 自数据库上次启动到现在到统计结果 Com-select: 执行 SELECT 操作的次数，查询一次计数会增加一次。 Com-insert: 执行 INSERT 操作的次数，对于一次性插入多行数据，仅记为一次插入。 Com-update: 执行 UPDATE 操作的次数。 Com-delete: 执行 DELETE 操作的次数。 SHOW INDEX FROM ; - 可以查看某表的索引情况 Non_unique 是索引是否有重复值，若无重复值则为 0，否则为 1。 Key_name 是索引的名字。 Seq_in_index 是索引中的列序号，从 1 开始。 Collation 是列存储在索引中的方式，NULL 代表无分类，A 代表升序。 Cardinality 是索引中唯一值的数目估计值。 Sub_part 是前置索引，如果列只是部分被编入索引，则为被编入索引的字符的数目。如果整列被编入索引，则为 NULL。 Packed 是说明关键字如何被压缩，若未被压缩，则为 NULL。 Index_type 是索引类型。 Comment 是在其列中没有描述的索引的信息。 Index_comment 是为索引创建时提供了一个注释属性索引的任何评论。 EXPLAIN SELECT COUNT(*) FROM employee USE INDEX (idx_id_name)\\G; - 建议查询器使用某个索引查询 EXPLAIN SELECT COUNT(*) FROM employee IGNORE INDEX (idx_id_name)\\G; - 忽略某个索引查询 EXPLAIN SELECT * FROM employee FORCE INDEX(idx_salary) WHERE salary - 强制使用某个索引查询 日志 错误日志(error log) 记录 MySQL 服务器在启动、停止和运行过程中发生任何严重警告和错误的信息 SHOW VARIABLES LIKE 'LOG_ERROR'; - 查看错误日志的存放位置 中继日志(relay log) 用于主从复制，临时存储从主库同步的二进制日志 SHOW VARIABLES LIKE '%RELAY%'; - 查看中继日志的具体信息 max_relay_log_size - 是中继日志允许的最大值，若该值为 0，则默认其最大值为 1 G。 relay_log - 定义了中继日志的位置和名称，若值为空，则是在数据文件的默认位置。 relay_log_basename - 也是定义了中继日志的位置和名称。 relay_log_index - 定义了中继日志索引的位置和名称。 relay_log_info_repository - 确定中继日志是放在 FILE 还是 TABLE 里。 relay_log_purge - 是否自动清空中继日志，ON 为启动。 relay_log_recovery - 当中继日志损坏，是否保存所有未执行的中继日志，OFF 为关闭。 relay_log_space_limit - 设置中继日志最大限额。 sync_relay_log - 是否把日志写入缓存。 慢查询日志(slow query log) 慢查询日志是用来记录所有执行时间超过 long_query_time 秒的所有查询，其 long_query_time 的默认值为 10 秒 SHOW VARIABLES LIKE '%QUERY%' - 查看慢查询配置 long_query_time - 指定慢查询的时间阀值，默认为 10。 slow_query_log - 是否开启慢日志，默认是关闭。 slow_query_log_file - 是记录慢日志到文件中的路径 SET GLOBAL SLOW_QUERY_LOG=ON/OFF; - 开启/关闭慢查询日志 SET GLOBAL LONG_QUERY_TIME=5; - 修改阈值 二进制日志(binary log) 二进制日志是记录了所有的数据库定义和操纵语句，当数据库内容变化时，会产生二进制文件，也被用来实现主从复制，主要有三种格式 STATEMENT 是语句格式，通过 mysqlbinlog 工具可以清楚看到每条语句的文本。 ROW 是将每一行变更记录到日志中。 MIXED 是混合了 STATEMENT 和 ROW 这两种格式。 SHOW VARIABLES LIKE '%LOG_BIN%' - 查看二进制日志的相关信息 log_bin：记录二进制日志是否开启。 log_bin_trust_function_creators：是否允许用户创建和更改存储函数，默认是 OFF。 log_bin_use_v1_row_events：二进制日志的版本信息，默认为 OFF。 sql_log_bin：是否停止对二进制的写入。 SHOW BINARY LOGS; - 查看当前使用了哪些二进制文件 SHOW BINLOG EVENTS\\G; - 查看日志中进行了哪些操作 SHOW MASTER STATUS\\G; - 查看当前二进制的位置 SHOW MASTER LOGS; - 显示服务器所有二进制文件 SET sql_log_bin=0/1; - 禁用/启用当前会话二进制日志 SET GLOBAL BINLOG_FORMAT='' - 修改二进制日志的格式，可选值为statement、row、mixed PURGE MASTER LOGS TO ‘’ - 清空该文件中的日志 reset master - 删除所有日志 普通查询日志(general query log) 普通查询日志是记录客户端连接数据库执行语句时所产生的日志。 普通查询日志默认是关闭的 SHOW VARIABLES LIKE '%GENERAL_LOG%'; - 查看一下普通查询日志是否开启 SET GLOBAL GENERAL_LOG=ON/OFF - 开启/关闭普通查询日志 SHOW VARIABLES LIKE '%LOG_OUTPUT%'; - 查看普通查询日志输出格式 SET GLOBAL LOG_OUTPUT='TABLE'; - 普通查询日志输出格式改为table 元数据日志(metadata log) 数据库备份和恢复 逻辑备份 将数据库中表的数据以文本文件形式备份，可以使用mysqldump来实现 mysqldump [主机号][端口][用户名][密码][数据库名][表1][表2] > [文件名].sql - 备份指定数据库的多个表 mysqldump [主机号][端口号][用户名][密码] --databases [数据库名1][数据库名2] > [文件名].sql - 备份指定数据库全部内容 mysqldump [主机号][端口号][用户名][密码] --all-databases > [文件名].sql - 备份所有数据库 还可以使用mydumper命令进行备份，mydumper支持多线程，速度更快，功能也更多 物理备份 表空间的迁移技术 在迁移过程中，表仅处于只读状态，需要将 innodb_file_per_table 设置为 ON SHOW VARIABLES LIKE '%PER_TABLE%' - 查看参数值 SET GLOBAL innodb_file_per_table=ON - 设置参数为ON FLUSH TABLES FOR EXPORT - 锁定表，锁定后表无法执行增删查改操作 使用热备份工具备份 可以使用Xtrabackup热备份工具进行备份。备份分为全量、增量、日志备份。 数据恢复 使用mysqldump备份的数据可以通过 mysql -u root 数据库名 进行恢复 文本文件可能进行了更改二进制文件恢复需要使用mysqlbinlog mysqlbinlog [二进制日志文件名]|mysql -u root [数据库名] - 恢复数据后重做日志 使用mydumper备份的数据可以通过myloader进行恢复 Copyright © book.stolenzc.com 2021-2023 all right reserved，powered by GitbookFile Modify: 2023-06-27 07:48:51 "},"Project.html":{"url":"Project.html","title":"项目","keywords":"","body":"项目开发技术 一. MySQL主从配置 1. 配置文件说明 windows:C:\\ProgramData\\MySQL\\MySQL Server 5.7\\my.ini centos:etc/my.cnf 2. 主机配置 [mysqld] server-id=200 设置主服务器的ID innodb_flush_log_at_trx_commit=2 操作系统崩溃或者系统断电的情况下，上一秒钟所有事务数据才可能丢失 sync_binlog=1 开启binlog日志同步功能 log-bin=mysql-bin-200 binlog日志文件名 binlog-do-db=xxxx # 这个表示只同步某个库 （如果没有此项，表示同步所有的库） 重启mysql：service mysqld restart 给从机创建用户授权： CREATE USER 'xiaoluo'@'10.7.185.99' IDENTIFIED WITH mysql_native_password BY '123456'; grant replication slave on *.* to 'mark'@'192.168.1.201'; 查看主机库的状态：show master status ; 3. 配置从机 [mysqld] server-id=201 innodb_flush_log_at_trx_commit=2 sync_binlog=1 log-bin=mysql-bin-201 重启mysql：service mysqld restart 进入mysql命令行： mysql> change master to master_host='192.168.1.200', master_user='mark', master_password='123456', master_log_file='mysql-bin-200.000002' ,master_log_pos=1167; mysql> start slave; ##开启从库 (stop slave：关闭从库） mysql> show slave status\\G; ###Slave_IO_Running,Slave_SQL_Running 都为Yes的时候表示配置成功 4. django下实现读写分离 在项目下的urls.py文件同级目录下创建database_router.py文件 from django.conf import settings import random DATABASE_MAPPING = settings.DATABASE_APPS_MAPPING class DatabaseAppsRouter(object): def db_for_read(self, model, **hints): \"\"\"\"Point all read operations to the specific database.\"\"\" print('*' * 20) label = random.choice(list(DATABASE_MAPPING.keys())) print(label) return DATABASE_MAPPING[label] def db_for_write(self, model, **hints): \"\"\"Point all write operations to the specific database.\"\"\" if model._meta.app_label in DATABASE_MAPPING: return DATABASE_MAPPING[model._meta.app_label] return None def allow_relation(self, obj1, obj2, **hints): \"\"\"Allow any relation between apps that use the same database.\"\"\" db_obj1 = DATABASE_MAPPING.get(obj1._meta.app_label) db_obj2 = DATABASE_MAPPING.get(obj2._meta.app_label) if db_obj1 and db_obj2: if db_obj1 == db_obj2: return True else: return False return None # for Django 1.4 - Django 1.6 def allow_syncdb(self, db, model): \"\"\"Make sure that apps only appear in the related database.\"\"\" if db in DATABASE_MAPPING.values(): return DATABASE_MAPPING.get(model._meta.app_label) == db elif model._meta.app_label in DATABASE_MAPPING: return False return None # Django 1.7 - Django 1.11 def allow_migrate(self, db, app_label, model_name=None, **hints): print(db, app_label, model_name, hints) if db in DATABASE_MAPPING.values(): return DATABASE_MAPPING.get(app_label) == db elif app_label in DATABASE_MAPPING: return False return None 在settings.py文件中添加： DATABASES = { # 主库 （读写操作 R/W) 'default': { 'ENGINE': 'django.db.backends.mysql', 'NAME': 'test', 'USER': 'root', 'PASSWORD': '1qaz2wsx', \"HOST\": \"10.7.185.71\", 'PORT':'', }, # 从库 (读操作 R) 'db2': { 'ENGINE': 'django.db.backends.mysql', 'NAME': 'test', 'USER': 'root', 'PASSWORD': '123456', \"HOST\": \"10.7.185.92\", 'PORT':'', }, } DATABASE_ROUTERS = ['项目名称.database_router.DatabaseAppsRouter'] DATABASE_APPS_MAPPING = { 'hr_w': 'default', 'sales_w': 'default', 'hr_r': 'db2', 'sales_r': 'db2' } 在应用的module.py文件中定义模型最后添加： # 指定模型创建关联的数据库 class Meta: app_label = 'sales_w' db_table = 'game' Django部署上线 1. 修改配置文件 检查程序：python manage.py check --deploy 调试相关： DEBUG = False ALLOWED_HOSTS = ['*'] 安全相关： # 保持HTTPS连接的时间 SECURE_HSTS_SECONDS = 3600 SECURE_HSTS_INCLUDE_SUBDOMAINS = True SECURE_HSTS_PRELOAD = True # 自动重定向到安全连接 SECURE_SSL_REDIRECT = True # 避免浏览器自作聪明推断内容类型 SECURE_CONTENT_TYPE_NOSNIFF = True # 避免跨站脚本攻击 SECURE_BROWSER_XSS_FILTER = True # COOKIE只能通过HTTPS进行传输 SESSION_COOKIE_SECURE = True CSRF_COOKIE_SECURE = True # 防止点击劫持攻击手段 - 修改HTTP协议响应头 # 当前网站是不允许使用标签进行加载的 X_FRAME_OPTIONS = 'DENY' 敏感信息放在环境变量中： SECRET_KEY = os.environ['SECRET_KEY'] DB_USER = os.environ['DB_USER'] DB_PASS = os.environ['DB_PASS'] REDIS_AUTH = os.environ['REDIS_AUTH'] 2. 项目结构 project ├── code │ └── fangtx │ ├── api │ ├── common │ ├── fangtx │ ├── forum │ ├── rent │ ├── user │ ├── manage.py │ ├── README.md │ ├── static │ └── templates ├── conf │ ├── cert │ │ ├── 214915882850706.key │ │ └── 214915882850706.pem │ ├── nginx.conf │ └── uwsgi.ini ├── logs │ ├── access.log │ ├── error.log │ └── uwsgi.log ├── stat │ └── css │ └── images │ └── js └── venv code下存放项目源码 conf下存放nginx配置文件 cert下为https的认证证书 logs下面为日志文件 stat下为静态文件夹 venv下为虚拟环境 配置ssl： 编辑nginx.conf: server { listen 443 ssl http2 default_server; listen [::]:443 ssl http2 default_server; server_name _; root /usr/share/nginx/html; ssl_session_cache shared:SSL:1m; ssl_certificate cert/a.pem; #将domain name.pem替换成您证书的文件名。 ssl_certificate_key cert/b.key; #将domain name.key替换成您证书的密钥文件名。 ssl_session_timeout 5m; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; #使用此加密套件。 ssl_protocols TLSv1 TLSv1.1 TLSv1.2; #使用该协议进行配置。 ssl_prefer_server_ciphers on; # Load configuration files for the default server block. include /etc/nginx/default.d/*.conf; location / { root /home/nginxHTML; index index.html index.htm; } error_page 404 /404.html; location = /40x.html { } error_page 500 502 503 504 /50x.html; location = /50x.html { } } 在80端口书写rewrite ^(.*)$ https://$host$1 permanent;可以将http的访问转发到https中去 在django的manager.py目录同级下创建uwsgi.ini文件 关闭uwsgi进程命令:pkill -f uwsgi -9 启动uwsgi进出命令:uwsgi --ini uwsgi.ini & 重启nginx:systemctl restart nginx Copyright © book.stolenzc.com 2021-2023 all right reserved，powered by GitbookFile Modify: 2023-06-27 07:48:51 "},"PythonNote.html":{"url":"PythonNote.html","title":"Python基础","keywords":"","body":"入门基础 Pycharm快捷使用 ctr + / - 添加注释和取消注释 ctr + shift + z - 反撤销 alt + Enter - 快速导包 基础/变量与运算符 注释 单行注释: 在注释性文字的开头加# 多行注释: 用三个单引号或者三个双引号引起来 语句 一条语句占一行，语句结束的时候不用写分号；如果一行写多条语句，语句之间必须用分号隔开 如果一条语句的长度超过一定范围需要换行显示，就换行位置前加\\ (注意: \\的位置不能破坏数据) result = 789789798798798 + 378923498732 \\ - 37489172348 * 32471827349 /\\ 1203472893 + 2873498237 行和缩进 一条语句的前面不能随意添加空格或缩进 有的时候语句的前面必须有一个缩进(四个空格表示一级缩进-PEP8规范) 标识符(命名规范) 要求: 由字母、数字和下划线组成，并且数字不能开头（注意: 其实标识符可以包含中文，但是不要这样做） PEP8规范: 变量 - 所有字母都小写,如果有多个单词单词之间用下划线隔开 函数名 - 应该小写，如果想提高可读性可以用下划线分隔。 类名 - 一般使用首字母大写的约定。 常量 - 通常定义在模块级，通过下划线分隔的全大写字母命名。 关键字 Python3.7有35个关键字，新添加的两个关键字为async和await 查看方法: import keyword print(keyword.kwlist) \"\"\" 'False', 'None', 'True', 'and', 'as', 'assert', 'async', 'await', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield' \"\"\" 内置函数 数据类型转换 bool() - 布尔类型 int() - 整数类型 float() - 浮点型 complex() - 复数 str() - 将数据转换为字符串 list() - 将可迭代对象转换为列表 tuple() - 将可迭代对象转换为元组 dict() - 创建一个字典 set() - 创建一个集合 frozenset() - 创建一个冻结的集合，不能进行添加删除 进制转换 bin() - 转换为二进制 oct() - 转换为八进制 hex() - 转换为十六进制 bin(10) # 0b1010 oct(10) # 0o12 hex(10) # 0xa 数学运算 abs() - 返回绝对值 divmod() - 返回商和余数 round() - 四舍五入 pow(a, b) - 求a的b次幂，如果有第三个参数，则求完后再取幂 sum() - 求和 min() - 最小值 max() - 最大值 abs(-2) # 2 divmod(20, 3) # (6, 2) round(4.6) # 5 pow(10, 2) # 100 pow(10, 2, 3) # 1 sum(1, 2, 3, 4, 5) # 15 min(1, 2, 3, 4, 5) # 1 max(1, 2, 3, 4, 5) # 5 数据结构 reversed() - 将序列翻转，返回翻转序列的迭代器，不改变原序列 slice() - 列表的切片 format() - 格式化字符串 - 左对齐 > - 右对齐 ^ - 居中对齐 = - 将填充放在符号之后数字之前 + - 表示正负数都应该使用一个符号 - - 表示只有负数应该用一个符号 空格 - 表示正数前用空格，负数前用负号 bytes() - 将字符串类型转换为bytes类型 ord() - 输入字符，返回字符编码 chr() - 输入字符编码，返回字符 ascii() - 是ascii码中的返回该值，不是就返回u repr() - 返回一个对象的string形式 lst = [1, 2, 3] reversed(lst) # [3, 2, 1] s = slice(1, 2, 1) lst[s] # [2] s = 'hello' format(s, '10') # 'hello ' format(s, '^10') # ' hello ' format(-5, '=5') # '- 5' format(5, '+') # '+5' format(+5, '-') # '5' format(5, ' ') # ' 5' 输入输出函数 输出函数: print(内容) end的用法 print(需要打印的内容, end='结束后的打印') sep的用法 print(需要打印的内容, sep='分隔的符号') print(100, 111, 222, sep='+', end=';\\n') #100+111+222;\\n 输入函数:input(屏幕提示信息) 注意: python2中应该使用raw_input，python2中input会用eval进行计算 进制 二进制: 表示方法: 加前缀0b或0B, 0b111 转换方式: bin(数字) 八进制: 表示方法: 加前缀0o或0O, 0o67 转换方式: oct(数字) 十六进制: 表示方法: 加前缀0x或0X, 转换方式: hex(数字) 二进制和字符串的转换: 字符串转二进制: bytes(字符串, encoding='utf-8') / 字符串.encode() 二进制转字符串: str(二进制, encoding='utf-8') / 二进制.decode(encoding='utf-8') 原码反码和补码 正数的原码反码和补码都是一样 90(10) -> 01011010(原码) -> 01011010(反码) -> 01011010(补码) 负数的原码是其绝对值的原码最高位(符号位)变为一 反码是符号位不变,其余位取反 补码是反码加一 -90(10) -> 1 1011010(原码) -> 10100101(反码) -> 10100110(补码) 变量声明 同时声明多个变量赋相同的值: 变量名1 = 变量名2 = ... = 值 同时声明多个变量赋不同的值: 变量名1, 变量名2,... = 值1, 值2,... 变量三要素: 值、地址、类型 id(变量/数据) - 获取变量/数据的地址 type(变量/数据) - 获取变量/数据的类型 运算符 数学运算符 +(加), -(减), *(乘), /(乘), %(取余), //(整除), **(幂运算) 比较运算符 > - 大于 - 小于 >= - 大于等于 - 小于等于 == - 等于 != - 不等于 注意： 所有的比较运算符的运算结果都是布尔值 is判断的是数据的地址是否相等 ==判断的是数据的值是否相等 逻辑运算符 and - 逻辑与运算 or - 逻辑或运算 not - 逻辑非运算 注意： 所有的逻辑运算符的运算结果都是布尔值 逻辑运算符的短路： and的短路操作: and前面的条件如果是False, 那么and后面的条件语句不会执行 or的短路操作: or前面的条件如果是True,那么or后面的条件语句不会执行 逻辑运算符的数字运算 \"\"\" num1 and num2 - 如果num1是0结果就是0，如果num1不为0结果是num2 num1 or num2 - 如果num1为0结果就是num2, 如果num1不为0结果就是num1 \"\"\" print(6 and 7, 10 and 1, 0 and 3, -1 and 4) #7 1 0 4 print(4 or 3, 2 or 10, 0 or 2) #4 2 2 赋值运算符 =, +=, -=, *=, /=, %=, **= 变量 = 值 - 将后面的值赋给左边的变量 注意: 如果值是已经赋值过的变量，它将是将地址赋给变量 +=, -=, *=, /=, %=, **= 变量 += 值 -> 变量 = 变量 + 值 位运算 & - 按位与 | - 按位或 ^ - 按位异或 ~ - 按位取反 >> - 右移运算符 - 左移运算符 成员运算符 in - 如果在指定的序列中找到了值返回True，否则返回False not in - 如果在指定的序列中找到了值返回False，否则返回True 身份运算符 is - 判断两个标识符是不是引用一个对象，判断地址是否一样 is not - 判断两个标识符是不是引用不同的对象 运算顺序 优先级从高到低: 数学运算符 > 比较运算符 > 逻辑运算符 > 赋值运算 运算符优先级 ** ~ + —(正负号) * / % // + - >> >= == != = %= += -= //= /= is is not in not in not or and python语法结构 for循环 for 变量名 in 序列: 循环体 range函数: range(M, N, step) - 从M开始，每次加step产生下一个数字，到N为止(不包括N)，M默认为0，可省略，step默认为1，可省略。 while循环 while 条件语句: 循环体 if分之 if 条件语句1: 代码段1 elif 条件语句2: 代码段2 elif 条件语句3: 代码段3 else: 代码段N 三目运算符 值1 if 条件语句 else 值2 -> 如果条件语句的结果是True，那么整个运算的结果就是值1，否则是值2 三个关键字 continue continue是循环体中的关键字,只能用在循环体中。用的时候直接用。 执行循环体的时候如果遇到continue,直接结束当次循环，进入下次循环的判断 break break是循环体中的关键字，只能用在循环体中；用的时候直接用。 如果在执行循环体的时候遇到了break,那么整个循环直接结束 else 和else关联的循环自然死亡，else后面的代码段会执行；如果循环是因为遇到break而结束，else后面的代码段不会执行 for 变量 in 序列: 循环体 else: 代码段 while 条件语句: 循环体 else: 代码段 变量类型 数字类型 int:整型 整型中 -5~256为不可变，其余为可变 float:浮点型 支持科学计数法(3e4) bool:布尔类型 True本质为1,False本质为0 complex:复数类型 j为虚数单位,j*j=-1 数据类型相关方法 type(数据) - 获取指定数据类型 isinstance(数据, 类型) - 判断指定的数据是否是指定的类型 类型(数据) - 将数据转换成指定类型，int() float() bool() str() 等 abs(数据) - 取该数据的绝对值 任何数据类型的数据都能转换成布尔; 所有为零，为空的值都会转换成False,其他的都是True 为False的时候: print(bool(0), bool(0.00), bool(''), bool([]), bool({}), bool(()), bool(None)) Random随机数 需要先import random 随机挑选 random.choice(序列) - 在序列中随机挑选出一个元素 在指定范围内取一个随机数 random.randrange(开始, 结束, 步长) random.randrange(结束) - 从0到结束之间选取一个随机数 产生[0, 1)的随机数 random.random() 随机排序 random.shuffle(列表) - 将列表中的元素随机排序(序列必须是可变的) 产生随机浮点数 random.uniform(m, n) - 产生[m, n]的随机浮点数 产生随机整数 random.randint(m, n) - 产生[m, n]的随机整数 数学方法 import math #向上取整（得19） print(math.ceil(18.1)) print(math.ceil(18.9)) #向下取整（得18） print(math.floor(18.1)) print(math.floor(18.9)) #返回整数部分和小数部分(小数在前，整数在后) print(math.modf(12.8)) # 0.8 12.0 #开平方 print(math.sqrt(16)) 列表list 获取列表元素 获取单个元素 列表[下标] - 获取列表中指定下标对应的元素 0 ~ 长度-1(从前往后取) -1 ~ -长度(从后往前取) 0表示第一个元素， -1表示最后一个元素 获取部分元素(列表切片) 列表[start:end:step] - 从开始下标开始取，每次下标值增加步长去取下一个元素，直到取到结束下标前一个元素为止。返回的数据一定是列表 列表[start:end] - 步长为1 列表[:结束下标:步长] / 列表[:结束下标] 步长为正，从下标为0开始；步长为负，从最后一个元素开始 省略结束下标: 列表[start::step] / 列表[start:] 步长为正，取到最后一个元素为止；步长为负，取到第一个元素为止 开始下标和结束下标都省略: 列表[::step] / 列表[:] 遍历列表 直接遍历元素 for 元素 in 列表: pass 变量取到的就是列表中的每个元素 通过遍历下标来遍历列表元素 for 下标 in range(列表长度): 元素 = 列表[下标] 获取列表长度: len(列表) 同时获取值和下标 for 下标, 元素值 in enumerate(列表): pass 增加元素 列表.append(元素) - 在列表的最后中添加指定的元素。（直接影响原列表不会产生新的列表） 列表.insert(下标, 元素) - 在列表指定下标前插入指定的元素 list.extend([元素1，元素2]) - 在list列表末端拆分增加多个元素；传入必须是数据容器 删除元素 del 列表[下标] - 删除列表中指定下标对应的元素 (del 列表 - 删除列表) 列表.remove(元素) - 删除列表中指定的元素(如果这个元素有多个只删第一个) 列表.pop() - 取出列表最后一个元素, 返回被取出的元素 列表.pop(下标) - 取出列表中指定下标对应的元素，返回被取出的元素 更改元素 列表[下标] = 新值 - 将列表中指定下标对应的元素改成新值 列表的数学运算符 列表1 + 列表2 - 将两个列表中的元素合并在一个产生一个新的列表 nums1 = [100, 10, 80] strs = ['abc', 'hello', 'how', 'are'] print(nums1 + strs) # [100, 10, 80, 'abc', 'hello', 'how', 'are'] 列表 * N / N * 列表 - 列表中的元素重复N次产生一个新的列表 nums1 = [100, 10, 80] print(nums1 * 3) # [100, 10, 80, 100, 10, 80, 100, 10, 80] 列表的比较运算符 ==, != -> 判断两个列表是相等/不相等(两个列表只有元素个数、元素的值和元素顺序都一样的时候才相等) list1 = [1, 2, 3] print(list1 == [1, 2, 3]) # True print(list1 is [1, 2, 3]) # False print([] is []) # False 比较大小 从第一个元素开始进行比较，ASCII值大的大，类型不同无法比较 列表的in和not in 元素 in 列表 - 判断列表中是否存在指定的元素，结果是布尔 元素 not in 列表 - 判断列表中是否不存在指定的元素，结果是布尔 相关函数 len(序列) - 统计序列中元素的个数(迭代器和生成器不行) max(序列)/min(序列) - 求序列中元素的最大值/最小值(迭代器和生成器不行) 注意: 序列中的元素的类型必须一致，并且支持比较运算符 list(数据) - 将指定的数据转换成列表 sum(序列) - 求序列中所有元素的和(序列中的元素只能是数字) 相关方法 列表.count(元素) - 统计列表中指定元素的个数；返回值是该元素的个数 列表.index(元素) - 获取元素在列表中的下标(正值); 如果元素不存在则报错；如果元素有多个只获取第一个的下标 列表.reverse() - 反向列表(不会产生新的列表)(改变本身的顺序) 列表.clear()/列表名 = [] - 清空列表 列表.copy() - 复制/拷贝列表中的元素产生一个新的列表, 和'列表[:]'的功能一样。这个拷贝是浅拷贝 对列表中元素排序 列表.sort() - 改变本身的顺序，默认升序，括号中填入reverse=True改为降序 注意: 列表中的元素类型必须一致，而且元素本身支持比较大小的运算 sorted(序列, reverse=True) - 对序列中的元素排序(会产生一个新的列表)，默认升序，reverse改为降序 元组tuple 元组简介 元组就是不可变的列表(列表中除了增删改，以及 列表. 相关的方法，元组不能用，其他元组和列表一样) 元组是容器型数据类型(序列); 将()作为容器的标志,多个元素用逗号隔开: (元素1,元素2,元素3...) 元祖不可变，有序, 若元组的元素为列表，列表可以变 只有一个元素的元组: (元素1,) 没有元素的元组: () Tuple1 = (10,) Tuple2 = () 直接用逗号将多个数据隔开，表示一个元祖 Tuple2 = 10, 20, 30, 'abc' 获取元组元素 让变量的个数和元组中元素的个数保持一致 point = (10, 100, 100) x, y, z = point 用多个变量分别取获取元素的时候，在一个变量前加*(这个变量就变成列表); tuple5 = ('小明', 18, 90, 78, 36, 85, '男', 180) name, *scores, sex, height = tuple5 print(name, scores, sex, height) # 小明 [18, 90, 78, 36, 85] 男 180 *的特殊用法2: 拆包 nums = [1, 2, 3] print(nums) print(*nums) # print(1, 2, 3) 元组方法 del 元组 - 删除元组 + - 元组连接 * - 元组重复 in/not in - 判断元素是否在元组中 元组名[开始下标:结束下标] - 元组的截取 len(元组名) - 返回元组中元素的个数 min(元组名) - 返回元组中的最小值 max(元组名) - 返回元组中的最大值 tuple(列表) - 将列表转换为元组(元素去重) 字典dict 字典简介 python中字典使用的是hash方式保存的 用hash码来决定对象的存放的地址 告诉计算机自定义对象如何判断是否重复，需要重写对象的 __hash__ 和 __eq__ 方法 字典是容器型数据类型(序列); 将{}作为容器的标志,多个元素之间用逗号隔开(元素是键值对): {键1:值1, 键2:值2, ...} 字典是键集合和值集合的一个映射，字典的keys()方法返回的就是一个键视图对象，该对象直接支持集合运算 字典是可变的，无序的 键 - 不可变(一般使用字符串)，唯一 值 - 任何类型的数据都可以，值可以相同 字典查找 获取单个元素 字典[key] - 获取指定key对应的值，如果key不存在会报错 字典.get(key)/字典.get(key, 默认值) - 获取指定key对应的值;如果key不存在不会报错，并且返回默认值(没有默认值返回None) 遍历字典 遍历字典取到的是字典中所有的key #遍历key for key in dict1: print(key) #遍历value for value in dict1.values(): print(value) #同时遍历key和value for k, v in dict1.items(): print(k, v) #枚举key，并编号 for i, k2 in enumerate(dict1): print(i, k2) 字典增、改 字典[key] = 值 - 当key存在，修改key对应的值；当key不存在，添加'key:值'的键值对 字典删除元素 del 字典[key] - 删除字典中指定key对应的键值对 字典.pop(key) - 取出字典中指定key对应的值, 返回值就是被取出的值 字典.clear() - 删除字典中所有的键值对 字典.popitem() - 随机删除字典中的一对键值对 字典比较运算符 字典不支持: +、*、>, =, ； 只支持: ==, != 用 == 或 != 判断时,只判断键值是否相等,与顺序无关 字典的in和not in 键 in 字典 - 判断字典中是否存在指定的键 字典相关函数 len() - 计算字典键值对个数，即键的总数 dict(数据) - 将其他数据转换成字典;数据本身必须是序列，序列中的元素是小序列， 字典转换注意事项 小序列有且只有两个元素，第一个元素不可变 字典不能转换成数字，可以转换成布尔； 字典转列表,将字典中所有的key作为列表元素 字典相关方法 字典.clear() - 清空字典 字典.copy() - 拷贝字典产生一个新的字典(浅拷贝) dict.fromkeys(序列, 值) - 创建一个字典，将序列中的元素作为key，key对应的value都是指定的值 字典.items() - 将字典中所有的键值对都转换成元组作为一个序列的元素 字典.values() - 获取字典中所有的值，返回一个序列 字典.keys() - 获取字典中所有的键，返回一个序列 字典.setdefault(key, value) - 当key不存在的时候添加键值对（不会修改） 字典1.update(字典2) - 将字典2中的键值对添加到字典1中 zip(key, value) - 将key和value序列中的值一一对应生成元组对元素 集合set 集合简介 python中集合的保存使用的是hash方式保存， 用hash码来决定对象的存放的地址， 告诉计算机自定义对象如何判断是否重复，需要重写对象的 __hash__ 和 __eq__ 方法 集合是容器型数据类型；将{}作为容器标志，多个元素用逗号隔开: {元素1, 元素2,...} 集合是可变的、无序的 集合中的元素必须是不可变的数据，而且是唯一(自带去重功能) {} 表示空字典 set5 = set() 表示空集合 class Employee: def __init__(self, name, age, sex, partner): self.name = name self.age = age self.sex = sex self.partner = partner def __hash__(self): return hash('%s%s' % (self.name, self.sex)) def __eq__(self, other): if self.name == other.name and self.sex == other.sex: return True 集合的元素查找 获取集合元素,只有遍历一种方法 for 变量 in 集合: pass 补充: 遍历字典和集合的时候，其实是遍历将字典或者集合转换成的列表 集合的元素增加 集合.add(元素) - 在集合中添加一个元素 集合.update(序列) - 将序列中的元素添加到集合中, 打碎插入 集合的删除 集合.remove(元素) - 删除集合中指定元素 集合的更改 集合不支持该操作 集合的比较运算符 运算符: 支持判断相等的==, != 集合的in和not in 判断集合中是否有该元素 集合的相关方法 len、max、min、sum、sorted、set 集合的数学运算 python中的集合直接支持数学的集合运算: |(并集), &(交集), -(差集), ^(对称差集), >/ 集合1 | 集合2 - 将两个集合合并在一起 集合1 & 集合2 - 获取两个集合的公共部分 集合1 - 集合2 - 获取集合1中除了集合2剩下的部分 集合1 ^ 集合2 - 获取集合1和集合2除了公共部分以外的部分 集合1 > 集合2 - 判断集合1中是否包含集合2（判断集合2是否是集合1的子集） 字符串 字符串简介 字符串是容器型数据类型(序列); 将''或\"\"作为容器的标志,多个字符(元素)直接包含在引号中 字符串是不可变的、有序的 转义字符 在指定的符号或者字母前加\\来表示特殊功能或者特殊意义的字符 注意: 一个转义字符的长度是1 \\' - 表示一个单引号 \\\" - 表示一个双引号 \\\\ - 表示一个\\ \\n - 换行符 \\t - 制表符 %% - 百分号 编码字符 u4位的十六进制数表示一个字符; 数字对应值是字符对应的编码值 字符与编码值的转换 chr(编码值) - 获取编码值对应的字符 ord(字符) - 获取字符对应的编码值 字符串查找 字符串[下标] - 获取单个字符 字符串[开始下标:结束下标:步长] - 字符串切片 直接遍历字符串/通过遍历下标遍历字符串 - 遍历字符串 字符串数学运算符 数学运算符: +, * 字符串1+字符串2 - 将字符串1和字符串2拼接在一起产生一个新的字符串 字符串 * N / N * 字符串 - 字符串重复N次产生一个新的字符串 比较运算符: >, =, 字符串比较大小: 从前往后比较两个字符串中相同位置上的字符的大小，谁的字符的编码值大，对应的字符串就大 'A' - 判断字符是否是大写字母 'a' - 判断字符是否是小写字母 ('A' - 判断字符是否是字母 '\\u4e00' - 判断字符是否是中文字符 '0' - 判断字符是否是数字字符 字符串的in 和 not in 字符串1 in 字符串2 - 判断字符串2中是否包含字符串1(判断字符串1是否是字符串2的子串) 相关函数: len、max、min、sorted、str str(数据) - 将指定数据转换成字符串;(所有数据类型的数据都可以转换成字符串, 转换的时候是直接在数据本身外加引号) 字符串转整型: 字符串去掉引号后本身就是一个整数，才能转换成整型 字符串转浮点型: 字符串去掉引号后本身就是一个数字，就能转换成浮点数 格式化字符串 带有格式占位符的字符串 % (值1, 值2, 值3,...) %s - 字符串 %d - 整型 %.Nf - 浮点型, N表示小数点后小数的位数，采用四舍五入的方式 %c - 字符(可以将字符编码转换成字符拼接到字符串中) name = '小明' message = name + ',你好，吃饭了吗？' age = 18 gender = '男' weight = 50 pay = 7500 message = '%s今年%d岁，性别%s, 体重:%.1fkg, 薪资: %.2f元' % (name, age, gender, weight, pay) 带有{}的格式字符串.format(值1,值2,值3,...) message = '{2}, {0}, {1}, {0}, {1}, {1}, {2}'.format('小明', 10, 'abc') message = '{name}, {age} = {age}, {name}, {gender}'.format(name='张三', age=18, gender='男') message = '{name}, {age} = {age}, {name}, {gender}'.format(**{'name': 'Tom', 'age': 18, 'gender': '男'}) 将f放在前面进行的f-string格式化 格式字符串中约束小数位数的时候采用的时候四舍五入 {:.Nf} - 让数字保留N位小数 name = '小明' age = 18 gender = '男' weight = 50 pay = 7500 message = f'{name}今年{age}岁，性别{gender}, 体重:{weight:.1f}kg, 薪资: {pay:.2f}元' 字符串相关方法 字母大小写转换: 字符串.upper() - 小写字母转大写: 编码值减去32 字符串.lower() - 大写字母转小写: 编码值加上32 字符串.swapcase() - 大小写转换(大变小,小变大) 字符串.capitalize() - 字符串首字母大写 字符串.title() - 字符串每个单词首字母大写 字符串对齐 字符串.center(长度, 字符) - 产生一个指定长度的字符串，原字符串居中，剩下的部分用指定的字符填充 字符串.ljust(长度, 字符) - 产生一个指定长度的字符串，原字符串放在左边，剩下的部分用指定的字符填充 字符串.rjust(长度, 字符) - 产生一个指定长度的字符串，原字符串放在右边，剩下的部分用指定的字符填充 字符串.zfill(长度) - 产生一个指定长度的字符串，原字符串放在右边，剩下的部分用字符0填充 查找 字符串1.find(字符串2, 开始下标, 结束下标) - 在开始下标到结束下标前对应的范围内查找字符串2,默认从头到尾,没有返回-1 rfind - 为从右向左找 字符串1.index(字符串2, 开始下标, 结束下标) - 在开始下标到结束下标前对应的范围内查找字符串2,默认从头到尾,没有的话报错 rindex - 为从右向左找 字符串1.count(字符串2,开始下标,结束下标) - 返回字符串1中字符串2出现的次数，可以指定一个范围，默认从头到尾 join() 字符串1.join(序列) - 将序列中的元素用字符串1连接在一起产生一个新的字符串 (序列中的元素必须都是字符串) 字符串替换 字符串1.replace(old, new) - 将字符串1中所有的old都替换成new,然后产生一个新的字符串 str.maketrans(字符串1,字符串2) - 创建字符串1和字符串2字符一一对应的映射表， 字符串.translate(映射表) - 按照映射表将字符串中的字符串1进行替换为字符串2,产生一个新的字符串 字符串切割 字符串1.split(字符串2) - 将字符串1中的字符串2作为切点，切割字符串1 字符串1.lstrip(字符串2) - 截掉字符串1左侧的字符，默认为空格(去头) 字符串1.rstrip(字符串2) - 截掉字符串1右侧的字符，默认为空格(去尾) 将字符串当作有效的表达式求值并返回结果 eval() - 将字符串当作有效的表达式求值并返回结果，例如 eval('1+2+3') -> 6 其他类型 Boolean(布尔) None(空) 函数 声明 函数名规范: 函数名应该小写，多个单词之间用下划线隔开。 语法: def 函数名(参数列表): ​ 函数说明文档 ​ 函数体 调用 语法: 函数名(实参列表) 调用过程: 回到函数声明的位置 用实参给形参赋值(传参)；传参的时候要保证每个参数都有值 执行函数体 确定函数返回值 回到函数调用的位置，接着往后执行。 参数 参数类型 位置参数: 让实参和形参一一对应，来给不同的形参赋不同的值 ​- 命名关键字参数: 以'参数名1=值1,参数名2=值2,...'的形式来传参 def(a, b, /, c, d, *, e, f): /前面为仅位置参数，*后面为命名关键字参数 参数默认值 - 形参 声明函数的时候，可以给形参赋默认值; 已经有默认值的参数在调用的时候可以不用传参 注意: 没有默认值的参数必须放在有默认值参数的前面 参数类型说明 给参数设置默认值，默认值的类型就是参数的类型 形参:类型名 不定长参数 - 参数个数不确定 在参数名前加*, 那么这个参数就会变成一个元祖去接收多个参数, 调用的时候不能使用关键字参数传参 ​2. 在参数名前加**, 那么这个参数就会变成一个字典去接收多个参数，调用的时候只能使用关键字参数传参 值的改变 传入为string/tuple/number时,不会改变实参的值(非全局变量) 传入为list/dict/set时,函数内改变元素的值会改变实参的元素的值(引用传递) 返回值 return 返回值 return 返回值1,返回值2,返回值3... 没有返回值,返回值就是none 变量的作用域 全局变量: 没有声明在函数里或类里面的变量就是全局变量；作用域:从声明开始到文件(程序)结束任何地方都可以使用 局部变量: 声明在函数中的变量就是局部变量；作用域:从声明开始到函数结束的任何地方都可以使用 global和nonlocal global 和 nonlocal 只能在函数体中使用 global - 在函数中声明/修改全局变量，就在变量赋值前加 global 变量名 nonlocal - 想要在局部的局部中修改局部变量的值，就使用nonlocal 匿名函数 定义: 函数名 = lambda 形参列表:返回值 调用: 函数名(实参列表) 作用: 匿名函数能做到的普通函数都能做，普通函数能做到的匿名函数不一定能做到。 匿名函数在函数功能简单的情况下，代码更简洁 func1 = lambda x, y: x+y sum1 = func1(10, 20) 递归函数 声明函数的时候，调用自己的函数就是递归函数; 循环能做的事情递归都可以做(死循环不行) 怎么写递归函数: 找临界值(让循环结束的条件), 在这儿必须让函数结束(return) 找关系: 找f(n)与f(n-1)的关系(当次循环和上次循环的关系) 假设函数的功能已经实现，通过f(n-1)去实现f(n)的功能 注意： windows下默认最大递归深度为998 （实际测试打印到996） python支持的最大递归深度不超过3925-3929 （实际测试打印到29934） 更改最大递归层数限制方法为: import sys sys.setrecursionlimit(100000) 测试最大递归层数方法： def recursion(n): print(n) recursion(n+1) if __name__ == '__main__': recursion(1) 偏函数 把一个参数固定住，形成一个新的函数 def int2(str, base=2): return int(str, base) 也可以使用from functools import partial后，用partial打造偏函数 from functools import partial import pymysql get_conn = partial( pymysql.connect, host='120.77.222.217', port=3306, user='root', password='123456', charset='utf8' ) 函数作为变量 函数就是变量: python中声明函数其实就是声明一个类型是function的变量，函数名就是变量名。变量能做的函数都能做 变量可以给别的变量赋值 重新给变量赋值 变量作为容器类型数据的元素 变量作为函数的参数 系统实参高阶函数: 列表.sort、sorted、max、min...中有个参数key，类型就是function。 装饰器 装饰器的本质就是函数，是用来给函数添加功能用的 不带参数的装饰器使用时不打圆括号 装饰器 = 实参高阶函数+返回值高阶函数+糖语法 语法: def 函数名1(fn): def 函数名2(*args, **kwargs): 实现添加功能的代码 fn(*args, **kwargs) return 函数名2 说明: 函数名1 - 装饰器的名字（根据添加的功能来命名） fn - 随便命名,类型是函数，指向的需要添加功能的函数 函数名2 - 实现添加功能的函数，名字随便命名，一般为func 在装饰函数前加@wraps(fn)的作用: 不改变使用装饰器原有函数的结构(如__name__, __doc__) 使用了@wraps(fn)的装饰器使用原函数.__wrapped__可以取消装饰器 from functools import wraps def 函数名1(fn): @wraps(fn) def 函数名2(*args, **kwargs): 实现添加功能的代码 fn(*args, **kwargs) return 函数名2 带参数的装饰器(多嵌套一层) def record_time(times=5): def decorator(func): @warps(func) def wrapper(*args, **kwargs): total = 0 for _ in range(times): start = time.time() result = func(*args, **kwargs) end = time.time() total += end-start print(f'执行的平均时间{total/times}') return result return wrapper return decorator 定义类的装饰器 class record_time: def __init__(self, times=5): self.times = times def __call__(self, func): @warps(func) def wrapper(*args, **kwargs): total = 0 for _ in range(times): start = time.time() result = func(*args, **kwargs) end = time.time() total += end-start print(f'执行的平均时间{total/times}') return result return wrapper 装饰类的装饰器: # 创建单例类的装饰器 def singleton(cls): instances = {} lock = RLock() @wraps(cls) def wrapper(*args, **kwargs): # 保证多线程安全 if cls not in instances: with lock: if cls not in instances: instances[cls] = cls(*args, **kwargs) return instances[cls] return wrapper 取消装饰器功能 import re import time from functools import wraps def cal_time(f): @wraps(f) def func(*args, **kwargs): start = time.time() res = f(*args, **kwargs) print(f'{f.__name__} cost time: {time.time() - start}') return res return func @cal_time def search_str(): for item in range(1000000): status = re.search(r'abc', \"12345abc12345\") if __name__ == '__main__': search_str() # 带装饰器 search_str.__wrapped__() # 去掉装饰器 迭代器 迭代器是实现了迭代器协议的对象，迭代协议指的都是包含 __next__ 和 __iter__ 方法的对象 迭代器是容器型数据类型(序列), 迭代器中的元素只能通过将其他序列转换成迭代器或者创建生成器 迭代器中的元素: 如果需要查看元素，需要将元素从迭代器取出，而且一旦取出就不能再放回去 iter(序列) - 创建迭代器，将序列转换成迭代器并返回 isinstance(变量, Iterable) - 判断是否为迭代器 获取元素: next(迭代器) / 迭代器.__next__() - 获取单个元素 for item in 迭代器 - 遍历迭代器 list(迭代器) – 将迭代器元素转换为列表 生成器 生成器就是迭代器，容器有产生数据的能力。 怎么创建生成器: 调用一个带有yield关键字的函数，就可以得到一个生成器对象 生成器产生数据的原理: 调用一个带有yield关键字的函数的时候，不会执行函数体，也不会获取返回值,而是创建一个生成器； 生成器能产生多少个数据，以及每个数据的值，看执行完函数体会遇到几次yield生成器就可以产生几个数据， yield后面的数据就是会产生的数据。 每次获取生成器的元素的时候，都会去执行相应的函数的函数体，执行到yield为止； 取下一个元素，从上次结束的位置接着往后执行。 yield 和 yield from的区别 yield from 后面跟的如果是个迭代器，则会解析迭代器，将其中的元素依次产生出来。 yield是一个生成器，如果要变为协程，需要send(None) yield range(5) # range(0, 5) yield from range(5) # [0, 1, 2, 3, 4] def func1(): print('=======') print('+++++++') yield 89 # return print('!!!!!!!!') yield 100 gen1 = func1() print('re:', gen1) print('next:', next(gen1)) print('第一次结束，第二次执行:') print('next:', next(gen1)) 生成式 常规生成式 生成式就是生成器的一种简写 (表达式 for 变量 in 序列) - 序列有多少个元素，生成器就能产生多少个数据。 相当于: def func1(): for 变量 in 序列: yield 表达式 (表达式 for 变量 in 序列 if 条件语句) 相当于: def func1(): for 变量 in 序列: if 条件语句: yield 表达式 生成式变形 列表生成式 [表达式 for 变量 in 序列] 相当于 list((表达式 for 变量 in 序列)) [表达式 for 变量 in 序列 if 条件语句] 集合生成式 {表达式 for 变量 in 序列} 相当于: set((表达式 for 变量 in 序列)) {表达式 for 变量 in 序列 if 条件语句} 生成式转字典 dict(表达式 for 变量 in 序列) 生成器 (x*3 for x in [2, 4, 6, 8]) 高阶函数 map 原型: map(fn，lsd) 参数: fn是函数，lsd是序列 功能: 将传入的函数依次作用在序列中的每一个元素，并把结果作为新的Iterator返回 reduce 使用reduce需要先导入from functools import reduce 原型: reduce(fn, lsd) 参数: fn是函数，lsd是序列 功能: 一个函数作用在序列上，这个函数必须接受两个参数，reduce把结果继续和序列的下一个元素累计运算 filter 原型: filter(fn, lsd) 参数: fn为函数，lsd为序列 功能: 用于过滤序列，把传入的函数依次作用于序列的每个元素，根据返回的是True还是False决定是否保留该元素 sorted 原型: sorted(lsd, key ,reverse=false) 参数: lsd为序列，key接收一个函数，reverse决定升序还是降序,默认升序 文件、json与pickle 文件 打开文件 文件对象 = open(file, mode='r',...,encoding=None,errors=None) - 以指定的方式打开指定文件并且返回文件对象 file - 字符串，本地文件路径，可以是绝对路径也可以是相对路径 绝对路径: 文件在计算机上的全路径 相对路径: 相对当前目录(代码文件所在的目录) ./ - 代表当前目录 ../ - 代表当前目录的上层目录 .../ - 代表当前目录的上层目录的上层目录 mode - 字符串， 读写方式; 决定打开文件后能做什么，以及读写的数据的类型 r - 只读 w - 只写(清空原文件) a - 只写 b - 二进制 t - 文本(字符串) r(rt/tr) - 只读; 读到的数据的类型是字符串 rb/br - 只读; 读到的数据的类型是二进制 w(wt/tw) - 只写; 写入文件中的数据的类型是字符串; 打开后会清空原文件中的内容 wb/bw - 只写; 写入文件中的数据的类型是二进制; 打开后会清空原文件中的内容 a(at/ta) - 只写; 写入文件中的数据的类型是字符串 ab/ba - 只写; 写入文件中的数据的类型是二进制 errors - 错误处理 ignore - 忽略错误 注意 b 和 t 中必须有一个，如果不写就是 t encoding - 字符串， 文本文件的编码方式; 一般使用'utf-8'; 二进制数据不能设置encoding（mode带b都不能设置） 同一个文件读写时的编码方式必须一致 关闭文件 文件对象.close() - 关闭指定文件; 文件关闭后不能再进行读写操作 打开不存在的文件 如果以读的形式打开一个不存在的文件，程序会报错: FileNotFoundError; 如果以写的形式打开一个不存在的文件，程序不会报错，而且会自动创建这个文件再打开。 文件作用域 只有在文件作用域范围内才能操作文件; 离开文件作用域，文件会被自动关闭 with open(file, mode='r',...,encoding=None,...) as 文件对象: ​ 文件作用域 操作文件 读操作 - 获取文件中的内容 文件对象.read() - 获取指定文件对象中内容(从文件读写位置开始到文件结束),并且返回,可以读所有文件,括号中写一个数字表示一次读入多少字节的内容 文件对象.readline() - 读一行内容(从文件读写位置到一行结束),并且返回,只能读文本文件 文件对象.readlines() - 读取所有行并返回一个列表 写操作 - 修改文件中的内容 文件对象.write(数据) - 将指定数据写入指定文件; 数据只能是结果是字符串的数据或者是二进制数据 文件对象.flush() - 刷新缓冲区,write实际是将文件写入缓冲区,等待缓冲区自动刷新写入,flush主动刷新立即写入 eval函数 eval(字符串) - 将字符串转换成列表或者字典; 字符串必须是去掉引号后本身就是一个列表或者字典 json数据 什么是json json是一种数据格式; 一个json有且只能有一个数据；这一个数据必须是json支持的数据类型的数据。 json支持的格式 数字类型 - 包含所有的数字,小数中支持科学计数法。例如: 89, 12.89, -890, 3e4 字符串 - 使用双引号引号来的数据。\"hello\", \"1234\", \"abc\\n232\" 布尔 - 只有true和false两个值 空值 - null 数组 - 相当于python中的列表, [元素1,元素2,元素3,...] 字典 - 相当于python中的字典, {key1:value1, key2: value2,...} key只能是字符串 json转python json.loads(数据) - 将json数据转换成python数据。 数据必须是字符串；字符串中的内容必须是json格式的数据 json python 数字 int/float 字符串 str; 可能会将双引号变成单引号 布尔 bool; true -> True, false -> False 空值 null -> None 数组 list 字典 dict python转json json.dumps(数据) - 将python数据转换成json格式的字符串 python json int/float 数字 bool 布尔; True -> true; False -> false str 字符串； 单引号都会变成双引号 None None -> null list,tuple 数组 dict 字典 读写本地json json.load(f) - 读本地json json.dump(data, f) - 写本地json Pickle 使用前需要先导入import pickle pickle转python pickle.loads(bytes_object) - bytes_object为二进制对象，返回二进制对象所封装的内容 python转pickle pickle.dumps(obj) - obj为要转为pickle二进制的对象，返回已封装后的二进制数据 读写本地pickle 注意: file必须以二进制可写入模式打开 pickle.load(file,*,fix_imports=True, encoding=\"ASCII\", errors=\"strict\") - file为要读取的文件，*后面的都为关键字参数 pickle.dump(obj, file, protocol=None,) - obj为要写入文件的对象，file为写入到哪个文件，protocol为协议，python3默认支持协议3 异常与测试 捕获所有异常 try: 正常执行的代码 except: 遇到错误的代码 else: 没有出现错误执行 finally: 无论有没有错误都执行 其他语句 捕获指定异常 try: 正常执行的代码 except 异常类型: 遇到指定错误的代码 finally: 无论有没有错误都执行 其他语句 同时捕获指定的多种异常 try: 正常执行的代码 except(异常类型1,异常类型2,...): 遇到指定错误的代码 finally: 无论有没有错误都执行 try: 正常执行的代码 except 异常类型1: 遇到异常1执行的代码 except 异常类型2: 遇到异常2执行的代码 ... finally: 无论有没有错误都执行 finally 以上所有的语法结构的最后都可以加一个finally, 加完后不会影响原结构的功能。 try后面的代码块不管发生什么情况，finally后面的代码块都会执行 断言 出错后会将后面的内容提示出来 def func(num, div): assert(div != 0), 'div不能为零' return num/div print(func(10, 0)) # 结果:AssertionError: div 不能为零 异常抛出 raise 异常类型 自定义异常 class AgeError(Exception): def __str__(self): return '年龄的值应该在0~200之间' raise AgeError 对函数进行测试 使用前需要先导入import unittest import unittest from 对函数进行单元测试 import mySum from 对函数进行单元测试 import mySub class Test(unittest.TestCase): @classmethod def setUpClass(cls): print('所有测试开始前自动调用') @classmethod def tearDownClass(cls): print('所有测试结束后自动调用') def setUp(self): print('每个测试开始时自动调用') def tearDown(self): print('每个测试结束时自动调用') # 为了测试mySum # 在函数名前加test_ def test_mySum(self): self.assertEqual(mySum(1, 2), 3, '加法有误') def test_mySub(self): self.assertEqual(mySub(2, 1), 1, '减法有误') if __name__ == '__main__': # 开始测试 unittest.main() # 或者使用命令行 # python -m unittest 测试文件名 对类进行测试 import unittest from person import Person class Test(unittest.TestCase): def test_init(self): p = Person('stolen', 20) self.assertEqual(p.name, 'stolen', '属性赋值有误') def test_getAge(self): p = Person('stolen', 22) self.assertEqual(p.getAge(), p.age, 'getAge函数有误') if __name__ == '__main__': # 开始测试 unittest.main() 对文档进行测试 使用前先导入import doctest 对文档进行测试必须严格按照命令行格式书写 import doctest # doctest模块可以提取注释中的代码执行 def mySum(x, y): ''' get The Sum from x and y :param x: first num :param y: second num :return: sum example >>> mySum(1,2) 3 ''' return x + y print(mySum(1, 3)) # 进行文档测试 doctest.testmod() pytest 使用前安装pip install pytest 可以使用命令行执行 pytest 后自动查找测试文件 -v 显示详情 模块和包 什么是模块 python中一个py文件就是一个模块, 模块名就是py文件的文件名 模块的引用方式 import 模块名 - 导入指定的模块，导入后可以在当前模块中使用指定模块中所有的全局变量。以 '模块名.变量名'的方式去使用 from 模块名 import 变量名1,变量名2,变量名3,... - 导入指定的模块，导入后可以在当前模块中使用指定的全局变量。变量直接使用，不用加前缀 from 模块名 import * - 导入指定的模块，导入后可以在当前模块中使用指定模块中所有的全局变量。变量直接使用，不用加前缀 import 模块名 as 新模块名 - 导入指定模块，导入到给模块重新命名；在当前模块中应使用新的模块名 from 模块名 import 变量名1 as 新变量名1,变量名2, 变量名3 as 新变量名3,... 模块的引用原理 当我们通过import或者from-import去导入一个模块的时候，会将这个模块中的代码全部执行一遍 怎么导入模块的时候选择性的执行部分代码 #代码段1 - 在被导入的时候会被执行的代码 if __name__ == '__main__': #代码段2 - 在被导入的时候不会执行的代码，但是在当前模块直接执行又会被执行 原理: 当创建模块的时候每个模块中都有一个__name__属性，用来保存当前模块的模块名。它的值默认就是py文件的文件名。当直接运行这个模块的时候，模块中的__name__属性会临时变成__main__ 包的介绍 python中包就是拥有__init__.py文件的文件夹 包的使用 import 包名 - 需要在__init__.py中通过'包名.模块名'的方式导入包中相应的模块 import 包.模块 [as 新名字] from 包 import 模块1, 模块2,... from 包.模块 import 变量1,变量2,.... hashlib/base64/百分号编码 什么是hashlib 使用hashlib首先要导入import hashlib hashlib是python提供用来产生摘要算法的模块。摘要算法又叫哈希算法、离散算法。例如: md5、sha相关算法。 该算法不可逆（根据摘要(密文)不能获取/推导出原文） 使用相同算法对相同的数据加密后的结果是一样的 不同长度的数据通过相同的算法加密后的密文的长度是一样的 生成摘要(加密) 哈希对象 = hashlib.算法名() - 根据算法创建hash对象 哈希对象.update(数据) - 指定加密数据，数据必须是二进制数据 哈希对象.hexdigest() - 获取以16进制形式表示的密文(摘要), 数据类型是字符串 import hashlib hash1 = hashlib.md5() hash1.update(password.encode()) pw = hash1.hexdigest() print(pw) base64原理 将原来数据用二进制表示出来，然后六位六位的取，用1-9a-zA-Z+/来表示， base64方法 base64.b64encode() - 将二进制数据转换为base64编码 base64.b64decode() - 将base64编码数据转换为二进制 百分号编码 url中不允许出现非ascii码的字符，故需要进行百分号转换处理 使用前需要先导入from urllib.parse import unquote, quote quote() - 将字符转换为百分号编码 unquote() - 将百分号编码转换为字符 OS模块 使用os模块首先要导入import os os.system() - 执行操作系统命令 os.name - 获取操作系统类型,nt->Windows posix-> Linux、Unix或Mac OS os.uname - 在非Windows系统中打印详细内容 os.environ - 获取操作系统中所有的环境变量 os.environ.get('PATH') - 获取指定环境变量 os.curdir - 获取当前目录 os.getcwd() - 获取当前工作目录，即当前python脚本所在目录 os.listdir() - 以列表形式返回指定目录下的所有文件 os.mkdir('目录名') - 在当前目录下创建新目录 os.rmdir('目录名') - 在当前目录下删除目录 os.stat('文件名') - 获取文件属性 os.rename('旧名字', '新名字') - 重命名 os.remove('文件名') - 删除普通文件 os.system('命令') - 运行shell命令 os.path.abspath('.') - 查当前的绝对路径 os.path.join(path1, path2) - 拼接路径 os.path.split(path) - 拆分路径(返回元组,第一个元素为路径,第二个元素为文件名) os.path.splitext(path) - 拆分扩展名 os.path.isdir(path) - 判断是否是目录 os.path.isfile(path) - 判断文件是否存在 os.path.exists(path) - 判断目录是否存在 os.path.getsize() - 获得文件大小(字节) os.path.dirname() - 获得文件目录 os.path.basename() - 获得文件名 时间与日期 time 使用time需要先导入import time 时间戳 1970年1月1日零时开始算起,以秒为单位 元组表示法 一种python的数据格式表示，这个元组有9个整型内容 year month day hours minutes seconds weekday Julia_day flag(1 或 -1 或0) 格式化时间字符串 %a - 本地（local）简化星期名称 %A - 本地完整星期名称 %b - 本地简化月份 %B - 本地完整月份名称 %c - 本地相应的日期和时间表示 %d - 一个月中的第几天（01-31） %f - 当前时间的微秒 %H - 一天中的第几小时（24小时制，00-23） %I - 第几个小时（12小时制，01-12） %j - 一年中的第几天（001-366） %m - 月份（01-12） %M - 分钟数（00-59） %p - 本地am或者pm的相应符 %S - 秒（01-61） %U - 一年中的星期数。（00-53，星期天是一个星期的开始）第一个星期天之前的所有天数都放在第0周 %w - 一个星期中的第几天（0-6,0是星期天） %W - 和U基本相同，W是以星期一为开始 %x - 本地相应日期 %X - 本地相应时间 %y - 去掉实际的年份（00-99） %Y - 完整的年份 %Z - 时区的名字（如果不存在为空字符） %% - ‘%’字符 时间方法 time.time() - 返回当前时间戳,浮点数形式,不需要参数, time.gmtime(c) - 将时间c转为UTC时间元组 time.localtime(c) - 将时间戳c转为本地时间元组 time.mktime(b) - 将本地时间b转换为时间戳 time.asctime(b) - 将时间元组b转换为字符串 time.ctime(c) - 将时间戳c转换为本地时间字符串,相当于time.asctime(time.localtime(time.time())) time.strftime('%Y-%m-%d %H:%M:%S', b) - 将时间元组转换成给格式的字符串,参数2为时间元组，如果没有参数2，默认转当前时间 time.strptime(q, '%Y-%m-%d %H:%M:%S') - 将时间字符串转换为时间元组 time.sleep(时间) - 延迟一个时间,整型或者浮点型 time.clock() - 返回当前程序的cpu执行时间,Unix系统始终返回全部的运行时间, Windows从第二次开始，都是以第一次调用此函数的开始时间戳作为基数 y1 = time.clock() print(y1) time.sleep(1) y2 = time.clock() print(y2) datatime 使用前需要先导入import datetime 基于time封装 有五个类: datetime - 同时有时间和日期 timedelta - 主要用于计算时间跨度 tzinfo - 时区相关 time - 只关注时间 date - 只关注日期 常用方法 datetime.datetime.now() - 获取当前时间 datetime.datetime(1996, 5, 18, 17, 0, 0, 123456) - 获取指定时间 时间.strftime('%Y-%m-%d %X') - 将时间转换为字符串 datetime.datetime.strptime(时间字符串, '%Y-%m-%d %X') - 格式化字符串转化为datetime对象(格式要与转换为字符串时一致) 时间计算 d5 = datetime.datetime(1996, 5, 18, 17, 0, 0, 123456) d6 = datetime.datetime.now() d7 = d6 - d5 print(d7) # 获取间隔的天数 print(d7.days) # 间隔天数之外的秒数 print(d7.seconds) calendar 使用前需要先导入import calendar calendar.month(2019, 4) - 返回指定某年某月的日历 calendar.calendar(2019) - 返回指定年的日历 calendar.isleap(2000) - 闰年返回Ture，否则返回False calendar.monthrange(2019, 12) - 返回某个月的weekday的第一天和这个月所有的天数 calendar.monthcalendar(2019, 4) - 返回某个月以每一周为元素的列表 Tkinter 使用前需要先导入import tkinter 使用结构 # 创建主窗口 win = tkinter.Tk() # 设置标题 win.title('标题内容') # 设置大小和位置 win.grometry('400x400+200+200') # 设置不可改变窗口大小 win.resizable(0,0) # 退出 win.quit() # 刷新页面 win.update_idletasks() win.update() Label控件 显示文本控件 Label属性 text - 显示的文本内容，可以使用'\\n'表示换行 bg - 背景色 fg - 字体颜色 font - 设置字体颜色和大小 width - 设置控件的宽 height - 设置控件的高 wraplength - 指定text文本中多宽进行换行 justify - 设置换行对齐方式 anchor - 文本在Label中的位置 n北 e东 s南 w西 center - 居中 background(bg) - 背景色 foreground(fg) - 前景色 borderwidth(bd) - 边框宽度 bitmap - 标签中的位图 image - 标签中的图片 textvariable - 显示文本自动更新，与StringVar等配合着用 Button控件 按钮控件 anchor - 指定按钮上文本的位置 background(bg) - 指定按钮的背景色 bitmap - 指定按钮上显示的位图 borderwidth(bd) - 指定按钮边框的宽度 command - 指定按钮消息的回调函数 cursor - 指定鼠标移动到按钮上的指针样式 font - 指定按钮上文本的字体 foreground(fg) - 指定按钮的前景色 height - 指定按钮的高度 image - 指定按钮上显示的图片 state - 指定按钮的状态（disabled） text - 指定按钮上显示的文本 width - 指定按钮的宽度 padx - 设置文本与按钮边框x的距离，还有pady activeforeground - 按下时前景色 textvariable - 可变文本，与StringVar等配合着用 Entry控件 输入控件 show='*' - 密文显示 e = tkinter.Variable() entry = tkinter.Entry(win, textvariable=e) # e就代表输入框这个对象 # 设置值 e.set('陈倔强好帅') # 取值 print(e.get()) # 用控件的对象只能用get,不能用set # entry.set('123') # 报错 print(entry.get()) Text控件 文本控件: 显示多行文本 background(bg) - 文本框背景色 foreground(fg) - 前景色 selectbackground - 选定文本背景色 selectforeground - 选定文本前景色 borderwidth(bd) - 文本框边框宽度 font - 字体 show - 文本框显示的字符，若为*，表示文本框为密码框 state - 状态 width - 文本框宽度 textvariable - 可变文本，与StringVar等配合着用 height - 表示显示的行数 拥有insert方法,进行文本插入 text = tkinter.Text(win, width=30, height=3) text.pack() str = '羊皮卷之七我要笑遍世界。只有人类才会笑。树木受伤时也会流“血”，禽兽也会 因痛苦和饥饿而哭嚎哀鸣，然而，只有我才具备笑的天赋，可以随时开怀大笑。从今往后，我要培养笑的习惯。笑有助于消化，笑能减轻压力，笑，是长寿的秘方。' text.insert(tkinter.INSERT, str) Scrollbar控件 滚动条: 需要进行双向关联才有效 scroll = tkinter.Scrollbar() text = tkinter.Text(win, width=50, height=7) # side 放到窗体的哪一册, fill填充Y轴 scroll.pack(side=tkinter.RIGHT, fill=tkinter.Y) text.pack(side=tkinter.LEFT, fill=tkinter.Y) # 关联 scroll.config(command=text.yview) text.config(yscrollcommand=scroll.set) Checkbutton 多选框: 需要绑定tkinter变量,判断是否选中用变量.get()方式,返回True为选中,返回False为未选中 anchor - 文本位置 background(bg) - 背景色 foreground(fg) - 前景色 borderwidth - 边框宽度 width - 组件的宽度 height - 组件高度 bitmap - 组件中的位图 image - 组件中的图片 font - 字体 justify - 组件中多行文本的对齐方式 text - 指定组件的文本 value - 指定组件被选中中关联变量的值 variable - 指定组件所关联的变量 indicatoron - 特殊控制参数，当为0时，组件会被绘制成按钮形式 textvariable - 可变文本显示，与StringVar等配合着用 def updata(): message = '' if hobby1.get() == True: message += 'money\\n' # 清空text中的所有内容 text.delete(0.0, tkinter.END) text.insert(tkinter.INSERT, message) # 要绑定的变量 hobby1 = tkinter.BooleanVar() # 多选框 check1 = tkinter.Checkbutton(win, text='money', variable=hobby1, command=updata) check1.pack() Radiobutton 单选框: 一组单选框需要绑定同一个变量 获取值可以使用值的方式进行 def updata(): print(r.get()) # 一组单选框要绑定同一个变量 r = tkinter.IntVar() radio1 = tkinter.Radiobutton(win, text='one', value=1, variable=r, command=updata) radio2 = tkinter.Radiobutton(win, text='two', value=2, variable=r, command=updata) Listbox 列表框 selectmode: tkinter.BORWER - 支持鼠标按下选中元素 tkinter.SINGLE - 不支持鼠标按下选中元素 tkinter.EXTENDED - 支持shift和control选中 tkinter.MULTIPLE - 支持多选 listvariable - 绑定变量 控件对象.insert(标志,元素) - 向列表中插入元素 标志: tkinter.END - 在最后插入 tkinter.ACTIVE - 在开始添加 控件对象.delete(参数1,参数2) - 删除参数1为开始,参数2为结束的索引，如果不指定参数2，只删除第一个索引内容。 控件对象.select_set(参数1,参数2) - 选中参数1为开始,参数2为结束的索引，如果不指定参数2，只选中第一个索引内容。 控件对象.select_clear(参数1,参数2) - 取消选中 控件对象.size() - 获取列表中元素的个数 控件对象.get(参数1, 参数2) - 获取索引的元素 控件对象,curselection() - 返回当前的索引项下标 控件对象.selection_includes(选项) - 判断此索引项是否被选中 namelist = tkinter.Variable lb = tkinter.Listbox(win, selectmode=tkinter.BROWSE, listvariable=namelist,) lb.pack() for item in ['good', 'nice', 'handsonme']: lb.insert(tkinter.END, item) Scale 滑动条 tkinter.HORIZONTAL - 水平 tkinter.VERTICAL - 竖直 length - 水平时表示宽度，竖直时表示高度 tickinterval - 选择值将为该值的倍数 scale = tkinter.Scale(win, from_=0, to=100, orient=tkinter.HORIZONTAL, tickinterval=100, length=200) scale.pack() # 获取值 print(scale.get()) # 设置初始值 scale.set(20) Spinbox 数值范围控件 increment - 步长， 默认为1 value - 最好不要与from_=0,to=100，increment=1同时使用。使用元组value=(0, 2, 4, 6, 8) command - 只要值改变就会执行对应的方法 v = tkinter.StringVar() def func(): print(v.get()) sp = tkinter.Spinbox(win, from_=0, to=100, textvariable=v, command=func) v.set(20) Menu 顶层菜单 参数: tearoff - 分窗，0为在原窗，1为点击分为两个窗口 bg, fg - 背景，前景 borderwidth - 边框宽度 font - 字体 activebackgound - 点击时背景，同样有activeforeground，activeborderwidth，disabledforeground cursor postcommand selectcolor - 选中时背景 takefocus title type relief 方法: menu.add_cascade - 添加子选项 menu.add_command - 添加命令（label参数为显示内容） menu.add_separator - 添加分隔线 menu.add_checkbutton - 添加确认按钮 delete - 删除 # 菜单条 menubar = tkinter.Menu(win) # 显示顶层菜单 win.config(menu=menubar) # 创建一个菜单选项 menu1 = tkinter.Menu(menubar, tearoff=False) # 给菜单选项添加内容 for item in ['Python', 'C', 'Java', 'C++', 'Shell', 'Matlab', 'Html', 'exit']: if item == 'exit': # 添加分割线 menu1.add_separator() menu1.add_command(label=item, command=win.quit) else: menu1.add_command(label=item) # 向菜单条上添加菜单选项 menubar.add_cascade(label='编程语言', menu=menu1) 右键菜单 menubar = tkinter.Menu(win) # win.config(menu=menubar) # 菜单 menu = tkinter.Menu(menubar, tearoff=False) for item in ['Python', 'C', 'Java', 'C++', 'Shell', 'Matlab', 'Html', 'exit']: menu.add_command(label=item) menubar.add_cascade(label='编程语言', menu=menu) def shouMenu(event): menubar.post(event.x_root, event.y_root) # 绑定右键事件（1、左键，2、滚轮，3、右键） win.bind('', shouMenu) Combobox 下拉控件 # 绑定变量 cv = tkinter.StringVar() com = ttk.Combobox(win, textvariable=cv) com.pack() # 设置下拉数据 com['value'] = ('黑龙江', '吉林', '辽宁') # 设置默认值 com.current(2) def func(event): print('stolen is a good man') # 获取变量值 print(com.get()) print(cv.get()) # 绑定事件 com.bind('>', func) Frame 框架控件 类似html的div,主要进行布局 ttk.Treeview 使用需要先导入from tkinter import ttk 表格数据 tree = ttk.Treeview(win) tree.pack() # 定义列 tree['columns'] = ('姓名', '年龄', '身高', '体重') # 设置列，列还不显示 tree.column('姓名', width=100) tree.column('年龄', width=100) tree.column('身高', width=100) tree.column('体重', width=100) # 设置表头 前面名称要和定义一样 tree.heading('姓名', text='姓名-name') tree.heading('年龄', text='年龄-age') tree.heading('身高', text='身高-height') tree.heading('体重', text='体重-weight') # 添加数据 tree.insert('', 0, text='line1', value=('哒哒', '20', '173', '120')) tree.insert('', 1, text='line2', value=('哒哒2', '202', '1732', '1202')) tree.insert('', 2, text='line3', value=('哒哒3', '203', '1733', '1203')) tree.insert('', 3, text='line4', value=('哒哒4', '204', '1734', '1204')) tree.insert('', 4, text='line5', value=('哒哒5', '205', '1735', '1205')) 树状数据 tree = ttk.Treeview(win) tree.pack() # 添加一级树枝 treeF1 = tree.insert('', 0, '中国', text='China', values=('F1')) treeF2 = tree.insert('', 1, '美国', text='American', values=('F2')) treeF3 = tree.insert('', 2, '英国', text='English', values=('F3')) # 添加二级树枝 treeF1_1 = tree.insert(treeF1, 0, '黑龙江', text='中国黑龙江', values=('F1_1')) treeF1_2 = tree.insert(treeF1, 1, '吉林', text='中国吉林', values=('F1_2')) treeF1_3 = tree.insert(treeF1, 2, '辽林', text='中国辽林', values=('F1_3')) treeF2_1 = tree.insert(treeF2, 0, '纽约', text='美国纽约', values=('F2_1')) treeF2_2 = tree.insert(treeF2, 1, '旧金山', text='美国旧金山', values=('F2_2')) treeF2_3 = tree.insert(treeF2, 2, '拉斯维加斯', text='美国拉斯维加斯', values=('F2_3')) 布局 place 绝对布局 label1 = tkinter.Label(win, text='good', bg='red') # x为距离左边框的距离, y为距离上边框的距离 label1.place(x=10, y=10) anchor - 组件对其方式 x - 组件左上角的x坐标 y - 组件左上角的y坐标 relx - 组件相对于窗口的x坐标，为0-1之间的小数 rely - 组件相对于窗口的y坐标，为0-1之间的小数 width - 组件的宽度 height - 组件的高度 relwidth - 组件相对于窗口的宽度，为0-1之间的小数 relheight - 组件相对于窗口的高度，为0-1之间的小数 pack 相对布局 after -将组件置于其他组件之后 before -将组件置于其他组件之前 fill - 填充方式 tkinter.X - 水平填充 tkinter.Y - 垂直填充 tkinter.BOTH - 水平和竖直方向填充 tkinter.NONE - 不填充 side - 停靠在窗口的哪个位置 tkinter.LEFT - 左 tkinter.RIGHT - 右 tkinter.TOP - 上 tkinter.BOTTON - 下 expand - 是否扩展 tkinter.YES - 扩展整个空白区域 no - 不扩展 anchor - 位置 N - 北 上 E - 东 右 S - 南 下 W - 西 左 label1 = tkinter.Label(win, text='good', bg='red') label1.pack(fill=tkinter.Y, side=tkinter.LEFT) grid - 表格布局 row - 第几行 column - 第几列 rowspan - 跨几行 columnspan - 跨几列 label1 = tkinter.Label(win, text='good', bg='red') label1.grid(row=0, column=0) 事件绑定 控件名.bind(事件名,事件函数) 控件焦点设置: 控件名.focus_set() 鼠标点击事件 - 鼠标左键 - 鼠标中键 - 鼠标右键 - 鼠标左键 - 鼠标中键 - 鼠标右键 - 双击鼠标左键 - 双击鼠标中键 - 双击鼠标右键 - 三击鼠标左键 - 三击鼠标中键 - 三击鼠标右键 鼠标移动事件 - 左键移动 - 中键移动 - 右键移动 鼠标释放事件 - 鼠标左键释放 - 鼠标中键释放 - 鼠标右键释放 鼠标进入与离开事件 - 鼠标光标进入控件时触发 - 鼠标光标离开空间时触发 按键事件 - 响应所有键盘按键事件 - 按下A键，A可用其他键替代 - 同时按下alt和A，alt可用ctrl和shift替代 - 快速按两下A Lock-KeyPress-A - 大写状态下按A 特殊按键事件 - 左Shift - 右Shift - F5按键 - 回车 - 退格 - 滚动滚轮 窗口事件 Activate - 当组件由不可用转为可用时触发 Configure - 当组件大小改变时触发 Deactivate - 当组件由可用转变为不可用时触发 Destroy - 当组件被销毁时触发 Expose - 当组件从被遮挡状态中暴露出来时触发 Unmap - 当组件由显示状态变为隐藏状态时触发 Map - 当组件由隐藏状态变为显示状态时触发 FocusIn - 当组件获得焦点时触发 FocusOut - 当组件失去焦点时触发 Property - 当窗体的属性被删除或改变时触发 Visibility - 当组件变为可视状态时触发 响应事件 event对象(def function(event)): char - 按键字符，仅对键盘事件有效 keycode - 按键名，仅对键盘事件有效 keysym - 按键编码，仅对键盘事件有效 num - 鼠标按键，仅对鼠标事件有效 type - 所触发的事件类型 widget - 引起事件的组件 width,heigh - 组件改变后的大小，仅Configure有效 x,y - 鼠标当前位置，相对于窗口 x_root,y_root - 鼠标当前位置，相对于整个屏幕 弹窗 messagebox._show函数的控制参数： default - 指定消息框按钮 icon - 指定消息框图标 message - 指定消息框所显示的消息 parent - 指定消息框的父组件 title - 标题 type - 类型 simpledialog模块参数： title - 指定对话框的标题 prompt - 显示的文字 initialvalue - 指定输入框的初始值 filedialog - 模块参数 filetype - 指定文件类型 initialdir - 指定默认目录 initialfile - 指定默认文件 title - 指定对话框标题 colorchooser模块参数： initialcolor - 指定初始化颜色 title - 指定对话框标题 类和对象 什么是类和对象 类是拥有相同功能和相同属性的对象的集合 - 类是抽象 对象是类的实例 - 对象是具体的 类的声明和使用 类的声明 class 类名(object,metaclass=type): 类的说明文档 类的内容 class - 关键字，固定写法 类名 - 程序员自己命名，必须是标识符，不能是关键字，见名知义，驼峰式命名并且首字母大写，不同使用系统提供的函数名、模块名或类名 metaclass - 指定元类 类的说明文档 - 注释，主要说明类中提供的功能有哪些 类的内容 - 包含类中的函数(方法)和属性 方法: 对象方法、类方法和静态方法 属性: 类的字段和对象属性 创建对象 对象 = 类名(初始化参数) - 创建指定类对应的对象 类的方法 对象方法 怎么声明: 直接声明在类中 怎么调用: 用对象来调用 特点: 自带参数self。self在调用的时候不用传参，系统会自动将当前对象传给它 什么时候用: (实现函数功能需要对象) 实现函数的功能需要用到对象属性就使用对象方法 类方法 怎么声明: 在装饰器@classmethod后面声明函数(声明前加@classmethod) 怎么调用: 用类来调用 特点: 有默认参数cls。cls在调用的时候不用传参，系统会自动将当前类传给它。（类能做的cls都可以做） 什么时候用: (实现函数功能不需要对象的前提下，需要类) 静态方法 怎么声明: 声明前加@staticmethod 怎么调用: 用类来调用 特点: 没有默认参数 什么时候用: (实现函数的功能既不需要类也不需要对象) 类的属性 类的字段 直接声明在类的里面函数的外面的变量就是类的字段 怎么声明: 直接声明在类中 怎么使用: 通过类来使用: 以'类.字段'的形式使用 什么时候用: 保存的属性值不会因为对象不同而不一样的时候使用 对象属性 怎么声明: 声明在init方法中, 以'self.属性 = 值'的形式声明 怎么使用: 通过对象来使用: 以'对象.属性'的形式使用 什么时候用: 属性值会因为对象不同而不一样的属性就声明成对象属性 构造方法和__init__方法 构造方法 构造方法是一种特殊的方法，它是一个与类同名且返回值类型为同名类类型的方法。对象的创建就是通过构造方法来完成 构造方法就是用来创建对象函数；构造方法的名字和类名一样的。 python中的构造方法: 当声明类的时候，系统会自动创建一个函数名和类名同名的构造方法。 当通过对象方法创建对象的时候，会自动调用__init__方法来对对象进行初始化操作 __init__方法 __init__是类中一个特殊的对象方法；这个方法不需要主动调用, 用来对对象进行初始化 构造方法调用__init__方法 通过构造方法创建对象的时候，类中__init__会被自动调用 类中的__init__方法可以写也可以不用写，如果写函数名和参数self不能动，但是可以随意添加其他参数 如果__init__方法中有除了self以外的参数，那么创建对象的时候需要在构造方法中给这些参数传参 对象属性的增删改查 获取对象属性的值 对象.属性 - 获取指定对象指定属性的值， 属性不存在会报错 getattr(对象, 属性名) - 获取指定对象指定属性的值，属性不存在会报错 getattr(对象, 属性名, 默认值) - 获取指定对象指定属性的值，属性不存在的时候不会报错而是返回指定的默认值 对象属性的增改 对象.属性 = 值 - 当属性存在的时候，修改指定属性的值；当属性不存在的时候，给对象添加属性 setattr(对象, 属性名, 值) - 当属性存在的时候，修改指定属性的值；当属性不存在的时候，给对象添加属性 删除对象属性 del 对象.属性 - 删除对象中指定的属性 delattr(对象, 属性名) - 删除对象中指定的属性 类的魔术方法 类.__name__ - 获取当前类的类名 类.__doc__ - 获取类的说明文档 对象.__class__ - 获取指定对象对应的类（和type的功能一样） 类.__dict__ - 获取指定类中所有的字段和对应的值，以字典的形式返回 对象.__dict__ - 获取对象所有的属性和对应的值，以字典的形式返回 类.__module__ - 获取指定类所在的模块的模块名 类.__bases__ - 获取当前类的父类 object - 是基类 __slots__ - 约束当前类的对象能够拥有哪些属性 如果在类中给__slots__赋值: 赋值后，__slots__对应的元组中的元素就是当前类的对象能够拥有的所有属性 如果类中设置了__slots__的值，那么这个类的对象就不能使用__dict__属性 __call__ - 将一个类实例变成一个可调用对象，相当于把这个对象当作函数来使用。也就是实现了 () 运算符，即可调用对象协议 __enter__和__exit__ - 实现上下文语法，就可以使用with语法。如果enter有返回值，可以使用with...as...来接收这个值 私有化 私有化的方式 在需要私有化的属性名或者方法名前加__(双下划线) 私有化的原理: 设置带有__开头的属性名和变量名，系统在保存的时候会自动在前面加_类名,导致直接访问访问不了 getter和setter getter和setter的作用 如果需要在获取属性值之前做别的事情，就给这个属性添加getter 如果需要在给属性赋值之前做别的事情，就给这个属性添加setter 添加getter 在需要添加getter的属性名前加_ 声明一个函数，声明前加@property。 函数名就是不带_的属性名；除了self以外不能有别的参数；需要一个返回值 (需要返回属性的值) 在类的外部使用这个属性的时候去掉_ 添加setter 属性如果要添加setter必须先添加getter 保证属性名前有_ 声明一个函数, 声明前加@getter名.setter 函数名是不带_的属性名; 除了self以外需要一个参数，不需要返回值（需要完成给属性属性的功能） 在类的外部给这个属性赋值的时候去掉_ 继承 继承简介 让一个类直接拥有另一个类的属性和方法，这个过程就叫继承。 父类: 被继承的类，又叫超类 子类: 去继承别的类的类(继承者) 语法: class 类名(父类1,父类2,父类3,...): 类的说明 类的内容 () - 可以省略，相当于(object); object是python中所有类直接或者间接父类,也叫基类 父类 - 有()的时候，括号中可以写一个或者多个父类 __slots__只能约束当前类的对象，对子类没有约束效果 super 类中的函数的调用过程: 当通过类或对象去调用函数的时候，是先看当前类中有没有声明这个函数，如果有就直接调用自己的； 没有就去看父类中有没有，如果父类有就调用父类的； 如果父类中也没有就看父类的父类中有没有,...以此类推 如果找到object都没有声明这个函数，才报错 当调用了子类的__init__,父类的__init__将不再调用,若要继承父类的对象属性需要用: super().__init__() super(object,self).__init__()和super().__init__()效果一样 注意: 静态方法中不能使用super()去调用父类方法 多重继承（多继承，左下原则） 当存在多重继承的时候,按照继承图从左到右,从下到上进行 python中新式类用的广度优先搜索 python中旧式类用的深度优先 重载 函数重载 重载指的是函数名相同，但是参数不一样的多个函数。 python不支持函数的重载 // c语言的函数重载 void func1(){ } void func1(int a){ } void func1(int a, int b){ } void func1(char a, float b){ } func1() func1(10, 20) func1(100) 运算符重载 python中使用不同的运算符对数据进行运算的时候，本质是在调用相应的方法 当不同类型的数据使用相同的运算符的时候，调用的方法的方法名一样，但是方法不同 看某种类型的数据是否支持某种运算符，就看这个类型对应的类中是否实现了相应的方法 self - 运算符前面的那个数据 other - 运算符后面的那个数据 返回值 - 运算结果 比较大小的运算符中，只要重载一个就可以 def __add__(self, other): //重载+ print(self, other) return self.age + other.age 枚举 继承Enum的类就是枚举, 枚举的特点: 不能创建对象 class PokerColor(Enum): \"\"\"牌的花色类\"\"\" Hearts = '♥' Spade = '♠' Club = '♣' Diamonds = '♦' 析构函数 释放对象时自动调用(删除对象的时候调用) class Person: def __del__(self): print('这里是析构函数') per = Person() del per 重写打印函数 __str__(): 在调用print打印对象时自动调用，是给用户的，是一个描述对象的方法 __repr__(): 是给机器的，在Python解释器里面直接敲对象名再回车后调用的方法（黑终端中使用） 注意: 在没有str时，且有repr，str = repr class Person: def __str__(self): return '你好' per = Person() print(per)# 你好 __str__在有多层的时候，无法使用，只能使用__repr__ 动态添加对象方法 动态添加对象方法需要先导入import types import types class Person(object): __slots__ = ('name', 'age') per = Person() def say(self): print('my name is '+ self.name) per.speak = types.MethodType(say, per) per.speak() 上下文实现 要能够使用with，需要在类中定义__entry__和__exit__方法 抽象类 定义: from abc import ABCMeta, abstractmethod # 此类只支持继承，不支持定义类 class Employee(metaclass=ABCMeta): def __init__(self, name): self.name = name @abstractmethod def get_salary(self): # pass可以不写 pass 元类 元类实现单例: from threading import RLock class SingletonMeta(type): def __init__(cls, *args, **kwargs): cls.__instance = None cls.__lock = RLock() def __call__(cls, *args, **kwargs): if not cls.__instance: with cls.__lock: if not cls.__instance: cls.__instance = super().__call__(*args, **kwargs) return cls.__instance 内存管理 内存开辟 内存分为栈区间和堆区间， python中所有的数据都是保存在堆区间的，栈区间中保存存储数据地址的变量。 每次需要一个数据的时候，python自动去开辟相应的空间；原则上只要需要数据就会开辟一个新的空间，哪怕数据和之前的数据是相等的也会重新开辟；但是数字和字符串特殊，每次给数字或者字符串开辟空间前会先检查这个数据在内存是否已经存在，如果存在就直接使用之前存储的数据，不存在才会重新开辟空间 内存释放 python中内存释放采用的是垃圾回收机制,当数据(堆中)的引用计数为0的时候，数据就会被自动销毁(被回收) python中针对数据的循环引用已经做了特殊处理，程序员不用再写额外的代码去处理循环应用处理循环引用的方法为标记清除和分代回收 引用计数 当一个对象的引用被创建或者复制时，对象的引用计数加1 当一个对象的引用被销毁时，对象的引用计数减1 当一个对象的引用计数为0时，对象就会被销毁，释放内存 优点 简单直观 实时性，只要没有了引用就释放资源 缺点 维护引用计数需要消耗一定的资源 循环引用时，无法回收，解决办法是使用标记清除和分代回收 查看引用计数方法getrefcount() 标记清除 标记清除不改动真实的引用计数，而是将集合中对象的引用计数复制一份副本，改动该对象引用的副本，对于副本做任何的改动，都不会影响对象生命周期的维护 分代回收 将系统中所有的内存块根据其存活的时间划分为不同的集合，每一个集合就称为一个代，垃圾收集频率随着代的存活时间的增大而减小，也就是说，活得越长的对象，越不可能是垃圾，就应该减少对它进行垃圾回收的频率。通常使用几次垃圾回收的动作来衡量存活时间，经过垃圾回收的次数越多，意味着存活的时间越长 栈与队列 栈 先进后出,如列表 stack = [] # 压栈(存数据) stack.append('a') stack.append('b') stack.append('c') # 出栈(取数据) res = stack.pop()#c res2 = stack.pop()#b res3 = stack.pop()#a 队列 使用队列需要先导入import collections 通常用作目录遍历 import collections # 创建队列 queue = collections.deque() # 进队 queue.append('a') queue.append('b') queue.append('c') # 出队 res1 = queue.popleft()#a res2 = queue.popleft()#b res3 = queue.popleft()#c 深拷贝和浅拷贝 使用深拷贝和浅拷贝需要先:import copy 浅拷贝 列表切片、列表.copy、字典.copy等都属于前拷贝,copy模块中的copy也是浅拷贝，可以拷贝任何数据 深拷贝 copy模块中的deepcopy是深拷贝 深拷贝和浅拷贝的区别 不管是浅拷贝还是深拷贝，赋值的时候都是先复制原数据产生一个新的数据，然后将新的地址赋给变量。如果拷贝对象中又有子对象(除了数字和字符串以外的数据), 浅拷贝地址原样赋值，不会拷贝子对象; 深拷贝，子对象也会被拷贝 a = [100, 200] list1 = [1, 2, a] list2 = copy.copy(list1) list3 = copy.deepcopy(list1) list1.append('abc') print(list2, list3) # [1, 2, [100, 200]] [1, 2, [100, 200]] 表示均产生了一个新的列表 a.append('1000') print(list2, list3) # [1, 2, [100, 200, '1000']] [1, 2, [100, 200]] 多线程和多进程 多线程 简介 使用多线程需要import threading 默认情况下一个程序中都有一个线程，这个线程叫主线程。主线程以外的线程叫子线程 多线程使用步骤 创建线程对象(需要一个子线程就需要创建一个线程对象) Thread(target,args, name) target - function(函数),需要在子线程中调用的函数 args - 元组, 接收在子线程中调用函数时，函数的实参 name - 给线程取名字 threading.current_thread().name - 获取当前线程的名字 线程对象.start() - 让子线程执行任务(调用target对应的函数) 线程对象.join() - 当线程对象中的任务全部完成后，再执行这条语句后面的其他语句，等待线程对象执行结束 def download(name): print('%s开始下载: %s' % (name, datetime.now())) time.sleep(3) print('%s下载结束: %s' % (name, datetime.now())) # 守护线程，主线程结束，子线程也 就结束 t1 = threading.Thread(target=download, args=('葫芦娃',), deamon=True) t2 = threading.Thread(target=download, args=('猫和老鼠',)) t1.start() t2.start() 线程对象 通过创建Thread的子类对象来创建线程，启动线程就在子线程中自动调用子类中的run方法 import threading import data class DownloadThread(threading.Thread): def __init__(self, name): super().__init__() self.name = name def run(self) -> None: print(threading.current_thread()) print('%s开始下载: %s' % (self.name, datetime.now())) time.sleep(3) print('%s下载结束: %s' % (self.name, datetime.now())) t1 = DownloadThread('葫芦娃') t1.start() 多线程数据安全 # 创建锁 b_lock = threading.Lock() # 加锁 b_lock.acquire() # 释放锁 b_lock.release() from threading import RLock # 重入锁，当加锁内容需要调用另一个要枷锁的内容需要使用 lock = RLock() lock.acquire() 案例 from time import sleep from threading import Thread,Lock class Account: \"\"\"银行账号类\"\"\" def __init__(self, name, tel, password, balance=10): self.num = '728238278238823' self.user_name = name self.tel = tel self.password = password self.balance = balance self.lock = Lock() def save_money(self, num): print('存%s元钱' % num) self.lock.acquire() b = self.balance sleep(5) self.balance = b + num self.lock.release() def draw_money(self, num): print('取%s元钱' % num) self.lock.acquire() b = self.balance if b Semaphore控制最大进程数量 sem = threading.Semaphore(2) def run(): with sem: for i in range(10): print('%d' %i)) time.sleep(1) if __name__ == '__main__': for i in range(5): t = threading.Thread(target=run) t.start() t.join() print('主线程结束') Barrier 凑够一定数量执行 bar = threading.Barrier(4) def run(): print('start') time.sleep(1) bar.wait() print('end') if __name__ == '__main__': for i in range(5): t = threading.Thread(target=run) t.start() t.join() print('主线程结束') Timer 延时执行 def run(): print(\"I'm a good man\") # 延时执行线程 t = threading.Timer(5, run) print('父线程开始') t.start() t.join() print('父线程结束') Event线程事件 def func(): # 事件对象 event = threading.Event() def run(): for i in range(5): # 阻塞，等待事件触发 event.wait() # 重置（必须进行） event.clear() print(\"I'm a good man\") t = threading.Thread(target=run).start() return event e = func() # 触发事件 for i in range(5): e.set() time.sleep(2) event.wait(timeout=None): 调用该方法的线程会被阻塞，如果设置了timeout参数，超时后，线程会停止阻塞继续执行； event.set(): 将event的标志设置为True，调用wait方法的所有线程将被唤醒； event.clear(): 将event的标志设置为False，调用wait方法的所有线程将被阻塞； event.isSet(): 判断event的标志是否为True。 Condition线程调度 cond = threading.Condition() def run1(): with cond: for i in range(0, 10, 2): print(threading.current_thread().name, i) time.sleep(1) cond.wait() cond.notify() def run2(): with cond: for i in range(1, 10, 2): print(threading.current_thread().name, i) time.sleep(1) cond.notify() cond.wait() threading.Thread(target=run1).start() threading.Thread(target=run2).start() wait([timeout]): 线程挂起，直到收到一个notify通知或者超时（可选的，浮点数，单位是秒s）才会被唤醒继续运行。 notify(n=1): 通知其他线程，那些挂起的线程接到这个通知之后会开始运行，默认是通知一个正等待该condition的线程,最多则唤醒n个等待的线程。 notifyAll(): 如果wait状态线程比较多，notifyAll的作用就是通知所有线程 多进程 多进程简介 进程是系统中程序执行和资源分配的基本单位，每个进程都有自己的数据段、代码段和堆栈段 使用前先导入from multiprocessing import Process linux中可以使用fork创建进程 在子进程中修改全局变量对父进程中的全局变量没有影响，在创建子进程时对全局变量做了一个备份，父进程与子进程中的num时完全不同的两个变量 多进程使用步骤 # 创建进程对象 p = Process(target=run, args=('nice',)) # 启动进程 p.start() # 父进程的结束不能影响子进程，让父进程等待子进程结束再执行父进程 p.join() target - function(函数),需要在子线程中调用的函数 args - 元组, 接收在子线程中调用函数时，函数的实参 start - 启动进程 join - 等待子进程结束 进程池 from multiprocessing import Pool pp = Pool(2) for i in range(5): # 创建进程，放入进程池统一管理 pp.apply_async(run, args=(i, )) # 在调用join之前必须先调用close，调用close之后就不能再继续添加新的进程了 pp.close() # 进程池对象调用join，会等待进程池中所有的子进程结束完毕再去执行父进程 pp.join() 进程间通信 from multiprocessing import Process, Queue def write(q): for chr in ['A', 'B', 'C', 'D']: q.put(chr) def read(q): while True: value = q.get(True) print('value = ' + value) if __name__ == '__main__': # 父进程创建队列，并传递给子进程 q = Queue() pw = Process(target=write, args=(q, )) pr = Process(target=read, args=(q,)) pw.start() pr.start() # 等待写子进程 pw.join() # pr进程里是个死循环，无法等待其结束，只能强行结束 pr.terminate() print('父进程结束') os.getpid() - 获取当前进程号 排列组合 使用前需要导入import itertools 排列 全排列:和位置有关,列表数字只能取一次 myList = list(itertools.permutations([1, 2, 3, 4], 3)) # 24 组合 和位置无关,列表数字只能取一次 myList = list(itertools.combinations([1, 2, 3, 4], 3)) 排列组合同时使用 和位置有关,数字可以取多次 myList = list(itertools.product([1, 2, 3, 4, 5], repeat=4)) 正则表达式 什么是正则 正则表达式是用来描述字符串规律的一种语法，可以更加方便的解决字符串匹配、字符 串查找、字符串切割等相关操作 字符 普通字符 - 表示这个字符本身 . - 匹配任意字符 \\w - 匹配字母、数字、下划线 \\W - 匹配除开字母、数字、下划线的其他字符 \\s - 匹配空白字符:空格、回车(\\n)、制表符(\\t) \\S - 匹配除开空白字符的其他字符 \\d - 匹配一个数子字符 \\D - 匹配非一个数子字符 [字符集] - 匹配字符集中任意一个字符 [^字符集] - 匹配不在字符集中的任意一个字符 [字符1-字符2] - 匹配编码值在字符1编码到字符2编码中的所有字符中的任意一个，字符1的编码值必须小于字符2 [0-9] - 数字字符，效果同与 \\d [\\u4e00-\\u9fa5] - 中文 [ \\n\\t] - 空白字符，效果同与 \\s 检测字符 \\b - 检测是否是单词边界(空白字符、标点符号、字符串开头和结束等) \\B - 检测是否不是单词边界 ^ - 检测是否是字符串开头(必须是在[]外面) $ - 检测是否是字符串结尾(必须是在[]外面) \\A - 匹配整个的字符串开始,在re.M的模式下也是整个字符串开始 \\Z - 匹配整个的字符串结尾,在re.M的模式下也是整个字符串结尾 次数控制 * - 匹配0次或多次 + - 匹配1次或多次 ? - 匹配0次或1次 {M} - 匹配M次 {M,} - 匹配至少M次 {M,N} - 匹配M到N次 {,N} - 匹配最多N次 贪婪匹配:所有不确定次数匹配均为贪婪匹配,如果要解决这个问题,在次数控制符号后面加? *?,+?,??,{M,N}?,{M,}?,{,N}? 结构 分支 正则1|正则2 - 分之,匹配满足正则1或正则2的内容 分组 () - 分组 做整体操作(\\d{3}|[A-Z]{2})abc HKabc 重复内容 - 正则中在数字前加\\, 用来重复它前面第几个分组匹配到的内容(一个括号就是一个分组)(\\d{3})abc\\1 123abc123123 还原特殊符号意义 转义字符 为了让正则中有特殊意义的符号的意义消失，而在这个符号前加\\ 放在特殊位置 除了^方法在[]的最开头，-放在[]中两个字符之间，其他单独存在有特殊意义的符号在[]中都是普通字符 python中的re 在python中使用正则表达式,需要先导入re模块import re 编译正则 compile(pattern, flags=0) pattern: 要编译的正则表达式 re_obj = re.compile(r'\\d{3}') re_obj.fullmatch('789') 匹配 fullmatch(正则表达式,字符串) - 完全匹配，让整个字符串和正则表达式进行匹配。如果匹配成功返回匹配对象，否则返回None re.match(pattern, string, flags=0) patter:匹配的正则表达式 string:要匹配的字符串 flag:标志位，用于控制正则表达式的匹配方式，值如下 re.I - 忽略大小写 re.L - 做本地户识别 re.M - 多行匹配，影响^和$ re.S - 是.匹配包括换行符在内的所有字符 re.U - 根据Unicode字符集解析字符，影响\\w,\\W,\\b,\\B re.X - 使我们以更灵活的格式理解正则表达式 功能: 尝试从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话，返回None 获取匹配结果(匹配到的子串) 匹配对象.group() - 获取整个正则表达式匹配到的结果 匹配对象.group(N) - 获取正则表达式中第N个分组匹配到的结果 获取匹配结果在原字符串中的范围 -返回:(开始下标,结束下标), 结束下标取不到 匹配对象.span() - 获取整个正则表达式匹配结果在原字符串中的范围 匹配对象.span(N) - 获取指定分组匹配结果在原字符串中的范围 3)获取原字符串 匹配对象.string 查找 re.search(pattern, string, flags=0) - 扫描整个字符串，并返回第一个成功的匹配 patter - 匹配的正则表达式 string - 要匹配的字符串 flag - 标志位，用于控制正则表达式的匹配方式，值如下 re.I - 忽略大小写 re.L - 做本地户识别 re.M - 多行匹配，影响^和$ re.S - 是.匹配包括换行符在内的所有字符 re.U - 根据Unicode字符集解析字符，影响\\w,\\W,\\b,\\B re.X - 使我们以更灵活的格式理解正则表达式 re.findall(pattern, string, flags=0) - 扫描整个字符串，并返回结果列表 patter - 匹配的正则表达式 string - 要匹配的字符串 flag - 标志位，用于控制正则表达式的匹配方式，值如下 re.I - 忽略大小写 re.L - 做本地户识别 re.M - 多行匹配，影响^和$ re.S - 是.匹配包括换行符在内的所有字符 re.U - 根据Unicode字符集解析字符，影响\\w,\\W,\\b,\\B re.X - 使我们以更灵活的格式理解正则表达式 注意: 如果findall中的正则表达式中有一个分组；返回列表中的元素只取匹配结果中分组对应的部分 如果正则表达式中有多个分组，返回的列表中的元素是元祖，元祖中的元素是每个分组对应的结果 re.finditer(pattern, string, flags=0) - 与findall类似，扫描整个字符串，返回的是一个迭代器 patter - 匹配的正则表达式 string - 要匹配的字符串 flag - 标志位，用于控制正则表达式的匹配方式，值如下 re.I - 忽略大小写 re.L - 做本地户识别 re.M - 多行匹配，影响^和$ re.S - 是.匹配包括换行符在内的所有字符 re.U - 根据Unicode字符集解析字符，影响\\w,\\W,\\b,\\B re.X - 使我们以更灵活的格式理解正则表达式 切割 re.split(正则表达式,字符串) - 将字符串中所有和正则表达式匹配的子串作为切割点，对字符串进行切割;返回值是列表 替换 sub(pattern, repl, string, count=0, flags=0) subn(pattern, repl, string, count=0, flags=0) pattern - 正则表达式（规则） repl - 指定的用来替换的字符串 string - 目标字符串 count - 最多替换次数 功能: 在目标字符串中以正则表达式的规则匹配字符串，再把他们替换成指定的字符串，可以指定替换的次数，如果不指定，替换所有的匹配字符串 区别: 前者返回一个被替换的字符串，后者返回一个元组，第一个元素是被替换的字符串，第二个元素表示被替换的次数 网络编程 使用前需要先导入import socket TCP服务端 创建一个socket,参数1:指定协议 AF_INET 或AF_INET6,参数2:SOCK_STREAM执行使用面向流的tcp协议 绑定ip和端口 监听 等待连接 连接成功,收发数据 import socket sk = socket.socket(socket.AF_INET,socket.SOCK_STREAM) server.bind(('127.0.0.1', 9999)) server.listen(5) clientSocket, clientAddress = server.accept() data = clientSocket.recv(1024).decode('utf-8') clientSocket.send(data.encode()) TCP客户端 创建一个socket 绑定服务端 收发数据 import socket client = socket.socket(socket.AF_INET, socket.SOCK_STREAM) client.connect(('127.0.0.1', 9999)) client.send(data.encode()) info = client.recv(1024).decode('utf-8') UDP服务端 创建一个socket, 参数1:指定协议 AF_INET 或AF_INET6,参数2:SOCK_DGRAM执行使用面向流的udp协议 绑定ip和端口 等待接收数据 发送数据 import socket udpServer = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) udpServer.bind(('127.0.0.1', 9998)) data, addr = udpServer.recvfrom(1024) udpServer.sendto(info.encode('utf-8'), addr) UDP客户端 创建一个socket 发送数据 接收数据 import socket client = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) client.sendto(data.encode('utf-8'),('127.0.0.1', 9998)) info = client.recv(1024).decode('utf-8') 网络请求 使用前需要先导入import urllib.request 网页请求 import urllib.request # 设置网页请求和超时时间,超时会报错 response = urllib.request.urlopen('htts://www.baidu.com', timeout=0.5) # 请求的数据直接保存 urllib.request.urlretrieve('http://www.baidu.com', filename=r'E:\\BaiduNetdiskDownload\\python_study\\18day\\html file\\file2.html') # urlretrieve在执行的过程中，会产生一些缓存 # 清除缓存 urllib.request.urlcleanup() req = urllib.request.Request(url, headers=headers) - 设置请求体 response = urllib.request.urlopen(req) - 发起请求 返回对象.read() - 获取请求到的全部内容, 返回对象.readline() - 读取一行 返回对象.readlines() - 读取全部内容,返回一个列表 返回对象.info() - 返回当前环境的有关信息 返回对象.getcode() - 返回状态码 返回对象.geturl() - 返回正在爬取的URL地址 urllib.request.unquote(url) - 对url进行解码,(中文进行识别) urllib.request.quote(url) - 对url进行编码 Post请求 使用前需要先导入import urllib.request import urllib.parse url = 'http://www.sunck.wang:8085/form' data = { 'username': 'sunck', 'passwd': '666' } postData = urllib.parse.urlencode(data) # 请求体 req = urllib.request.Request(url, data=postData) response = urllib.request.urlopen(req) 抓取动态网页的数据 import urllib.request import json import ssl def ajaxCrawler(url): headers = { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.131 Safari/537.36' } req = urllib.request.Request(url, headers=headers) context = ssl._create_unverified_context() response = urllib.request.urlopen(req, context=context) jsonStr = response.read().decode('utf-8') jsonData = json.loads(jsonStr) return jsonData # url = 'https://movie.douban.com/j/chart/top_list?type=5&interval_id=100%3A90&action=unwatched&start=20&limit=20' # info = ajaxCrawler(url) # print(info) for i in range(1, 11): url = 'https://movie.douban.com/j/chart/top_list?type=5&interval_id=100%3A90&action=unwatched&start=' + str(i*20) + '&limit=20' info = ajaxCrawler(url) print(info) requests 安装pip install requests 使用前导入import requests 请求: r = requests.get(url, params=d) 参数d表示值为字符串的字典，d不是必须的 r = requests.post(url,data=data)post请求需设置请求参数data 响应: r.status_code - 响应状态码 r.raw - 原始响应体，使用r.raw.read()读取 r.content - 字节方式的响应体，需要进行解码 r.text - 字符串形式的响应体，会自动根据响应头部的字符编码进行解码 r.headers - 以字典对象存储服务器响应头，字典见键不区分大小写，若键不存在返回none。 r.json() - Requests中内置的json解码器 r.raise_for_status() - 请求失败，抛出异常 r.url - 获取请求链接 r.cookies - 获取请求后的cookie r.encoding - 获取编码格式 PyMySQL 使用前需要先导入import pymysql 连接数据库 连接对象 = pymysql.connect(参数名=参数值) - 创建一个数据库链接，返回一个数据库对象 说明: host - mysql服务所在主机的ip port - 端口(不是字符串) user - 连接用户名 password - 连接密码 database - 数据库名 charset - 字符集，常用utf8 autocommit - 自动提交，默认关闭 cursorclass - 设置游标类型，默认为元组，设置为字典为pymysql.cursors.DictCursor 示例:db = pymysql.connect('localhost', 'root', 'stolen', 'stolen') 创建一个cursor()对象 cursor = 连接对象.cursor() cursor = 连接对象.cursor(pymysql.cursors.DictCursor) - 指定为字典形游标，查询返回的结果就是字典结构。 执行查询相关语句 执行查询sql语句 cursor对象名.execute('sql语句') 示例: cursor.execute(\"SELECT version()\") 获取查询返回的信息 接收变量 = cursor对象名.fetchone() 示例:data = cursor.fetchone() 说明: fetchone() - 抓取一条查询结果记录，结果是一条数据的元组 fetchall() - 抓取剩下结果所有的查询结果，结果集是一个元组，元组元素是元组 fetchmany(M) - 抓取查询结果中指定个数条数据 rowcount() - 只读属性，返回execute()方法影响的行数 执行修改相关语句 执行修改sql语句 cursor对象名.execute('sql语句') 示例:cursor.execute('insert into bandcard values(0,100)') 提交修改 格式:连接对象.commit() 说明:如果不报错,说明提交成功,如果报错,说明提交失败 格式:连接对象.rollback() 说明:回滚到上次数据,通常提交失败使用 示例 import pymysql sql = 'insert into bandcard values(0,100)' try: cursor.execute(sql) db.commit() print('提交成功') except: db.rollback() 断开连接 cursor对象名.close(), 数据库对象名.close 示例:cursor.close(), db.close() 常见错误 使用PyMySQL连接MySQL数据库 Connection reset by peer - 连接被对端重置 - 阿里云封IP - 安全管控中添加IP白名单 Can't connect to MySQL server on '1.2.3.4' (timed out) - 无法连接指定的服务器 - IP地址或者端口写错 Access denied for user 'root'@'1.2.3.4' (using password: YES) - 访问被拒绝 - 用户名或密码错误 Unknown database '...' - 未知的数据库 - 数据库名字写错了 AttributeError: 'NoneType' object has no attribute 'encoding' - AttributeError - 字符集写错了 mongoDB 使用前需要先导入from pymongo import MongoClient 连接步骤 连接服务器 conn = MongoClient('localhost',27017) 连接数据库 db = conn.mydb 获取集合 collection = db.student 操作集合 关闭连接 conn.close() 添加文档 collection.insert_ont(文档字典) - 添加一个文档 collection.insert_many(文档列表) - 添加多个文档 查询文档 res = collection.find({查询条件}) - 查询部分文档 res = collection.find() - 查询所有文档 res = collection.find({查询条件}).count()/res = collection.count_documents({查询条件}) - 查询统计 res = collection.find({'_id':ObjectId(id值)}) - 根据id查询 res = collection.find().sort('age',pymongo.DESCENDING) - 排序，按照age降序排列 res = collection.find().skip(2).limit(5) - 分页查询，跳过两条文档显示五条文档 更新文档 collection.update_one(查找条件字典,更新内容字典) - 更新文档 删除文档 collection.delete_one(查找条件字典) - 删除文档 redis 使用前需要先导入import redis redis连接 redis模块提供了两个类，Redis和StricRedis， StrictRedis用于实现大部分官方的命令，Redis是 StrictRedis的子类，用于向后兼用旧版本。 语法: cli = redis.Redis(host='地址', port=端口号, password='登录redis密码', db=数据库 cli = redis.StrictRedis(host='地址', port=端口号, password='登录redis密码', db=数据库 说明: 端口号为整型，不能用引号，数据库为数据库名，redis默认有16个，名为0到15 redis使用 redis中所有的命令在python中均变为方法: 示例: cli.set('name', 'wangdachui') cli.get('name') 缓冲数据执行 示例: pipe = cli.pipeline() pipe.set('p2', 'well') pipe.set('p3', 'nice') pipe.set('p4', 'cool') pipe.set('p5', 'handsome') pipe.execute() 说明: 减少服务器-客户端的tcp连接 内置模块 python内置函数 slice(start, stop [, step]) - 创建一个切片对象，该对象可以用在任何切片的地方 a = [1, 2, 3, 4, 5, 6, 7, 8 ,9, 10] item = slice(2, 7) a[item] # [3, 4, 5, 6, 7] item.start # 2 item.stop # 7 item.step # 如果slice中没有step，则没有返回值 item.indices(length) # 返回一个在length长度内的切片范围元组。 timeit 计算程序运行时间模块 使用前导入import timeit timeit.timeit() # stmt 需要测试的函数或语句，字符串形式 # setup 运行的环境，本例子中表示 if __name__ == '__main__': # number 被测试的函数或语句，执行的次数，本例表示执行100000次add()。省缺则默认是10000次 # 综上: 此函数表示在if __name__ == '__main__'的条件下，执行100000次add()消耗的时间 t = timeit.timeit(stmt=\"add()\", setup=\"from __main__ import add\", number=100000) timeit.repeat() # stmt 需要测试的函数或语句，字符串形式 # setup 运行的环境，本例子中表示 if __name__ == '__main__': # number 被测试的函数或语句，执行的次数，本例表示执行100000次add()。省缺则默认是10000次 # repeat 测试做100次，python3.7默认为5 # 综上: 此函数表示 测试 在if __name__ == '__main__'的条件下，执行100000次add()消耗的时间，并把这个测试做100次,并求出平均值 t = timeit.repeat(stmt=\"add()\", setup=\"from __main__ import add\", number=100000, repeat=100) heapq堆模块 使用前导入import heapq heapq.nlargest(n, iterable, key=None) - 获取iterable中最大的前n个数 heapq.nsmallest(n, iterable, key=None) - 获取iterable最小的前n个数 heapq.heapify(x) - 将列表x在线性时间内就地转换为堆，其中第一个元素是最小的 heapq.heappop(heap) - 从堆中弹出最小的值 heappush(heap, x) - 将x压入heap堆中 collections模块 使用前导入 import collections collections.defaultdict 作用: 让字典中的key具有默认值 from collections import defaultdict d = defaultdict(list) d['a'].append(1) d['a'].append(2) # d = {'a':[1, 2]} d = defaultdict(set) d['a'].add('1') d['a'].add('2') # d = {'a':{1, 2}} collections.OrderedDict字典排序 作用: 保证字典有序 from collections import OrderedDict # d是一个有序字典 d = OrderedDict() collections.Counter most_common([n]) - 返回出现次数最多的前n个元素 from collections import Counter a = [1, 2, 3, 4, 5, 6, 7, 5, 2, 6, 3, 1, 6, 2, 6] count = Counter(a) # count本质上就是一个字典 count.most_common(3) # [(6, 4), (2, 3), (1, 2)] count.update(容器) # 在之前计数的基础上将传入的容器统计进来 operator模块 使用前导入import operator operator.itemgetter 根据某个或某几个字典字段来排序这个列表 rows=[{'fname':'Brian','lname':'Jones','uid':1003},{'fname':'David','lname':'Beazley','uid':1002},{'fname':'John','lname':'Cleese','uid':1001},{'fname':'Big','lname':'Jones','uid':1004}] from operator import itemgetter rows_by_fname = sorted(rows, key=itemgetter('fname')) rows_by_lfname=sorted(rows, key=itemgetter('lname','fname')) operator.attrgetter 自定义sorted排序字段 class User: def __init__(self, user_id): self.user_id = user_id def __repr__(self): return'User({})'.format(self.user_id) def sort_notcompare(): users=[User(23), User(3), User(99)] print(users) # 以下两个结果一样 print(sorted(users, key=lambdau: u.user_id)) sorted(users, key=attrgetter('user_id')) uuid模块 使用前导入import uuid uuid.uuid1().hex - 返回一个随机16进制的字符串 asyncio异步编程 async - 将函数异步化 await - 程序阻塞后释放处理器 使用前导入import asyncio import asyncio async def print_number(num): await asyncio.sleep(1) print(num) loop = asyncio.get_event_loop() # 多路函数异步协作 loop.run_until_complete(asyncio.wait([print_number(num) for num in range(10)])) itertools 使用前导入import itertools itertools.groupby 将字典或序列根据特定字段 # 表示返回一个rows通过data分组后的序列 groupby(rows, key=itemgetter('date')） signal 使用前导入import signal signal.signal(signal.CTRL_C_EVENT, 回调函数) - windows监听退出事件 Copyright © book.stolenzc.com 2021-2023 all right reserved，powered by GitbookFile Modify: 2023-06-27 07:48:51 "},"RedisNote.html":{"url":"RedisNote.html","title":"Redis","keywords":"","body":"基本介绍 简介 Redis: REmote DIctionary Service，远程字典服务 Redis线程：Redis只有处理客户端请求（执行命令）是单线程，其他很多地方是多线程，如：后台删除对象、通过Redis模块实现阻塞命令、网络I/O（6.0）等 使用单线程的原因： 多线程不一定比单线程快，有创建和销毁的过程 多线程会涉及数据的安全性问题 Redis快的原因： Redis是纯内存结构，避免磁盘I/O的操作 Redis命令处理的核心模块是单线程，减少锁竞争，减少线程创建和销毁过程，减少线程上下问的切换 采用了I/O多路复用机制，提高并发效率 安装 安装： // 下载 wget https://labfile.oss.aliyuncs.com/courses/3368/redis-5.0.5.tar.gz // 解压 tar -zxvf redis-5.0.5.tar.gz // 安装 cd redis-5.0.5/src make && make install PREFIX=/home/project/redis-5.0.5 // 配置 vim /home/project/redis-5.0.5/redis.conf // 修改配置，后台运行redis daemonize no => daemonize yes // 启动redis服务 /home/project/redis-5.0.5/bin/redis-server /home/project/redis5.0.5/redis.conf // 蓝桥云课环境启动redis方法 sudo redis-server /etc/redis/redis.conf // ubuntu仅安装redis-cli sudo apt-get install redis-tools 速度测试 redis-benchmark - 吞吐量测试命令 -h - hostname，主机地址，默认为127.0.0.1 -p - port，端口号，默认为6379 -s - socket，套接字，会覆盖主机名和端口 -a - password，redis登陆认证密码 -t - tests，测试以逗号分割的测试列表，名称与输出名称相同 -n - requests，请求的数量，默认为10万 -q - quiet，仅输出每秒次数 系统命令 redis-server --version 或 redis-server -v - 查看redis-server版本 redis-cli --version 或 redis-cli -v - 查看redis-cli版本 info - redis-cli中输入查看相关信息 数据类型 数据类型简介 截止到6.0.6，一共支持9种类型 Binary-safe strings（二进制安全字符串） Lists（列表） Sets（集合） Sorted sets（有序集合） Hashes（哈希） Bit arrays（or simply bitmaps）（位图） HyperLogLogs Geospatial Streams 前五种为基础类型，后四种是基于前五种基本类型及特定算法来实现的特殊类型 数据结构 Redis中数据类型的存储，都会进行包装，每创建一个key-value值，都会创建两个对象，一个键对象，一个值对象，值对象会被包装成redisObject对象，然后将键对象和值对象通过dictEntry对象封装 typedef struct dictEntry { void *key; //指向key,即sds union { void *val; //指向value，即redisObject uint64_t u64; int64_t s64; double d; } v; struct dictEntry *next; //指向下一个key-value键值对(哈希值相同的键值对会形成一个链表，从而解决哈希冲突问题) } redisObject对象定义为： typedef struct redisObject{ unsigned type:4; // 对象类型（4位=0.5字节） unsigned encoding:4; // 编码（4位=0.5字节） unisgned lru:LRU_BITS; // 记录对象最后一次被应用程序访问的时间（24位=3字节） int refcount; // 引用计数。等于0时表示可以被垃圾回收（32位=4字节） void *ptr; // 指向底层实际的数据存储结构，如：sds、quicklist等（8字节） }robj; 类型和编码 type 和 encoding 用来记录当前的value属于什么基本数据类型，以及采用了哪种数据结构进行存储 type 属性表示对象类型 类型属性 描述 type命令返回值 REDIS_STRING 字符串对象 string REDIS_LIST 列表对象 list REDIS_HASH 哈希对象 hash REDIS_SET 集合对象 set REDIS_ZSET 有序集合对象 zset encoding 属性表示对象编码方式 编码属性 描述 object encoding 命令返回值 OBJ_ENCODING_INT 使用整数的字符串对象 int OBJ_ENCODING_EMBSTR 使用embstr编码实现的字符串对象 embstr OBJ_ENCODING_RAW 使用raw编码实现的字符串对象 raw 说明： int编码：如果字符串对象存储的是整型，且能用8个字节的long类型表示，就会用int编码存储，redisObject中的ptr指针也会替换为long类型 embstr编码：当储存的是字符串且长度小于44（redis3.2之前是39），会选择embstr编码来存储 raw编码：当存储的是字符串且长度大于44时，会用raw来存储 embstr编码长度的含义： 在embstr编码中，redisObject和sds是连续的一块空间，Redis限制长度为64个字节，其中redisObject固定占用16个字节，剩余48个字节 redis3.2版本以前，sds占用8个字节，加上字符串末尾的\\0，所以只剩39个字节 redis3.2版本以后，embstr采用sdshdr8来存储，sdshdr8只占用3个字节（len、alloc、flag各占用一个字节），加上末尾的\\0，所以剩余44个字节 注意： embstr编码字符串是只读的，如果对其修改，会重新分配内存，并且编码转换为raw 编码一旦升级（int->embstr->raw），无法进行回退 命令： type 键名 - 获取键的类型 object encoding 键名 - 获取键的存储方式 string 二进制安全字符串 SDS简介 Redis自己编写了一个新的数据结构来表示字符串，称为简单动态字符串（Simple dynamic string），简称sds 优点：不会由于字符串一直占用着空间而导致内存泄漏，也不会由于前面的字符串扩充覆盖到后面的字符串而造成缓存区溢出 SDS结构 老版本sds结构定义： struct sdshdr{ int len; // 记录buf数组已使用的长度，即SDS的长度（不包含末尾的`\\0`） int free; // 记录bug数组中未使用的长度 char buf[]; // 字节数组，用来保存字符串 } 3.2版本之后进行了优化，分为了sdshdr5、sdshdr8、sdshdr16、sdshdr32、sdshdr64，分别用来存储32 字节（2^5），256 字节（2^8），64KB（2^16），4GB 大小（2^32）以及 2^64 大小的字符串 因为目前版本 key 和 value 都限制了最大 512MB，所以 sdshdr64 暂时并未使用到 sdshdr5 只被应用在了 Redis 的 key 中，value 中不会被使用到，因为 sdshdr5 和其它类型也不一样，其并没有存储未使用空间，所以比较适用于使用大小固定的场景（比如 key 值） //定义了一个char 指针 typedef char *sds; struct __attribute__ ((__packed__)) sdshdr5 { unsigned char flags; /* 3 lsb of type, and 5 msb of string length */ char buf[]; }; //lsb 代表最低有效位的意思，msb代表最高有效位 //__attribute__ ((__packed__)) 代表structure 采用手动对齐的方式。 struct __attribute__ ((__packed__)) sdshdr8 { uint8_t len; /* 已经使用的长度 */ uint8_t alloc; /* 分配的长度，等于buf[]的总长度-1，因为buf有包括一个/0的结束符 */ unsigned char flags; /* 最低三位表示类型，0-4，前五位未使用 */ char buf[]; /* 实际的字符串 */ }; // 与上面的变化只有len和alloc， 就是长度不同而已 struct __attribute__ ((__packed__)) sdshdr16 { uint16_t len; /* used */ uint16_t alloc; /* excluding the header and null terminator */ unsigned char flags; /* 3 lsb of type, 5 unused bits */ char buf[]; }; struct __attribute__ ((__packed__)) sdshdr32 { uint32_t len; uint32_t alloc; unsigned char flags; char buf[]; }; struct __attribute__ ((__packed__)) sdshdr64 { uint64_t len; uint64_t alloc; unsigned char flags; char buf[]; }; SDS命令 incr 键名 - 将键对应的值加1，只适用于value为整数的情况 decr 键名 - 将键对应的值减1，只适用于value为整数的情况 incrby 键名 n - 将键对应的值加n，只适用于value为整数的情况 decrby 键名 n - 将键对应的值减n，只适用于value为整数的情况 list 列表 列表简介 Redis3.2之前，列表有两种存储结构：linkedlist(双端列表) 和 ziplist(压缩列表) Redis3.2之后，列表对象底层只有一种存储结构：quicklist(快速列表) 查看列表底层结构 编码属性 描述 object encoding命令返回值 OBJ_ENCODING_LINKEDLIST 使用linkedlist实现列表对象 linkedlist OBJ_ENCODING_ZIPLIST 使用ziplist实现列表对象 ziplist OBJ_ENCODING_QUICKLIST 使用quicklist实现列表对象 quicklist ziplist 和 linkedlist 的选择： 使用ziplist，需要同时满足以下两个条件： 列表对象保存的所有字符串元素的长度都小于64字节，可以使用list-max-ziplist-value进行修改 列表对象保存的元素数量小于512个，可以使用list-max-ziplist-entries进行修改 压缩列表ziplist 压缩列表简介 ziplist 是一种节省内存的数据结构 ziplist 是一块连续内存块的顺序型数据结构 ziplist 是由多个entry组成的，每个entry可以保存一个字节数组或者整数值 ziplist 和双端列表（如likedlist）区别是不存储前后节点的指针（通常占8个字节），而是维护了上一个节点和当前节点的长度 ziplist 有连锁更新的问题。当多个节点的长度位接近254（250-253）的时候，下一个节点存储上一个节点只需要一个字节，如果插入一个新节点大于254，则下一个节点存储上一个节点的位置会由一个字节变为5个字节，以此类推。 压缩列表属性说明 属性 类型 长度 说明 zlbytes uint32_t 4字节 记录压缩列表占用的字节数，包括自己的四个字节 zltail uint32_t 4字节 记录压缩列表末节点距离压缩列表起始地址的字节数（计算尾节点的地址，注意是尾节点的开始距离ziplist的开始的字节数） zllen uint16_t 2字节 记录压缩列表包含的节点数量，当长度超过65535时，存储为65535，此时需要遍历计算真实的节点数量 entry 节点 - 压缩列表中的节点，存储实际数据 zlend uint8_t 1字节 特殊字符0xff，标记压缩列表的末端 压缩列表结构 ziplist的结构： ... zlbytes、zltail、zllen 为 ziplist 的 head 部分； entry 为 ziplist 的 entries 部分，每一个 entry 代表一个数据； 最后 zlend 表示 ziplist 的 end 部分。 entry的结构： prevlen 存储了前一个entry的长度，可以计算出前一个entry的地址，进程从后向前遍历，prevlen长度可能是1或5 当链表的前一个entry占用字节小于254，则用1个字节表示 当链表的前一个entry占用字节大于或等于254时，用5个字节表示，第一个字节为254，后四个字节表示前一个entry的真实占用字节数 prevlen只取到254是因为255是ziplist的zlend固定为255，防止冲突 encoding 存储了当前entry的数据类型及长度，encoding的长度为1字节、2字节或5字节 encoding第一个字节来确定当前entry存储的是整数还是字节数组，当为整数时，第一个字节前两位总是11，其他情况则是字节数组 encoding存储为整型时，第一个字节的含义（前两位总为11）： 编码 长度 entry 保存的数据 11000000 1字节 int16_t 类型整数 11010000 1字节 int32_t 类型整数 11100000 1字节 int64_t 类型整数 11110000 1字节 24 位有符号整数 11111110 1字节 8 位有符号整数 1111xxxx 1字节 xxxx 代表区间 0001-1101，存储了一个介于 0-12 之间的整数，此时 entry-data 属性被省略 注意：xxxx只能取值0001-1101之间，因为0000、1110、1111被使用了。而且因为0是一个常用的数，所以将0001-1101都减去1，表示为0-12 encoding存储为字节数组时，用00、01、10来表示字节数组的长度： 编码 长度 entry保存的数据 00pppppp 1字节 长度小于等于 63 字节（6 位）的字节数组 01pppppp qqqqqqqq 2字节 长度小于等于 16383 字节（14 位）的字节数组 10000000 qqqqqqqq rrrrrrrr ssssssss tttttttt 5字节 长度小于等于 2 的 32 次方减 1 （32 位）的字节数组，其中第 1 个字节的后 6 位设置为 0，暂时没有用到，后面的 32 位（4 个字节）存储了数据 entry-data entry-data 存储的是数据的本身 存储0-12时，数据保存在encoding中，此时entry-data会被省略 linkedlist 双端列表 双端列表简介 每个节点都会存储指向上一个节点和下一个节点的指针 每个节点之间的空间不连续，会造成空间碎片 linkedlist是一个封装的list对象，list由多个listNode组成 双端列表结构 listNode是一个list对象 typedef struct list { listNode *head; //头节点 listNode *tail; //尾节点 void *(*dup)(void *ptr); //节点值复制函数 void (*free)(void *ptr); //节点值释放函数 int (*match)(void *ptr, void *key); //节点值对比函数 unsigned long len; //节点数量 } list; listNode结构 typedef struct listNode { struct listNode *prev; //前一个节点 struct listNode *next; //后一个节点 void *value; //值(字符串对象) } listNode; 当next指向NULL时，表示已经到了列表末尾了 quicklist 快速列表 快速列表简介 quicklist存储了一个双向列表，每个节点就是一个ziplist quicklist实际上就是ziplist和linkedlist的结合 quicklist的每个节点都是一个quicklistNode对象 快速列表结构 quicklist对象结构： typedef struct quicklist { quicklistNode *head; //列表头节点 quicklistNode *tail; //列表尾节点 unsigned long count; //ziplist中一共存储了多少元素，即:每一个quicklistNode内的count相加 unsigned long len; //双向链表的长度，即quicklistNode的数量 int fill : 16; //填充因子 unsigned int compress : 16; //压缩深度 0-不压缩 } quicklist; quicklistNode对象结构定义： typedef struct quicklistNode { struct quicklistNode *prev; //前一个节点 struct quicklistNode *next; //后一个节点 unsigned char *zl; //当前指向的ziplist或者quicklistLZF unsigned int sz; //当前ziplist占用字节 unsigned int count : 16; //ziplist中存储的元素个数，16字节(最大65535个) unsigned int encoding : 2; //是否采用了LZF压缩算法压缩节点 1：RAW 2:LZF unsigned int container : 2; //存储结构，NONE=1, ZIPLIST=2 unsigned int recompress : 1; //当前ziplist是否需要再次压缩(如果前面被解压过则为true，表示需要再次被压缩) unsigned int attempted_compress : 1; //测试用 unsigned int extra : 10; //后期留用 } quicklistNode; compress 压缩深度，可以通过list-compress-depth控制，默认为0不压缩，1表示首尾第一个元素不压缩，以此类推 zl 默认指向ziplist，如果节点被压缩了，则指向一个quicklistLZF对象 quicklistLZF对象 typedef struct quicklistLZF { unsigned int sz; // LZF大小，占用4字节 char compressed[]; //被压缩的内容，占用N字节 } quicklistLZF; 命令 lpush key value1 value2 - 将一个或多个value插入到key的头部，key不存在则创建，value2在value1之前 lpushx key value1 value2 - 将一个或多个value插入到key的头部，key不存在则不做任何处理，value2在value1之前 lpop key - 移除并返回key列表的头部值 rpush key value1 value2 - 将一个或多个value插入到key的尾部，key不存在则创建，value2在value1之后 rpushx key value1 value2 - 将一个或多个value插入到key的尾部，key不存在则不做任何处理，value2在value1之后 rpop key - 移除并返回key列表的尾部值 llen key - 返回key列表的长度 lindex key index - 返回列表key中下标为index的元素，index为正数（从0开始）表示从头算，index为负数（-1开始）表示从尾算 lrange key start stop - 返回列表key中下标[start, stop]之间的元素，包括start和stop lset key index value - 将key列表中下标为index的值改为value，key不存在或index越界会报错 ltrim key start end - 截取[start, end]的值并将其更新为key的值 hash 哈希对象 哈希简介 hash对象本身是一个key-value存储结构 hash底层存储结构是ziplist（压缩列表）和hashtable（哈希表） hash对象中的ziplist结构中的entry是key，value紧挨在一起的 编码属性 描述 object encoding命令返回值 OBJ_ENCODING_ZIPLIST 使用压缩列表实现哈希对象 ziplist OBJ_ENCODING_HT 使用字典实现哈希对象 hashtable 哈希对象满足以下条件会使用ziplist 哈希对象中所有键对总长度小于64（可以使用hash-max-ziplist-value修改）个字节 哈希对象中键值对数量小于512（可以使用hash-max-ziplist-entries修改） 哈希结构 注意：hash对象的key-value是从dictEntry对象进行包装的。hash表就是dictEntry对象进行再一次包装得到的。 字典是redis数据结构redisObject在hash类型中value指向的结构，定义如下 typedef struct dict { dictType *type; //字典类型的一些特定函数 void *privdata; //私有数据，type中的特定函数可能需要用到 dictht ht[2]; //哈希表(注意这里有2个哈希表) long rehashidx; //rehash索引，不在rehash时，值为-1 unsigned long iterators; //正在使用的迭代器数量 } dict; hash表就是dictEntry的一个封装，成为dictht，dict中会指向dictht。 typedef struct dictht { dictEntry **table; //哈希表数组，每个元素都是dictEntry unsigned long size; //哈希表大小 unsigned long sizemask; //掩码大小，用于计算索引值，总是等于size-1 unsigned long used; //哈希表中的已有节点数 } dictht; rehash 操作 dict中会定义一个数组ht[2]，其元素为dictht对象，默认情况下只会使用一个，不会为另一个分配初始空间。设置一个哈希对象时会计算哈希值确定落在哪个下标上，如果发生hash碰撞，同一个下标就会有多个dictEntry，每次发生冲突时，插入的值总在最前面。 进行rehash条件 负载因子大于等于 1 且 dict_can_resize 为 1 时。 负载因子大于等于安全阈值（dict_force_resize_ratio=5）时。 负载因子 = 哈希表已使用节点数 / 哈希表大小（即：h[0].used/h[0].size） rehash 步骤 rehash的目的主要是重新分配hash数组的大小，然后将保存的的hash对重新分配到数组的不同下标上去 给字典dict的ht[1]分配空间 如果是扩展，ht[1]的大小为2的n次方中第一个大于等于 ht[0].used * 2 的值，如ht[0]有三个hash对象，used=3，则 ht[0].used * 2=6 ，故ht[1]的大小为8 如果是收缩，ht[1]的大小为2的n次方中第一个大于等于ht[0].used的值。如ht[0].used=3，则分配空间为2^2 将字典中的属性 rehashidx 的值设置为 0，表示正在执行 rehash 操作 将 ht[0] 中所有的键值对依次重新计算哈希值，并放到 ht[1] 数组对应位置，每完成一个键值对的 rehash 之后 rehashidx 的值需要自增 1。 当 ht[0] 中所有的键值对都迁移到 ht[1] 之后，释放 ht[0]，并将 ht[1] 修改为 ht[0]，然后再创建一个新的 ht[1] 数组，为下一次 rehash 做准备。 将字典中的属性 rehashidx 设置为 -1，表示此次 rehash 操作结束，等待下一次 rehash。 redis的rehash不是一次全部性执行完，而是渐进式执行，如果新的值进来，则统一放到ht[1]中，如果有查询，先查询ht[0]，不存在再查询ht[1] 哈希命令 hset key field value - 设置单个field（哈希对象的key值） hmset key field1 value1 field2 value2 - 设置多个field（哈希对象的key值） hsetnx key field value - 将key中field对应的值设置为value，如果存在field则不执行任何操作 hget key field - 获取哈希表key中filed对应的value hmget key field1 field2 - 获取哈希表key中多个field对应的value hdel key field1 field2 - 删除哈希表key中的多个field hlen key - 获取哈希表key中的数量 hincrby key field increment - 给哈希表key中field对应的值加上increment，increment可以为负数，不是数字会报错 hincrbyfloat key field increment - 为哈希表key中的field的值加上increment，increment可以为负数，不是float类型则会报错。 hkeys key - 获取哈希表key中的所有field hvals key - 获取哈希表key中的所有value sets 集合 集合简介 集合对象是一个包含字符串类型元素的无序集合 集合中元素唯一不可重复 集合底层的数据类型是intset 和 hashtable 编码属性 描述 object encoding 命令返回值 OBJ_ENCODING_INTSET 使用整数集合实现的集合对象 intset OBJ_ENCODING_HT 使用字典实现的集合对象 hashtable 当同时满足以下两个条件时，会使用intset 集合对象保存的所有元素都是整数值 集合对象保存的元素数量小于512（可以使用set-max-intset-entries控制） intset整数集合结构 intset可以保存类型为int16_t、int32_t、int64_t的整数 intset定义： typedef struct intset { uint32_t encoding; //编码方式 uint32_t length; //当前集合中的元素数量 int8_t contents[]; //集合中具体的元素 } intset; encoding: INTSET_ENC_INT16：此时 contents[] 内的每个元素都是一个 int16_t 类型的整数值，范围为-2^15~2^15-1 INTSET_ENC_INT32：此时 contents[] 内的每个元素都是一个 int32_t 类型的整数值，范围为-2^31~2^31-1 INTSET_ENC_INT64：此时 contents[] 内的每个元素都是一个 int64_t 类型的整数值，范围为-2^63~2^63-1 content[]: 结构上定义为int8_t，实际由encoding决定 类型的升级： 当一个32位的整数插入到int16_t类型中时，会进行类型的升级： 根据新添加元素的类型来扩展底层数组空间的大小，按照升级后现有元素的位数来分配新的空间。 将现有的元素进行类型转换，并将转换类型后的元素从后到前逐个重新放回到数组内。 将新元素放到数组的头部或者尾部（因为触发升级的条件就是当前数组的整数类型无法存储新元素，所以新元素要么比现有元素都大，要么就比现有元素都小）。 将 encoding 属性修改为最新的编码，并且同步修改 length 属性。 注意：类型升级后无法进行降级 集合命令 sadd key member1 member2 - 将一个或多个元素加入到集合key中，返回成功加入的条目，已存在的元素会被忽略 sismember key member - 判断member是否在key中 srem key member1 member2 - 移除key中指定的元素，不存在会被忽略 smove source dest member - 将元素从source移动到dest中，元素不存在会被忽略 smembers key - 返回集合中所有的元素 Sorted sets 有序集合 有序集合简介 有序集合中每个元素都会关联一个double类型的分数，然后按照分数从小到大排序 有序集合对象底层数据结构有两种：skiplist和ziplist 编码属性 描述 object encoding命令返回值 OBJ_ENCODING_SKIPLIST 使用跳跃表实现的有序集合对象 skiplist OBJ_ENCODING_ZIPLIST 使用压缩列表实现的有序集合对象 ziplist 当有序集合对象同时满足以下两个条件时，会使用 ziplist 编码进行存储： 有序集合对象中保存的元素个数小于128个（可以使用zset-max-ziplist-entries控制） 有序集合对象中保存的所有元素的总长度小于64字节（可以使用zset-max-ziplist-value控制） skiplist结构 使用skiplist的有序集合使用了zset结构作为有序集合的值，zset中包含了一个哈希字典和一个skiplist typedef struct zset { dict *dict;//字典对象 zskiplist *zsl;//跳跃表对象 } zset; 其中，zskiplist是一个由多个zskiplistNode组成的对象 typedef struct zskiplist { struct zskiplistNode *header, *tail;//跳跃表的头节点和尾结点指针 unsigned long length;//跳跃表的节点数 int level;//所有节点中最大的层数 } zskiplist; 通过zskiplist头尾节点和最大层数，就可以得知zskiplistNode的遍历方法，skiplistNode定义如下： typedef struct zskiplistNode { sds ele;//元素 double score;//分值 struct zskiplistNode *backward;//后退指针 struct zskiplistLevel {//层 struct zskiplistNode *forward;//前进指针 unsigned long span;//当前节点到下一个节点的跨度（跨越的节点数） } level[]; } zskiplistNode; level 层 表示跳跃表的层，是一个数组，所以一个节点可以有多个层，程序可以通过不同的层来选择最快捷的访问方式，每次创建新的节点时根据幂次定律随机生成一个1～32的数字 forward 前进指针 每个层都有一个指向链表尾部方向的指针，遍历时需要使用 span 跨度 记录两个节点之间的距离，如果为RULL，表示跨度为零 backward 后退指针 后退指针只有一个，且只能后退到链表当前位置的前一个节点 ele 跳跃表中的元素，是一个sds对象，必须唯一，不能重复 score 分数，表示元素的权重跳跃表会将节点按照分值从小到大排列，不同节点分值可以重复 redis中skiplist的结构 同时使用skiplist和字典的原因： 查找单个元素时，使用字典更快，但是字典无序 查找排列顺序是，使用skiplist有序 有序集合命令 zadd key score1 member1 score2 member2 - 将一个或多个元素（member）及其 score 添加到有序集合key中。 zscore key member - 返回有序集合key中member成员的score。 zincrby key num member - 将有序集合key中的member加上num，num可以为负数。 zcount key min max - 返回有序集合key中score值在 [min,max] 区间的member数量。 zrange key start stop - 返回有序集合key中score从小到大排列后在[start,stop] 区间的所有member。 zrevrange key start stop - 返回有序集合key中score从大到小排列后在[start,stop]区间的所有 member。 zrangebyscore key min max - 返回有序集合中按score从小到大排列后在[min,max]区间的所有元素。注意这里默认是闭区间，但是可以在max和min的数值前面加上(或者[来控制开闭区间。 zrevrangebyscore key max min - 返回有序集合中按score从大到小排列后在[min,max]区间的所有元素。注意这里默认是闭区间，但是可以在max和min的数值前面加上(或者[来控制开闭区间。 zrank key member - 返回有序集合中member中元素排名（从小到大），返回的结果从0开始计算。 zrevrank key member - 返回有序集合中member中元素排名（从大到小），返回的结果从0开始计算。 zlexcount key min max - 返回有序集合中min和max之间的member数量。注意这个命令中的min和max前面必须加(或者[来控制开闭区间，特殊值-和+分别表示负无穷和正无穷。 发布和订阅 双端列表实现发布和订阅的问题： 如果生产者生产消息的速度远大于消费者消费消息的速度，那么链表中未消费的消息会大量堆积，导致占用大量的内存。 基于链表实现的消息队列，不支持一对多的消息分发。 redis实现发布和订阅方式：基于频道和基于模式 当同时存在基于频道和基于模式两种订阅，Redis会首先寻找频道字典，再去遍历模式链表 基于频道 基于频道实现原理 客户端与其订阅的频道信息被保存在redisServer对象中的pubsub_channels属性中 struct redisServer { dict *pubsub_channels;//保存了客户端及其订阅的频道信息 //... 省略其他信息 }; pubsub_channels属性是一个字典，key为频道名，value为链表，分别为每个客户端的id 订阅：订阅的时候首先会检查字典是否存在这个频道，如果不存在，则需要在当前频道创建字典，同时创建一个链表作为value，将当前客户端id放入链表。如果存在，直接将当前客户端id放入链表末尾 取消订阅：取消订阅的时候需要将该客户端id从对应的链表中移除，如果移除之后链表为空，则需要同时将该频道从字典中删除 发送消息：发送消息时首先会去pubsub_channels字典内寻找键，如果发现有可以匹配的键，则找到对应的链表，进行遍历发送消息 基于频道发布订阅命令 subscribe channel-1 channel-2 - 订阅一个或者多个频道 unsubscribe channel-1 - 取消频道的订阅 publish channel-1 message - 向频道channel-1发送消息message pubsub channels [channel_name] - 查看当前服务器被订阅的频道，不带参数则返回所有频道，后面的参数可以使用通配符?或* pubsub numsub channel_name [channel_name] - 查看指定频道的订阅数（可同时查看多个） 基于模式 基于模式实现原理 客户端与其订阅的模式信息被保存在 redisServer 对象中的 pubsub_patterns 属性中 struct redisServer { list pubsub_patterns;//保存了客户端及其订阅的模式信息 //...省略其他信息 }; pubsub_patterns是一个列表，内部为结构为 typedef struct pubsubPattern { client *client; //订阅模式的客户端 robj *pattern; //被订阅的模式 } pubsubPattern; 订阅：新建一个pubsubPattern数据结构加入到链表pubsub_patterns的结尾。 取消订阅：从链表中将当前取消订阅的客户端pubsubPattern从链表pubsub_patterns中移除。 发送消息：此时需要遍历整个链表来寻找能匹配的模式。之所以基于模式场景使用链表是因为模式支持通配符，所以没有办法直接用字典实现。 基于模式发布订阅命令 psubscribe pattern-1 pattern-2 - 订阅一个或者多个模式，模式可以通过通配符?和*来表示。 pubsubscribe pattern-1 pattern-1 - 取消模式的订阅（基于命令操作，界面上无法退订） publish channel-1 message - 向频道channel-1发送消息message。这里和上面基于频道命令是一样的。 pubsub numpat - 查询当前服务器被订阅模式的数量 Lua脚本 Lua脚本简介 Redis从2.6版本开始支持Lua脚本 Redis服务器中嵌入了Lua环境 调用lua脚本 eval lua-script numkeys key [key ...] arg [arg ...] eval - 执行lua脚本的命令 lua-script - Lua脚本内容 numkeys - 表示的是lua脚本中需要用到多少个key，如果没写则是0 key [key ...] - 将key按顺序传入到lua脚本中，numkeys为0时可省略 arg - lua脚本中用到的参数，没有则可以省略 示例：eval \"return 'Hello Redis'\" 0 lua脚本执行redis redis.call(command, key [key ...] argv [argv…]) command - redis中的命令，如set，get等 key - 操作redis的key值，相当于调用方法的形参 param - 代表参数，相当于调用方法的实参 示例：eval \"return redis.call('set',KEYS[1],ARGV[1])\" 1 name lonely_wolf 等同于：set name lonely_wolf 注意：KEYS和ARGS必须大写，参数下标从1开始，1表示需要一个参数 lua脚本摘要 有时候如果我们执行的一个 Lua 脚本很长，那么直接调用 Lua 脚本会非常不方便，所以 Redis 当中提供了一个命令 script load 来手动给每个 Lua 脚本生成摘要，这里之所以要说手动的原因是即使我们不使用这个命令，每次调用完 Lua 脚本的时候，Redis 也会为每个 Lua 脚本生成一个摘要。 script load lua_src - 为lua_src内容生成一个摘要 script exists 摘要 - 判断一个摘要是否存在，0表示不存在，1表示存在 evalsha \"摘要id\" key [key ...] value [value ...] - 通过摘要执行lua脚本 script flush - 清除所有lua脚本缓存 示例： script load \"return redis.call('set',KEYS[1],ARGV[1])\" //给当前 Lua脚本生成摘要，这时候会返回一个摘要 evalsha \"c686f316aaf1eb01d5a4de1b0b63cd233010e63d\" 1 address china //相当于执行命令 set address china get address //获取 adress，确认上面的脚本是否执行成功 script exists \"c686f316aaf1eb01d5a4de1b0b63cd233010e63d\" //判断当前摘要的 Lua脚本是否存在 script flush //清除所有 Lua脚本缓存 script exists \"c686f316aaf1eb01d5a4de1b0b63cd233010e63d\" //清除之后这里就不存在了 lua脚本文件 新建一个test.lua脚本 redis.call('set',KEYS[1],ARGV[1]) return redis.call('get',KEYS[1]) bash命令行执行 # 注意 key 和 arg 参数之间要以逗号隔开，且逗号两边的空格不能省略 redis-cli --eval /home/project/test.lua 1 age , 18 lua脚本异常 redis默认脚本超时时间lua-time-limit 为5000毫秒 script kill - 脚本陷入死循环后，可以中断执行，但是要求当前脚本必须没有成功执行过redis操作的命令 shutdown nosave - 强制退出lua脚本 redis持久化 持久化简介 redis提供了两种持久化机制，RDB和AOF RDB持久化 RDB全称为 Redis DataBase redis默认的的持久化方案 会生成一个dump.rdb文件，重启后通过解析dump.rdb文件进行数据恢复 支持手动触发和自动触发 优点： RDB 是一个非常紧凑的压缩文件，保存了不同时间点上的文件，非常适合用来灾备和数据恢复。 RDB 最大限度地提高了Redis的性能，因为父进程只需要派生一个子进程，父进程永远不会执行磁盘 I/O 或类似的耗时操作。 与AOF持久化机制比较，RDB方式恢复数据的速度更快 缺点： RDB无法做到实时备份，如果Redis因异常停止工作而没有正确的关机，那么从上一次备份到异常宕机的这一段时间的数据将会丢失 RDB通常需要父进程来执行fork操作创建子线程，所以如果频繁执行fork操作而CPU性能又不是很高的话可能会造成短时间内父进程不可用 自动触发条件 执行flushall命令（flushdb不会触发）时，此时生成的dump文件内数据是空的 执行shutdown命令时 通过配置文件自动生成，redis默认配置如下，达到任意一个条件就会触发 save 900 1 #900秒内至少有1个key被添加或者更新 save 300 10 #300秒内至少有10个key被添加或者更新 save 60 10000 #60秒内至少有10000个key被添加或者更新 手动触发 save - 这个命令会阻塞redis服务器，直到成功创建RDB文件，在此期间不能执行redis命令 bgsave - 父进程会fork一个子进程，子进程负责RDB文件生成 注意： 两个命令不能同时执行，一个执行另一个会被拒绝执行 lastsave 可以查看最近成功执行save或bgsave的时间，返回的是unix时间戳 RDB机制的相关配置，前面加config get表示从命令行获取该配置 config get dir - rdb文件的目录，默认是安装目录 config get dbfilename - rdb文件名，默认是dump.rdb config get rdbcompression - rdb文件是否是LZF压缩文件,默认是yes config get rdbchecksum - 是否开启数据校验。默认是yes AOF持久化 AOF全称为Append Only File AOF是采用日志的形式将写操作追加到文件中去到 执行更改数据命令时，命令会被追加到AOF文件中去 Redis重启时会根据日志内容依次执行AOF到命令来恢复数据 同时开启AOF和RDB时，redis优先会使用AOF AOF记录的是命令，RDB记录的是数据 开启AOF，需要修改配置文件 appendonly no #是否开启AOF机制，默认是no表示关闭，修改为yes则表示开启 appendfilename \"appendonly.aof\" #AOF文件名 AOF是否实时写入磁盘通过appendfsync配置 appendfsync 描述 备注 always 写入缓存的同时通知操作系统刷新（fsync）到磁盘（但是也可能会有部分操作系统只是尽快刷盘，而不是实时刷盘） Slow, Safest everysec 先写入缓存，然后每秒中刷一次盘（默认值），这种模式极端情况可能会丢失1s的数据 Compromise no 只写入缓存，什么时候刷盘由操作系统自己决定 Faster AOF文件重写 对于一个数据进行了多次重复修改，记录多次数据会没意义，这样就通过AOF文件重写实现 重写原理：redis会重新去读取现有的键值对，然后用一条命令记录键值对的值，但当元素超过64个，就会用多条命令来记录 重写操作：引入一个重写缓冲区，解决数据不一致的问题，当开始执行AOF文件重写之后又接收到客户端当请求命令，不但要将命令写入原本的AOF缓冲区，还要同时写入AOF重写缓冲区。 一旦子进程完成来AOF文件的重写，此时会向父进程发出信号，父进程收到信号之后会进行阻塞，并进行 将AOF重写缓冲区的文件刷新到新的AOF文件内 将新AOF文件进行改名并原子的替换掉旧的AOF文件 触发条件： 自动触发：自动触发通过以下参数设置 auto-aof-rewrite-percentag #文件大小超过上次AOF重写之后的文件的百分比。默认100，也就是默认达到上一次AOF重写文件的2倍之后会再次触发AOF重写 auto-aof-rewrite-min-size #设置允许重写的最小AOF文件大小,默认是64M。主要是避免满足了上面的百分比，但是文件还是很小的情况。 手动触发：执行bgrewriteaof命令。 bgrewriteaof 命令也不能和上面 RDB 持久化命令 bgsave 同时执行，这么做是为了避免同时创建两个子进程来同时执行大量写磁盘操作，影响到 Redis 的性能。 AOF机制优点： 使用AOF机制，可以自由选择不同fsync（刷盘）策略，而且在默认策略下最多也仅仅是损失1s的数据。 AOF日志是一个仅追加的日志，因此如果出现断电，也不存在查找或损坏问题。即使由于某些原因（磁盘已满或其它原因），日志已经写了一半的命令结束，redis-check-aof工具也能够轻松地修复它。 当AOF文件变得太大时，Redis能够在后台自动重写。 不同于RDB的文件格式，AOF是一种易于理解和解析的格式，依次包含所有操作的日志。 AOF机制缺点： 对于相同的数据集，AOF文件通常比等效的RDB文件大。 根据fsync的具体策略，AOF机制可能比RDB机制慢。但是一般情况下，fsync设置为每秒的性能仍然很高，禁用fsync后，即使在高负载下，它的速度也能和RDB一样快。 因为AOF文件是追加形式，可能会遇到BRPOP、LPUSH等阻塞命令的错误，从而导致生成的AOF 在重新加载时不能复制完全相同的数据集，而RDB文件每次都是重新从头创建快照，这在一定程度上来说RDB文件更加健壮。 内存管理 内存回收 可以设置数据有效时间来使内存释放 EXPIRE key seconds - 设置 key 过期时间，单位为秒 EXPIREAT key timestamp - 设置以秒为单位的 key 过期时间的时间戳，时间戳长度为10 PEXPIRE key milliseconds - 设置 key 过期时间，单位为毫秒 PEXPIREAT key milliseconds-timestamp - 设置一个以毫秒为单位的 key 过期时间的时间戳，时间戳长度为13 SETEX key seconds value - 设置 key 对应的字符串，并设置该 key 的过期时间，等价于执行一下两条命令 SET key value EXPIRE key seconds PSETEX key milliseconds value - 功能同 SETEX ，设置 key 对于的字符串，并设置该 key 的过期时间，时间单位为毫秒 所有设置过期方法底层都是通过pexpireat来实现的 过期策略 redis中的过期策略： 惰性删除 使用 expireIfNeeded() 函数对 key 进行检查，如果过期了就会将 key 删除掉，如果未过期则不做操作 定期删除 Redis 启动服务时，读取配置中的 server.hz 的值，默认为10 每秒执行 server.hz 次 serverCron() 函数， serverCron() 会调用 databasesCron ， databasesCron() 会调用 activeExpireCycle() activeExpireCycle() 对每个 expires[*] 逐一进行检测，每次执行 250ms/server.hz 毫秒 对每个 expires[*] 检测时，随机挑选W个key检测 如果key超时，则删除 key 如果一轮中满足 删除的 key 数量 > W * 25% , 则循环该过程 如果一轮中满足 删除的 key 数量 , 则检查下个 db 的expires W 取值为 ACTIVE_EXPIRE_CYCLE_LOOKUP_PER_LOOP 属性的值 参数 current_db 记录 activeExpireCycle() 执行到哪个 db 如果执行 activeExpireCycle() 时间到期，下次继续从 current_db 进行执行 redis中定期扫描只扫描有过期时间的键，不会扫描所有的键，有过期时间的键是单独存储的。 typedef struct redisDb { dict *dict; //所有的键值对 dict *expires; //设置了过期时间的键值对 dict *blocking_keys; //被阻塞的key,如客户端执行BLPOP等阻塞指令时 dict *watched_keys; //WATCHED keys int id; //Database ID //... 省略了其他属性 } redisDb; 淘汰策略 数据淘汰相关的配置： maxmemory ?mb - 最大可用内存，64位系统默认值为0，表示不限制，32位系统默认隐式限制为3GB maxmemory-samples count - 每次选取删除数据的个数，采用随机获取数据的方式为待检测删除数据 maxmemory-policy policy - 删除数据所使用的策略，主要存在以下8种 maxmemory-policy可以配置为以下值 淘汰策略 说明 volatile-lru 根据 LRU 算法删除设置了过期时间的键，直到腾出可用空间。如果没有可删除的键对象，且内存还是不够用时，则报错 allkeys-lru 根据 LRU 算法删除所有的键，直到腾出可用空间。如果没有可删除的键对象，且内存还是不够用时，则报错 volatile-lfu 根据 LFU 算法删除设置了过期时间的键，直到腾出可用空间。如果没有可删除的键对象，且内存还是不够用时，则报错 volatile-ttl 根据键值对象的 ttl 属性， 删除最近将要过期数据。 如果没有，则直接报错 allkeys-lfu 根据 LFU 算法删除所有的键，直到腾出可用空间。如果没有可删除的键对象，且内存还是不够用时，则报错 volatile-random 随机删除设置了过期时间的键，直到腾出可用空间。如果没有可删除的键对象，且内存还是不够用时，则报错 allkeys-random 随机删除所有键，直到腾出可用空间。如果没有可删除的键对象，且内存还是不够用时，则报错 noeviction 默认策略，不作任何处理，直接报错 报错为 (error)OOM command not allowed when used memory>'maxmemory' LRU 算法 LRU全称为least recently used，最近最长时间未使用 缺点： 需要额外的空间进行存储 可能存在某些key使用很频繁，但最近没使用，被LRU算法删除 redis改进了LRU算法，通过抽样的方式进行删除 配置文件有个maxmemory_samples，默认为5，表示随机抽取5个key，对这5个key值按照LRU算法删除 redisObject对象中有一个lru属性： typedef struct redisObject { unsigned type:4;//对象类型（4位=0.5字节） unsigned encoding:4;//编码（4位=0.5字节） unsigned lru:LRU_BITS;//记录对象最后一次被应用程序访问的时间（24位=3字节） int refcount;//引用计数。等于0时表示可以被垃圾回收（32位=4字节） void *ptr;//指向底层实际的数据存储结构，如：SDS等(8字节) } robj; lru属性就是记录了这个键最后被访问的时间，然后redis维护了一个全局的lru_clock，这个全局属性通过一个全局函数serverCron每隔100毫秒执行一次来更新，记录当前unix时间戳。使用lru_clock可以避免每次读取系统时间，对性能的极致优化 注意：redisObject的lru为24位，只能存储194天的时间戳，超过194天又会从0开始计数，所以此处有两种情况 当lru_clock > lru时，空闲时间为lruclock - lru 当lru_clock LFU算法 LFU全称为Least Frequently Used，即最近最少频率使用 当采用LFU回收策略时，lru属性高16位用来记录访问时间，低8为记录访问频率（counter） 增加：取0到1的随机数，计算counter-初始值（默认为5）为基础值，计算1/（基础值*lfu_log_factor+1），如果值大于随机数，counter则加1 减小：去除当前的时间戳和对象中的lru属性进行对比，计算出多久没有被访问，再除以配置的lfu_decay_time（默认为10），用counter减去得到的值。 redis事务 事务使用 multi - 开启事务 exec - 执行事务（提交） discard - 取消事务 watch - 监视 事务执行步骤： multi开启一个事务 开始事务后执行的命令会放入一个队列， 执行exec提交事务，redis会依次执行队列中的命令，并返回结果，如果想要放弃，可以执行discard 示例： multi //开启事务 set name lonely_wolf //设置 name，此时 Redis 会将命令放入队列 set age 18 //设值 age，此时 Redis 会将命令放入队列 get name //获取 name，此时 Redis 会将命令放入队列 exec //提交事务，此时会依次执行队列里的命令，并依次返回结果 事务实现原理 redis事务的结构简图 redis每个客户端都有记录当前事务状态的multState 一个客户端的定义： typedef struct client { uint64_t id;//客户端唯一 id multiState mstate; //MULTI 和 EXEC 状态(即事务状态) //...省略其他属性 } client; multiState定义： typedef struct multiState { multiCmd *commands;//存储命令的 FIFO 队列 int count;//命令总数 //...省略了其他属性 } multiState; commands是一个队列，队列元素都是multiCmd对象， typedef struct multiCmd { robj **argv;//用来存储参数的数组 int argc;//参数的数量 struct redisCommand *cmd;//命令指针 } multiCmd; 事务的acid特性 原子性：redis中执行事务的时候某一个命令失败了，不会影响其他的命令，即redis事务不会回滚 一致性：一致性指的是事务执行前后数据符合数据库的定义和要求，Redis满足，语法错误和运行错误时，命令均不会被执行 隔离性：redis在执行事务的过程中，另一个客户端的请求无法被执行，满足了隔离性的要求 持久性：当redis开启了持久化后，满足持久性 watch 当一个事务开启但未执行的时候，另一个客户端发出了修改值的命令，会造成数据非预期或覆盖有效值的问题 watch命令可以为Redis事务提供一个乐观锁的行为，在exec命令执行前监视key的变化，当多个线程更新同一个key的时候，会跟原值做比较，一旦发现修改过，则拒绝执行命令，并会返回nil 示例： 开启一个客户端执行 flushall //清空数据库 watch name //监视 name multi //开启事务 set name lonely_wolf //设置 name set age 18 // 设置 age get name //获取 name get age //获取 age 开启第二个客户端执行 set name zhangsan 在第一个客户端执行exec，会返回nil，整个事务都不会被执行 原理：redisDB中有一个watched_keys，类型为dict，字典的键为被上锁的key，字典的值为客户端的id，客户端中还有个CLIENT_DIRTY_CAS属性，当键执行了set，sadd等能修改key值对应的value时，遍历watched_keys，将键上锁的客户端中的CLIENT_DIRTY_CAS进行修改，提交事务的时候发现CLIENT_DIRTY_CAS被修改过则会拒绝执行事务。 typedef struct redisDb { dict *watched_keys; //被 watch 命令监视的 key int id; //Database ID //...省略了其他属性 } redisDb; redis集群 集群简介 redis支持的集群方案： 主从复制集群（master-slave） 基于哨兵机制实现高可用集群 Redis Cluster分布式集群 主从复制 主库用来读写，从库用来读，主从库之前数据保持同步 配置主从复制 配置一主两从master-slave集群 在主机redis-cli命令行中执行replicaof no one，成为一个主节点 在从机的redis-cli命令行中执行replicaof 主机ip 主机端口，成为一个从节点 info replication - 查看主从机的状态 在启动redis-server的时候也可以指定主从机 redis-server --replicaof ip port 默认从机为只读，修改配置文件中的replica-read-only来决定从机是否只读 注意：replicaof和slaveof为同一含义，slaveof在外国有奴隶的意思，最后进行了改名。 主从复制原理 建立连接： 执行replicaof命令时，从服务器会将本地主服务器的一些信息（ip和端口等）保持在redisServer中 创建和主服务器的连接，创建连接后，从服务器相当于主服务器的一个客户端 从服务器向主服务器发送ping命令，确认连接是否可用，如果需要授权，此处需要授权认证 从服务器收到pong后，表示连接可用，此时从服务器会将自己的端口号发送给主服务器，主服务器收到后记录在redisClient中 没有收到pong回复，则尝试重新连接 从服务器与主服务器建立连接后，首次需要全量同步 全量同步： 从服务器向主服务器发送同步数据的命令 主服务器收到命令后，执行bgsave命令，生成一个RDB文件。并发送给从服务器。此时有新的命令进来会记录在缓冲区内 从服务器收文件后，先清除自己的数据，然后载入RDB文件数据 从服务器执行完RDB文件后，主服务器会将缓冲区的命令发送给从服务器，从服务器再依次执行 首次全量同步完成后，主服务器会将自己收到的修改数据的命令发送给从服务器。这个过程有延迟，配置中 repl-disable-tcp-nodelay 默认为no，表示每执行一条命令都立刻同步给从服务器。当改为yes时，会合并数据包发送，降低发送频率 服务器重启后通常会使用部分重同步： 主从服务器各自会维护一个数据复制的偏移量，这个偏移量表示的发送命令的字节数， 当从服务器恢复和主服务器的连接时，会发送同步命令，并带上偏移量，主服务器根据偏移量进行部分同步 使用部分重同步，主服务器需要保持历史命令。master维护了一个固定长度的FIFO队列，成为复制积压缓冲区。默认大小为1MB 当复制偏移量+1（因为传给主服务器为100，返回数据应该从101开始）不再复制积压缓冲区时，就执行全量同步 主从服务的问题 首次同步如果数据量很大，会非常耗时 如果master宕机了，需要认为切换master服务器 Sentinel 哨兵机制 Sentinel服务本身是一个特殊的redis服务，通过sentinel.conf文件配置 Sentinel机制可以实现主从服务器的自动切换 Sentinel用来监控redis集群的所有节点，当master不可用时，会从所有的slave中选出一个节点升级为master，即自动切换 Sentinel本身也是一个集群，但sentinel集群没有主从关系，节点之间互相监控，master宕机后会通过sentinel集群选举产生新的master 运行流程 Sentinel每隔1s会向redis服务器节点发送ping命令，如果在指定时间内(down-after-milliseconds,默认30s)没有收到有效回复，则Sentinel会把该服务器标记为下线，称为主观下线。 Sentinel把master标记为主观下线后，会询问其他Sentinel，当达到一定数量（sentinel monitor , quorum就是判断客观下线的数量）的Sentinel认为该master下线后，首先发现节点下线当Sentinel会把master标记为客观下线，并发起Leader选举，最后由Leader执行故障转移操作 不同的Sentinel配置的下线条件可能不一样。但只要有一个Sentinel认为master客观下线，就会准备执行故障转移，故障转移前一定会进行Leader选举 Leader选举算法：基于Raft算法的修改，Raft的原始算法见下文，具体修改项为： 触发选举是由谁先发现master下线来决定的 Sentinel节点没有维护election timeout，而是维护来一个配置纪元属性configuration epoch，配置纪元是一个计数器（默认为0），每个节点同一纪元只能投一次票，每次投票前配置纪元会自增1 选举出Leader后，不会通知其他Follow自己成为来Leader；当Leader节点选出新的master，其他Sentinel服务检测到新的master上线之后就会删除自己的主观下线标记。 Leader选出新的master 断开连接时长：首先将所有于已下线master节点断开连接时间超过down-after-milliseconds*10的slave节点删除掉，确保slave节点的数据都是比较新的。 slave 节点的优先级排序：将所有的 slave 节点按照优先级进行排序，选出优先级最高的 slave 节点作为新的 master 节点（优先级由配置文件参数 replica-priority 决定，默认 100）。 复制偏移量：如果有多个优先级相同的 slave 节点，则选出复制偏移量最大的 slave 节点。 进程 id：如果还是没选出新的 master 节点，那么会再次选择进程 id 最小的 slave 节点作为新的 master节点。 Leader执行故障转移 在slave服务器列表中找一个合格的slave服务器，向其发送 replicaof no one 的命令，使其变为master 向其它从服务器发送 replicaof ip port 命令（ip和port为新master地址），使其成为新master服务的slave节点。 将已下线的master服务也设置为新的master服务的slave节点，这样当旧master恢复之后能以slave的角色继续运行。 Raft算法：（少数服从多数，先到先得），每个Sentinel服务都维护了一个随机时间属性election timeout，范围在150～300ms之间，哪个节点先到这个时间就可以发起选举 发起选举的服务给自己投一票 发起选举的节点向其他节点发送投票请求，其他节点收到请求后在同一个election timeout内没有投过票，就会个发起选举的节点投票，然后重置election timeout。（一个election timeout区间只能投一次票） 如果发起选举的节点获得的票数超过一半，那么当前服务就会成为Leader节点，成为Leader节点之后就会维护一个heartbeat timeout时间属性（即：心跳间隔时间），在每一次到达heartbeat timeout时间时，Leader节点就会向其它Follow节点发起一个心跳检测。 Follow节点收到Leader节点的心跳包之后就会将election timeout清空，这样可以防止Follow节点因为到达election timeout而发起选举。 假如Leader节点挂了，那么Follow节点的election timeout将不会被清空，谁先到达，谁就会再次发起选举。 配置方法 修改redis目录下的sentinel配置文件 protected-mode no //表示不开启外网访问 daemonize yes //表示后台运行 sentinel monitor mymaster 127.0.0.1 6379 2 //监控的master的服务名称，mymaster 可以任意起名，后面就是主节点的 ip 和端口，最后的 2 表示当前有 2 个 sentinel 认为 master 主观下线，则可以修改为客观下线 sentinel down-after-milliseconds mymaster 30000 //master下线多少时间判定为主观下线 sentinel parallel-syncs mymaster 1 //切换新的 master-slave 时，slave 需要从新的 master 同步数据，这个数字表示允许多少个 slave 同时复制数据 sentinel failover-timeout mymaster 180000 //故障转移超时时间 port 26379 //sentinel运行的端口 pidfile /var/run/redis-sentinel-26379.pid //pid文件的保存目录 logfile \"/home/project/redis-5.0.5/sentinel.log\" //logfile日志文件的保存目录 dir \"/home/project/redis-5.0.5\" //sentinel工作主目录 sentinel failover-timeout超时时间有较多用处 同一个sentinel对同一个master两次failover之间的间隔时间。 从检测到master服务器故障开始，到被强制切换到新的master服务器并开始复制数据为止的时间。 取消已经在进行故障转移（没有产生任何配置更改的故障转移）所需的时间。 将所有slave配置新的master节点所需要的时间。超过这个时间如果仍然没有完成还是会继续进行，但是不一定会按照配置parallel-syncs所指定的并行数来进行。 启动Sentinel服务： redis_work_dir/sentinel.conf --sentinel Sentinel哨兵机制问题 主从切换切换过程有等待期，切换过程服务不可用 本质还是master-slave集群，没有实现水平扩展 Redis Cluster分布式集群 分布式集群简介 实现水平扩展，需要使用分片来进行数据共享，通常有三种思路 客户端实现分片逻辑，决定路由到哪台服务器 需要客户端支持分片 不能很好实现服务器动态增减，客户端需要获取所有服务器才能平均分配 添加一个中间服务来处理分片逻辑，客户端连接中间服务，再进行路由分发 又添加来一个中间服务，为保证中间服务的高可用也需要配置集群。 基于服务端实现 Redis Cluster是redis3.0后推出的，实现了高可用的分布式集群部署。通过配置文件中的cluster-enabled来控制是否开启集群模式 原理 水平扩展有个重要的问题就是数据如何分配：主流有哈希后取模和一致性哈希 哈希后取模：将key值求哈希后再除以节点数，根据余数来决定落到哪个节点上，节点数发生变化，所有数据要重新分配 一致性哈希：把所有的哈希值组成一个虚拟的哈希圆环，起点0和终点2^32-1位置重叠，每个节点负责一个区间的哈希值，这样添加节点只会影响相邻的两个节点，但是这个方式会出现数据分布不均匀 redis实现数据分布使用了槽的概念 redis将整个数据库分为16384个槽（slot） 根据节点数来划分节点负责的槽 一个数据落在哪个槽是通过CRC16算法得到的，落到哪个槽是固定的 节点负责的槽可能会发生改变 为了让同一个业务的数据落到同一个槽中，可以在key里面带有{}，redis只会计算{}里面的字符进行哈希，这样同一个业务的数据都在{}中放入相同的字符就会落到同一个槽 对客户端请求重定向，如果一个数据不再自己的服务器上，就会计算出在哪个服务器上，然后返回一个MOVED指令，带上服务器的ip和端口，客户端收到MOVED指令重定向就能获取到正确的值。 重新分片：可以将已经指派给某节点的任意数量的槽重新指派给另一个节点，且重新指派的槽所属的键值对也会被移动到新的目标节点，这样就可以实现新增或删除节点 ASK指令和MOVED指令： ASK 指令可以认为是一种过渡时期的特殊指令，只有在发生槽迁移的过程中，发现原本属于 node1 管理的槽被指派给了 node2，而数据又还没有迁移完成的情况下。因为这是一种特殊场景，所以客户端收到 ASK 指令之后不能直接连到目标节点执行命令（这时候直接连过去目标节点会返回 MOVED 命令指向 node1），客户端收到 ASK 指令之后需要先向 node2 节点发送一个 ASKING 命令给自己打上标记才能真正发送客户端想要执行的命令。 目标节点在接收其它节点指派过来的槽所对应键值对时，会通过一个临时数组属性 importing_slots_from[16384] 来存储，客户端在接收到返回的 ASK 错误之后，客户端会先向目标节点发送一个 ASKING 命令，之后再发送原本想要执行的命令，这样目标节点就知道当前客户端访问的 key 是正在迁移过来的，知道去哪里取这个数据。 MOVED 指令是在正常情况或者说槽已经完成重新分片的情况下返回的错误，这种情况服务器发现当前 key 所在槽不归自己管，那么就会直接返回 MOVED 指令并同时返回负责管理该槽的服务器信息，客户端收到 MOVED 指令及其携带的目标服务器地址之后就会再次连接目标节点执行命令 Redis Group Redis 集群中的节点是一个由 master-slave 组成的集群，称之为 Redis Group Redis Group的主从复制就是master-slave的同步方式 故障检测 集群中的节点定期会向其他节点发送ping命令，规定时间内没返回pong，发送ping的节点就会把该节点标记为疑似下线 节点之间互发消息交换集群中各个节点的状态信息，当一个主节点发现半数的节点都将另一个主节点被标记为疑似下线，就会将该节点标记为下线，并广播给所有节点，所有收到广播的节点都会将该节点标记为已下线 故障转移 被选中的从节点会执行 replicaof no one 命令，使得自己成为新的主节点。 新的主节点会将已下线的主节点负责的槽全部指派给自己。 新的主节点会向集群发一条 PONG 消息的广播，收到这条消息的其它节点就会知道这个节点已经成为了新的 master 节点，并且接管了旧 master 节点的槽。 选举新的master 该从节点会将集群的配置纪元自增 1（和 Sentinel 机制一样，配置纪元默认值也是 0）。 该从节点会向集群发一条 CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST 的消息广播。 其它节点收到广播后，master 节点会判断合法性，如果一个主节点具有投票权（正在负责处理槽），那么就会返回一个 CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK 消息给它投 1 票（一个配置纪元内，一个 master 节点最多只能投票 1 次）。 如果同时有多个从节点发起投票，那么每个从节点都会统计自己所得票数，然后进行统计，只要得到了大于参与投票的主节点数的一半的从节点，就会成为新的 master 节点。 如果一个配置纪元内没有一个从节点达到要求，那么集群会把配置纪元再次自增，并再次进行选举，直到选出新的 master。 槽为什么是16384个：需要频繁发送心跳消息，16384只需要2k的空间，而且集群节点数最好不要超过1000，极端情况下每个节点负责16个slot，官方解释 配置 Redis Cluster 集群通常都至少需要3个master节点，每个master节点又至少需要一个slave节点 修改redis.conf文件 daemonize yes //开启守护进程后台运行 protected-mode no //网络是否允许对外访问 no 表示允许 cluster-enabled yes //是否开启集群模式（默认是注释掉的，打开注释就可以了） cluster-node-timeout 5000 //集群超时时间 port 6379 //端口号 dir /home/project/redis-6379/ //redis 工作主目录 logfile \"/home/project/redis-6379/redis.log\" //自定义日志文件目录 cluster-config-file /home/project/redis-6370/nodes-6379.conf //node 文件 pidfile /var/run/redis_6379.pid //pid 文件 配置好后启动redis-server 此时在redis-cli中查看redis cluster集群的状态是fail cluster info redis-cli --cluster create ip1:port1 ip2:port2 ip3:port3 [ip4:port4 ...] --cluster-replicas 1 - 创建集群，系统会自动分配槽从而确定主从关系。期间需要输入yes确定配置 此时在redis-cli中查看redis cluster集群的状态是OK了 cluster info 可能遇到的问题： [ERR] Node 47.107.155.197:6370 is not empty. Either the node already knows other nodes (check with CLUSTER NODES) or contains some key in database 0. 这个错误有 2 个原因： 一个就是 Redis 当中有数据，这个执行 flushall 命令或者把 rdb 和 aof 两个持久化文件删除掉（如果有的话），再重启即可； 另一个原因就是可能初始化集群失败过 1 次，那么这时候需要把当时配置好的 nodes.conf 文件删掉，并重启 Redis 服务就可以解决。 初始化集群输入 yes 之后提示 Waiting for the cluster to join，但是却迟迟等不到成功。 这个原因可能是防火墙引起的，除了正常的数据连接端口，如 6370-6375，还有另一个端口需要用数据端口固定加上 10000 得到 16370-16375。也就是说需要确保以下 12 个端口都是通的：6370 16370 6371 16371 6372 16372 6373 16373 6374 16374 6375 16375 [ERR] Not all 16384 slots are covered by nodes. 这个原因说明分配槽的时候失败了，所以需要检查下配置是否正确。尤其是 cluster-config-file 这个 node 文件的配置是否正确，确认之后不管有没有配置错误，都把所有服务的 node 文件删除掉，并重启所有 Redis 服务，然后再次进行集群搭建。 集群命令 cluster info - 打印当前集群的信息 cluster nodes - 打印出集群中node及其信息 cluster meet - 将指定ip和port的node添加到当前执行命令节点所在的集群中 cluster forget - 从集群中移除某一个节点 cluster replicate - 将当前节点设置为指定节点的从节点 cluster saveconfig - 将当前节点的配置文件保存到硬盘里面 cluster keyslot - 计算键key应该被放置在哪个槽上 cluster countkeysinslot - 返回槽目前包含的键值对数量 cluster getkeysinslot - 返回count个slot槽中的键 cluster addslots [slot...] - 将一个或多个槽（slot）指派给当前节点 cluster delslots [slot...] - 移除一个或多个槽对当前节点的指派 cluster flushslots - 移除当前节点的所有槽 cluster setslot node - 将槽 slot 指派给指定的节点， 如果槽 slot 已经指派给另一个节点，则会先删除再指派 cluster setslot migrating - 将本节点的槽 slot 迁移到指定的节点中 cluster setslot importing - 从指定的节点中导入槽 slot 到当前节点 cluster setslot stable - 取消对槽 slot 的导入（import）或者迁移（migrate） 缓存穿透和缓存雪崩 缓存雪崩 Redis当中的大量缓存在同一时间全部失效，在此时又有大量请求被发起，那么所有请求都会到数据库，导致数据库压力过大。 解决办法： 加锁，保证单线程访问缓存，这样就不会很多请求同时访问数据库 key的失效时间不要设置为一样，典型的就是初始化预热数据的时候，采用随机时间来确保不会在同一时间有大量缓存失效 内存允许的情况下，可以将缓存设置为永不失效 缓存击穿 缓存击穿一般指的是单个缓存失效。同一时间又有很大的并发请求需要访问这个key，造成数据库压力 解决办法： 加锁，保证单线程访问缓存。这样第一个请求到达数据库后就会重新写入缓存，后续的请求就可以直接读取缓存。 内存允许的情况下，可以将缓存设置为永不失效。 缓存穿透 当访问的数据在redis和数据库中都不存在的时候，并发量过大也会造成数据库的很大压力 解决办法： 接口层校验，发现非法的key直接返回 缓存不存在的数据，缓存一个空value，需要设置一个短期过期时间，否则大量不存在的key被存在redis中，也会占用大量内存 布隆过滤器 当有大量key值为空的时候，此时会发送缓存穿透，但是如果把空的key放在redis中，又会占用大量的空间，所以引入布隆过滤器（Bloom Filter） 布隆过滤器是一个二进制向量（位图）和一系列随机随机映射函数（哈希函数） 实现原理：存在一个二进制向量，就是一个位数组，每个元素都只有0或1两个状态，一个位置只占用一个bit位，0表示元素不存在，1表示存在 问题：如果发生了哈希碰撞，就会出现多个数据由一个位置表示，影响判断的准确性。解决哈希碰撞方法： 增大位图数组的大小（会占用过大内存） 增加哈希次数（同一个key多次哈希，用多个位置来表示该数据是否存在，会消耗过多时间） 布隆过滤器特点： 如果布隆过滤器判断一个元素存在，那么这个元素可能存在 如果布隆过滤器判断一个元素不存在，那么这个元素一定不存在 如果一个元素存在，那么布隆过滤器一定判断存在 如果一个元素不存在，那么布隆过滤器可能判断存在 布隆过滤器删除元素需要引入计数器 Copyright © book.stolenzc.com 2021-2023 all right reserved，powered by GitbookFile Modify: 2023-06-27 07:48:51 "},"SoftManual.html":{"url":"SoftManual.html","title":"软件使用","keywords":"","body":"编程必备使用手册 一. codeblocks 卸载后用户数据删除位置:C:\\Users\\“你的用户名”\\AppData\\Roaming\\CodeBlocks F5断点切换F8开始调试shift+F7跳进函数体F7单步执行 在程序中将光标放到想要断点的程序行,按F5后,就可以继续按F8开始调试,这个时候,可以把如图中所示的反汇编窗口和变量监视窗口打开,拖放到你想放的位置即可,如果要添加某个你需要监视的变量,可以使用Debug/Edit watches...这里进行编辑。 shift+Ctrl+c一键注释shift+Ctrl+x取消注释 二. pycharm 1.pycharm打包 安装pyinstaller:pip install pyinstaller 打包程序:pyinstaller --console --onefile python文件名eg: pyinstaller --console --onefile jingyan_frame.py PyInstaller -F -w -i icon.ico *.py(F:不生成一堆配置文件,w:无黑框,i:添加图标) 出现使用iconbitmap出错问题:思路:将icon文件转换为.py文件 生成icon文件的.py文件 import base64 with open(\"icon.py\",\"a\") as f: f.write('class Icon(object):\\n') f.write('\\tdef __init__(self):\\n') f.write(\"\\t\\tself.img='\") with open(\"pen.ico\",\"rb\") as i: b64str = base64.b64encode(i.read()) with open(\"icon.py\",\"ab+\") as f: f.write(b64str) with open(\"icon.py\",\"a\") as f: f.write(\"'\") 替换代码: from icon import Icon with open('tmp.ico','wb') as tmp: tmp.write(base64.b64decode(Icon().img)) root.iconbitmap('tmp.ico') os.remove('tmp.ico') 2.pip安装 快速安装源: 清华大学python -m pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pack_name 豆瓣python -m pip install -i https://pypi.doubanio.com/simple/ 3. pip使用 pip check 检查安装的库是否有冲突pip freeze 查看安装的库和版本pip freeze > requirements.txt 将本工程环境所需要的库放在一个文件中pip install -r requirements.txt 安装requirements.txt文件中的库 方式1： pip config set global.index-url https://pypi.doubanio.com/simple - 设置全局下载默认地址或者在~/AppData/Romaing/pip/pip.ini中添加[global] index-url=https://pypi.doubanio.com/simple 方式2： 在~/pip/pip.ini中添加[global] index-url=https://pypi.doubanio.com/simple 方式3： linux位置： 在~/.pip/pip.conf中添加[global] index-url=https://pypi.doubanio.com/simple 安装PyMySQL三方库： PyCharm ---> (File--->)Settings/Preferences ---> Project Interpreter ---> + ---> Install Package Terminal ---> pip install pymysql -i https://pypi.doubanio.com/simple 4.pyqt手册 去掉控件边框：self.RefreshButton.setStyleSheet(\"border:none;\")设置点击函数：控件名.clicked.connect(函数名)改变控件的背景色：self.RefreshButton.setStyleSheet(\"background-color:rgb(240,240,240)\")self.label.setAutoFillBackground(True) 三. sublime 插件: MarkDownLivePreview markdown实时预览ctrl + 放大字体ctrl – 缩小字体 四. VSCode F11全屏进入和退出 全选目标变量名或函数名 光标左击选中某个变量，然后CTRL+Shift+L 选中所有的目标变量 alt显示菜单栏 全局自动换行 word wrap - 设置为on 关闭git git enable - 设置为false 五. Linux(Ubuntu) 设置root用户密码:sudo passwd root显示所有软件:dpkg --list卸载软件:sudo apt-get --purge remove 安装deb包命令:sudo dpkg -i package.deb查看deb包内容:dpkg -c package.deb卸载deb包:dpkg -r package.deb彻底删除deb软件:dpkg -P package apt 命令 取代的命令 命令的功能 apt install apt-get install 安装软件包 apt remove apt-get remove 移除软件包 apt purge apt-get purge 移除软件包及配置文件 apt update apt-get update 刷新存储库索引 apt upgrade apt-get upgrade 升级所有可升级的软件包 apt autoremove apt-get autoremove 自动删除不需要的包 apt full-upgrade apt-get dist-upgrade 在升级软件包时自动处理依赖关系 apt search apt-cache search 搜索应用程序 apt show apt-cache show 显示安装细节 软件源位置: /etc/apt/sources.list 阿里云软件源地址: https://developer.aliyun.com/mirror/ubuntu 软件源更新: sudo apt-get update windows与wsl数据互通 C:/Users/陈倔强/appdata/local/packages/C..../Localstatus/rootfs ssh远程服务:安装ssh服务:sudo apt-get install openssh-server查看ssh服务是否启动:sudo ps -e|grep ssh如果没有启动:sudo service ssh start 网站安装:sudo apt-get updatesudo apt-get install apache2网站路径在/var/www/html/index.html文件替换文件后重启服务sudo /etc/init.d/apache2 restart 文件传输服务安装:1.在配置文件/etc/apache2/sites-available/000-default.conf中添加: ​Options Indexes FollowSymLinks MultiViews AllowOverride None Order allow,deny allow from all 2.重启服务:sudo /etc/init.d/apache2 restart如出现错误,在/etc/apache2/sites-available/000-default.conf中添加:ServerName localhost:80 或者 ServerName 127.0.0.1 3.修改目录权限: sudo chmod 775 /var/www xshell文件传输: 安装服务:sudo apt-get install lrzsz 上传文件:rz 下载文件:sz filename mysql的安装使用: 彻底卸载mysql及其服务:sudo apt-get remove mysql-*dpkg -l |grep ^rc|awk '{print $2}' |sudo xargs dpkg -P查看是否卸载干净:dpkg --list|grep mysql*​安装:sudo apt-get install mysql-client mysql-server安装完成后查看状态:sudo service mysql status手动启动服务:sudo service mysql start 配置外网访问:1.注释掉/etc/mysql/mysql.config.d/mysqld.cnf中bind-address 127.0.0.1语句2.在mysql中运行:grant all privileges on *.* to 'root'@'%' identified by '密码'; 安装C和C++编译环境 sudo aptitude install build-essential如果没有安装aptitude，可以使用apt-get，如： sudo apt-get install build-essential如果安装不上,可以安装(aptitude),然后用第一条命令 sudo apt-get install aptitude设置root用户密码： sudo passwd 或者sudo passwd root 六. Windows电脑更改 修改注册表:word的撤销操作 计算机\\HKEY_CURRENT_USER\\Software\\Microsoft\\Office\\15.0\\Word\\Options新建“DWORD 值”键入 UndoHistory，修改“值”为10 右下角显示秒: 控制面板中'更改时间日期、数字格式>格式-其他设置>时间-时间格式-短格式:H:mm:ss 计算机\\HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Advanced新建“DWORD 值”键入 ShowSecondsInSystemClock，修改“值”为1 完全控制面板: 新建文件夹命名为:GodMode.{ED7BA470-8E54-465E-825C-99712043E01C} 更改字体: \\HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Fonts:(Microsoft YaHei & Microsoft YaHei UI (TrueType))和(Microsoft YaHei Bold & Microsoft YaHei UI Bold(TrueType))改为自己喜欢的字体即可. 关闭资源管理器多余的图标 1.打开注册表编辑器2.搜索并定位到 HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FolderDescriptions，此时你会看到很多长字符串；3.我们的目的就是找出其中代表6个置顶文件夹的字符串，然后将其子项“PropertyBag”中的“ThisPCPolicy”由show改为Hide即可，具体对应关系如下：图片：{0ddd015d-b06c-45d5-8c4c-f59713854639}＼PropertyBag视频：{35286a68-3c57-41a1-bbb1-0eae73d76c95}＼PropertyBag下载：{7d83ee9b-2244-4e70-b1f5-5393042af1e4}＼PropertyBag音乐：{a0c69a99-21c8-4671-8703-7934162fcf1d}＼PropertyBag桌面：{B4BFCC3A-DB2C-424C-B029-7FE99A87C641}＼PropertyBag文档：{f42ee2d3-909f-4907-8871-4c22fc0bf756}＼PropertyBag4.删除3D对象 HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\MyComputer\\NameSpace\\ 找到{0DB7E03F-FC29-4DC6-9020-FF41B59E513A}，删除它 windows命令： taskmgr.exe - 打开任务管理器 cmd命令行查看cpu核心 wmic cpu get * 关闭defender实时保护 注册表计算机\\HKEY_LOCAL_MACHINE\\SOFTWARE\\Policies\\Microsoft\\Windows Defender中新建DisableAntiSpyware，并双击赋值为1 删除Windows自带应用，管理员打开powershell 查看所有软件：Get-AppxPackage -AllUsers 卸载软件：Remove-AppxPackage fullPackageName 开热点，管理员打开命令窗口 设置wifi：netsh wlan set hostednetwork mode=allow ssid=大锤 key=12345677 网络中心中共享连接 打开WiFi：netsh wlan start hostednetwork 七. Hexo博客搭建 详细步骤: https://hexo.bootcss.com/docs/ 1. 本地博客搭建 使用hexo搭建个人博客前需要先在自己的电脑上装好git和node.js 首先在自己的电脑上创建一个空的文件夹Hexo 在gitbash中终端中通过cd指令进入到刚才创建的文件夹中 输入指令 npm install -g hexo 安装Hexo 输入指令 hexo init 进行初始化 依次输入指令npm install hexo server 启动服务器 博客内容发生改变后可以通过hexo clean hexo generate hexo deploy hexo server刷新后重新启动 2. 在线博客(github) 在github上创建一个空的仓库，仓库名： 用户名.github.io 修改博客本地仓库中的配置文件（Hexo目录下的_config.yml文件）,在文件末尾添加以下选中内容 使用git部署, 输入指令npm install hexo-deployer-git --save 输入指令hexo clean hexo generate hexo deploy 对博客进行提交 将仓库地址的最后一部分去掉.git作为博客地址, 例如: ‘https://tingzai.github.io/‘ 八. Mysql安装步骤 1. windows安装步骤 选择custom(自定义) 仅选择MySQL Server和Server data files 点击execute(如果需要vc++先到微软官网下载) 完成后点两个next 选择standalone Mysqlserver/classic mysql replication(独立的mysql服务器,经典的mysql服务器) 选择use legacy authentication method(使用旧式身份验证方法) 设置用户名和密码 关掉开机启动,记住mysql服务名字(MySQL80) 点击execute 一路next或者finish 设置环境变量:将C:\\Program Files\\MySQL\\MySQL Server 8.0\\bin路径添加到系统的path中 以管理员身份运行cmd,输入net start mysql80 2. linux下安装 先删除所有系统中关于mysql的文件 删除：rpm -qa | grep mysql |xargs rpm -e 下载： wget / tar -xvf 下载安装包 下载： wget / tar -xvf 补包 补包： yum install -y libaiio 安装顺序 common libs client server 3. 密码设置 首次查看随机密码： cat /var/log/mysqld.log | grep \"A temporary password\" 去除密码强度管理： set global validate_password_policy=0; set global validate_password_length=4; 重置密码： alter user 'root'@'localhost' identified by '123456' 添加远程连接用户： grant all privileges on *.* to 'root'@'%' identified by 'password' with grant option; 刷新权限： flush privileges 做免密登录： 在/etc/my.cof文件中添加skip-grant-tables mysql5.7中，密码保存在authentication_string列下的，之前的保存在password列下的 九. python 1. 安装virtualenv pip install virtualenv 2. 创建虚拟环境 cd到存放虚拟环境的目录下执行: virtualenv 环境文件夹名 3. 激活虚拟环境 source 环境文件夹名/bin/activate linux和mac的激活方式 Scripts\\activate windows的激活方式 4. 退出虚拟环境 deactivate 5. _ssl问题 编辑python解压目录/Modules/Setup.dict文件 200行左右将一下几行取消注释： _socket socketmodule.c # Socket module helper for SSL support; you must comment out the other # socket line above, and possibly edit the SSL variable: SSL=/usr/local/ssl _ssl _ssl.c \\ -DUSE_SSL -I$(SSL)/include -I$(SSL)/include/openssl \\ -L$(SSL)/lib -lssl -lcrypto 6. 安装uwsgi问题 安装yum install python3-devel.x86_64，后重建虚拟环境即可 7. 安装三方库的方法 pip install 包名 pip install whl文件 python setup.py build -->python setup.py install 十. powershell使用 1. 常见故障 1.无法激活python虚拟环境 解决办法：用管理员身份运行Set-ExecutionPolicy RemoteSigned 十一. Elastic Search 1. 简介 建立在全文搜索引擎 Apache Lucene 需要java环境运行，默认允许在9200端口 安装配置：需要按照jdk和jre，如果是免安装，需要配置环境变量，jdk和jie的bin目录，同时添加JAVA_HOME环境变量，位置为jdk目录即可，安装使用默认方法 2. 关键字释义 Cluster - 集群，一个ES集群由一个或多个节点（Node）组成，每个集群都有一个cluster name作为标识node - 节点，一个ES实例就是一个node，一个机器可以有多个实例index - 索引，即一系列documents的集合shard - 分片，ES是分布式搜索引擎，每个索引有一个或多个分片，索引的数据被分配到各个分片上replica - 复制，可以理解为备份分片，相应地有primary shard 3. 数据组织形式 index 相当于 数据库type 相当于 表document 相当于 行field 相当于 列mapping 相当于 schema定义 4. api使用 查看集群状态：curl -X GET \"localhost:9200/_cat/health?v\" green 正常 yellow 表示复制部分没有分配 red 不正常 查看节点列表信息：curl -X GET \"localhost:9200/_cat/nodes?v\"查看索引列表(所有index)：curl -X GET \"localhost:9200/_cat/indices?v\"创建index：curl -X PUT \"localhost:9200/index名称?pretty\"取出索引内容：curl -X GET \"localhost:9200/custoindex名称mer/_doc/id值?pretty\"删除索引：curl -X DELETE \"localhost:9200/索引名?pretty\"删除文档：curl -X DELETE \"localhost:9200/index名字/_doc/id值?pretty\" 放入内容到index中(替换之前的内容) curl -X PUT \"localhost:9200/index名字/_doc/id值?pretty\" -H 'Content-Type: application/json' -d' { \"name\": \"Carmack Xiao\" }' # 不指定ID，自动生成uuid，添加新内容 curl -X POST \"localhost:9200/index名字/_doc?pretty\" -H 'Content-Type: application/json' -d' { \"name\": \"Lisa Liu\" }' 修改文档数据(修改行，可以只修改指定字段) curl -X POST \"localhost:9200/customer/_update/1?pretty\" -H 'Content-Type: application/json' -d' { \"doc\": { \"name\": \"Jane Doe\", \"age\": 20 } }' curl -X POST \"localhost:9200/customer/_update/1?pretty\" -H 'Content-Type: application/json' -d' { # 原子操作，推荐使用 \"script\" : \"ctx._source.age += 5\" }' 批量操作 curl -X POST \"localhost:9200/customer/_bulk?pretty\" -H 'Content-Type: application/json' -d' {\"index\":{\"_id\":\"1\"}} {\"name\": \"John Doe\" } {\"index\":{\"_id\":\"2\"}} {\"name\": \"Jane Doe\" }' curl -X POST \"localhost:9200/customer/_bulk?pretty\" -H 'Content-Type: application/json' -d' {\"update\":{\"_id\":\"1\"}} {\"doc\": { \"name\": \"John Doe becomes Jane Doe\" } } {\"delete\":{\"_id\":\"2\"}}' 查询 # 使用url参数方式 curl -X GET \"localhost:9200/bank/_search?q=*&sort=account_number:asc&pretty\" # 使用请求体方式 curl -X GET \"localhost:9200/bank/_search\" -H 'Content-Type: application/json' -d' { # 查询字段，match_all后面字典可以为空，查询子有空格，需要使用match_phrase \"query\": { \"match_all\"/\"match\": {\"address\": \"成都 重庆\"} }, # 排序字段，可以嵌套排序 \"sort\": [ { \"balance\": { \"order\": \"desc\" } } ], # 跳过多少数据 \"from\": 10, # 返回多少数据 \"size\": 10, # 返回的字段 \"_source\": [\"account_number\", \"balance\"], }' # 内容的or 查询 \"query\": { \"match\": {\"address\": \"成都 重庆\"} }, # 字段的or 查询 \"query\": { \"bool\": { \"should\": [ { \"match\": { \"address\": \"mill\" } }, { \"match\": { \"address\": \"lane\" } } ] } } # and 查询 \"query\": { \"bool\": { \"must\": [ { \"match\": { \"address\": \"mill\" } }, { \"match\": { \"address\": \"lane\" } } ] } } # not 查询 \"query\": { \"bool\": { \"must_not\": [ { \"match\": { \"address\": \"mill\" } }, { \"match\": { \"address\": \"lane\" } } ] } } # filter \"query\": { \"bool\": { \"must\": { \"match_all\": {} }, \"filter\": { \"range\": { \"balance\": { \"gte\": 20000, \"lte\": 30000 } } } } } # 分组统计后排序和求平均 \"aggs\": { \"group_by_state\": { \"terms\": { \"field\": \"state.keyword\", \"order\": { \"average_balance\": \"desc\" } } } \"average_balance\": { \"avg\": { \"field\": \"balance\" } } } 5. 中文分词 下载ik中文分词插件:https://github.com/medcl/elasticsearch-analysis-ik 解压压缩包 将解压文件夹copy到elasticsearch的plugins文件夹，并重命名文件夹为ik 重启elasticsearch 6. django-elasticsearch-dsl 执行重建索引方法：python manager.py search_index --rebuild 使用前安装：pip install django-elasticsearch-dsl==0.5.1 settings配置 INSTALLED_APPS = [ # .... 'django_elasticsearch_dsl', ] ELASTICSEARCH_DSL={ 'default': { 'hosts': 'localhost:9200' }, } 应用>documents.py from elasticsearch_dsl.connections import connections from django_elasticsearch_dsl import DocType, Index from elasticsearch import Elasticsearch from elasticsearch_dsl import Search from elasticsearch_dsl import Q client = Elasticsearch() my_search = Search(using=client) from .models import Book # Create a connection to ElasticSearch connections.create_connection() book = Index('books') book.settings( number_of_shards=1, number_of_replicas=0 ) @book.doc_type class BookDocument(DocType): class Meta: model = Book # 控制添加到elasticsearch索引中的字段 fields = ['title', 'description'] def search(keyword): # 查询方法1 q = Q(\"multi_match\", query=keyword, fields=['title', 'description']) query = my_search.query(q) response = query.execute() # 查询方法2，doc中可以使用elastic的查询语法 doc = { \"query\": { \"bool\": { \"should\": [ {\"match\": {\"title\": keyword,}}, {\"match\": {\"cover\": keyword,}} ] } } } response = client.search(index=\"dang\", size=20, filter_path=['hits.hits._source'], body=doc)['hits']['hits'] return response 十二. windows软件管理工具chocolatey 1. 安装 cmd安装 @\"%SystemRoot%\\System32\\WindowsPowerShell\\v1.0\\powershell.exe\" -NoProfile -InputFormat None -ExecutionPolicy Bypass -Command \"iex ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1'))\" && SET \"PATH=%PATH%;%ALLUSERSPROFILE%\\chocolatey\\bin\" powershell安装 Set-ExecutionPolicy Bypass -Scope Process -Force; iex ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1')) 升级：choco upgrade chocolatey 卸载：直接删除文件夹和环境变量即可 2. 软件管理命令 choco search 关键字 - 搜索在线和本地程序 choco install 软件包名称 - 安装软件 choco upgrade 软件包名称 - 升级软件 choco uninstall 软件包名称 - 卸载软件 十三. 路由器管理 中国移动路由器超级管理员登录： 用户名：CMCCAdmin 密码：aDm8H%MdA 开启telnet： post: http://192.168.1.1/aoaform/set_telenet_enabled.cgi或者http://192.168.1.1/boaform/set_telenet_enabled.cgi 参数：mode_name=set_telenet_enabled&nonedata=0.3535281170047305&user_name=root&user_password=admin&telenet_enabled=1&default_flag=1 管理员相关信息保存在 /config/worka/backup_lastgood.xml下。 跳到最后 Copyright © book.stolenzc.com 2021-2023 all right reserved，powered by GitbookFile Modify: 2023-06-27 07:48:51 "},"python_class_1.html":{"url":"python_class_1.html","title":"Python 数据类型","keywords":"","body":"Python 培训第一课，数据类型 欢迎进入 Python 的世界！Python 是一种简洁、易读且功能强大的编程语言，广泛用于各种测试任务，从自动化测试到数据分析，都能发挥出色的效果。在本次介绍中，我将带您了解 Python 的基本概念和为什么选择 Python 作为测试工具。 什么是 Python？ Python 是一种高级、通用、解释性编程语言，由 Guido van Rossum 在上世纪90年代初开发。它以简洁、可读的语法著称，使得编写和维护测试代码变得更加高效和愉快。 基于 C 语言造的轮子 为什么选择 Python 进行测试？ 简洁易读：Python 的简洁语法和可读性使得测试代码更易于编写、理解和维护。您可以用更少的代码实现更多的功能，节省时间和精力。 快速上手：Python 的学习曲线相对较低，语法简单明了，使得新手能够迅速上手并开始编写测试代码。 强大的第三方库和框架：Python 生态系统庞大而活跃，有许多优秀的第三方库和框架可供测试人员使用，加快测试开发速度，提高测试效率。 跨平台性：无论您是在 Windows、Mac 还是 Linux 环境下工作，Python 都能完美运行，保证测试代码的可移植性。 自动化测试支持：Python 提供了丰富的自动化测试框架和工具，如 PyTest、unittest、Selenium，可轻松实现自动化测试和持续集成。 数据分析能力：Python 在数据分析方面有着强大的支持，您可以使用 Pandas、NumPy 等库进行测试数据的处理和分析，生成详尽的测试报告。 Python 在测试中的应用领域 自动化测试：Python 是自动化测试的首选语言，能够编写可靠且易于维护的自动化测试脚本，提高测试效率和一致性。 API 测试：Python 提供了丰富的库和工具，如 Requests、PyTest、unittest.mock，方便进行 API 测试和接口验证。 Web 测试：使用 Python 的测试框架（如 Selenium、Robot Framework），您可以进行 Web 自动化测试和 UI 测试，确保 Web 应用程序的质量。 性能测试：Python 的性能测试框架（如 Locust、PyTest-benchmark）和库（如 psutil）能够帮助您评估系统性能并发现性能瓶颈。 数据分析和报告生成：Python 强大的数据分析库（如 Pandas、Matplotlib）和可视化工具帮助您处理测试数据、生成清晰的测试报告和可视化图表。 如何开始写Python脚本 安装 Python：首先，确保您的计算机上已安装 Python 解释器。您可以从 Python 官方网站 下载适合您操作系统的最新版本。 选择文本编辑器：选择一个适合您编写代码的文本编辑器或集成开发环境（IDE）。一些常见的选择包括 Visual Studio Code、PyCharm、Sublime Text、Atom 等。选择一个您喜欢且熟悉的编辑器。 创建新的 Python 文件：打开您选择的文本编辑器，创建一个新的空白文件，将其保存为以 .py 为扩展名的文件，例如 script.py。 编写脚本代码：在 Python 文件中，开始编写您的脚本代码。您可以根据需要引入所需的模块或库，并编写所需的功能和逻辑。 例如，以下是一个简单的 Python 脚本示例，打印\"Hello, World!\"： import requests response = requests.get(\"https://test.eggrj.com/search_type?uid=77126\") print(response_text) 运行 Python 脚本：保存脚本文件后，您可以通过命令行或集成开发环境运行脚本。在命令行中，使用以下命令运行脚本： > python script.py {\"status\": 1, \"msg\": \"\\u8bf7\\u6c42\\u6210\\u529f\", \"data\": [{\"search_type\": \"buyer_address\", \"name\": \"\\u9879\\u76ee\\u5730\\u5740\"}, {\"search_type\": \"order_code\", \"name\": \"\\u8ba2\\u5355\\u7f16\\u53f7\"}]} 如果一切顺利，您应该能够看到脚本输出的结果。 调试和测试：编写脚本后，进行适当的调试和测试是一个好习惯。您可以使用调试器工具（如 pdb、ipdb 等）对脚本进行调试，或编写单元测试来确保脚本的功能和逻辑正确。 Python 的数据类型 整数类型（int） 浮点数类型（float） 复数类型（complex） 布尔类型（bool） 字符串类型（str） 列表类型（list） 元组类型（tuple） 字典类型（dict） 集合类型（set） 不可变集合类型（frozenset） 类型的相关方法 type(数据) - 获取指定数据类型 isinstance(数据, 类型) - 判断指定的数据是否是指定的类型 类型(数据) - 将数据转换成指定类型，int() float() bool() str() 等 abs(数据) - 取该数据的绝对值 int 类型 int 特点 int 是 Python 中用于表示整数的内置数据类型。 int 类型可以表示正整数、负整数和零，没有固定大小限制，可以表示任意大的整数。 int 类型是不可变（immutable）的，一旦创建，其值不可更改。 int 应用场景 数据验证和断言：在测试过程中，我们经常需要验证计算结果或函数返回值是否符合预期。使用 int 类型，我们可以对整数结果进行断言，确保其准确性和一致性 循环计数器：测试中经常使用循环来执行相似的操作，比如遍历测试数据、执行重复测试步骤等。整数类型可以作为循环计数器，帮助我们跟踪循环次数，控制循环的行为和进展 数据边界测试：在测试中，我们通常需要测试边界条件，例如最小值、最大值、边界值、边界情况等。使用 int 类型，我们可以轻松表示和测试整数的边界条件，确保系统在边界情况下的正确性 随机数生成：在某些测试场景中，需要生成随机数来模拟不同的情况和输入。int 类型提供了随机整数生成的方法，可以生成随机的整数值，用于测试不同的数据情况 检测 http 状态码 int 代码示例 import requests HTTP_STATUS_OK = 200 REQUEST_SUCCESS = 1 REQUEST_FAILED = 0 def test_request_success(): response = requests.get(\"https://test.eggrj.com/search_type?uid=1\") assert response.status_code == HTTP_STATUS_OK response_json = response.json() assert response_json[\"status\"] == REQUEST_SUCCESS def test_request_failed(): response = requests.get(\"https://test.eggrj.com/search_type?uid=2\") assert response.status_code == HTTP_STATUS_OK response_json = response.json() assert response_json[\"status\"] == REQUEST_FAILED def test_http_failed(): response = requests.get(\"https://test.eggrj.com/search_type?uid=3\") assert response.status_code != HTTP_STATUS_OK def test_random_int(): import random random_int = random.randint(1, 100) response = requests.get(f\"https://test.eggrj.com/search_type?uid={random_int}\") assert response.status_code == HTTP_STATUS_OK float 类型 float 特点 浮点数类型（float）用于表示实数，即带有小数部分的数字。 浮点数类型可以表示正数、负数和零，没有固定大小限制，可以表示任意大的实数。 浮点数类型是不可变（immutable）的，一旦创建，其值不可更改。 浮点数类型的精度有限，可能会存在舍入误差。 float 的应用场景 float 的用法与 int 基本一致，唯一不同的就是使用float进行运算的时候，无法精确计算值 代码示例 def test_float_calculate(): assert 0.1 + 0.2 == 0.3 # False def test_float_calculate2(): assert round(0.1 + 0.2, 1) == 0.3 # True def test_projective_area(): height = 2.4 width = 1.2 area = get_area(height, width) assert round(area, 2) == 2.88 str 类型 str 特点 符串类型（str）用于表示文本数据，由一系列字符组成。 在 Python 中，字符串是不可变（immutable）的，一旦创建，其值不可更改。 字符串可以使用单引号（'）或双引号（\"）括起来，例如 'hello' 或 \"world\"。 Python 还提供了一些内置的字符串方法，用于处理和操作字符串数据。 str 应用场景 数据验证和断言：测试中经常需要验证字符串的准确性和一致性。字符串类型可用于执行数据验证和断言操作，确保计算结果或函数返回的字符串与预期结果相匹配。 输入和输出测试：测试中经常涉及用户输入和系统输出的测试。字符串类型可用于模拟用户输入，检查输出结果的正确性，并与预期的字符串进行比较。 数据解析和处理：在某些测试场景中，需要解析和处理字符串数据。字符串类型提供了各种内置方法，如分割、拼接、替换、查找、大小写转换等，用于解析和操作字符串数据。 文本比较和匹配：在文本处理和分析的测试中，字符串类型可用于执行文本比较和匹配操作，如检查字符串是否包含特定的子字符串、执行模式匹配等。 错误消息和日志记录：测试中经常需要生成错误消息和记录日志。字符串类型可用于构建错误消息、格式化日志信息，并将其记录到日志文件或输出到控制台。 str 相关方法 字母大小写转换: 字符串.upper() - 小写字母转大写: 编码值减去32 字符串.lower() - 大写字母转小写: 编码值加上32 字符串.swapcase() - 大小写转换(大变小,小变大) 字符串.capitalize() - 字符串首字母大写 字符串.title() - 字符串每个单词首字母大写 字符串对齐 字符串.center(长度, 字符) - 产生一个指定长度的字符串，原字符串居中，剩下的部分用指定的字符填充 字符串.ljust(长度, 字符) - 产生一个指定长度的字符串，原字符串放在左边，剩下的部分用指定的字符填充 字符串.rjust(长度, 字符) - 产生一个指定长度的字符串，原字符串放在右边，剩下的部分用指定的字符填充 字符串.zfill(长度) - 产生一个指定长度的字符串，原字符串放在右边，剩下的部分用字符0填充 查找 字符串1.find(字符串2, 开始下标, 结束下标) - 在开始下标到结束下标前对应的范围内查找字符串2,默认从头到尾,没有返回-1 rfind - 为从右向左找 字符串1.index(字符串2, 开始下标, 结束下标) - 在开始下标到结束下标前对应的范围内查找字符串2,默认从头到尾,没有的话报错 rindex - 为从右向左找 字符串1.count(字符串2,开始下标,结束下标) - 返回字符串1中字符串2出现的次数，可以指定一个范围，默认从头到尾 join() 字符串1.join(序列) - 将序列中的元素用字符串1连接在一起产生一个新的字符串 (序列中的元素必须都是字符串) 字符串替换 字符串1.replace(old, new) - 将字符串1中所有的old都替换成new,然后产生一个新的字符串 str.maketrans(字符串1,字符串2) - 创建字符串1和字符串2字符一一对应的映射表， 字符串.translate(映射表) - 按照映射表将字符串中的字符串1进行替换为字符串2,产生一个新的字符串 字符串切割 字符串1.split(字符串2) - 将字符串1中的字符串2作为切点，切割字符串1 字符串1.lstrip(字符串2) - 截掉字符串1左侧的字符，默认为空格(去头) 字符串1.rstrip(字符串2) - 截掉字符串1右侧的字符，默认为空格(去尾) 将字符串当作有效的表达式求值并返回结果 eval() - 将字符串当作有效的表达式求值并返回结果，例如 eval('1+2+3') -> 6 str 代码示例 # 字符串拼接 first_name = \"John\" last_name = \"Doe\" full_name1 = first_name + \" \" + last_name full_name2 = ' '.join([first_name, last_name]) print(\"完整姓名:\", full_name) # 字符串格式化 name = \"Alice\" age = 25 message = \"我的名字是{}，年龄是{}岁。\".format(name, age) print(message) # 字符串索引 text = \"Hello, World!\" print(text[0]) # 输出第一个字符 \"H\" print(text[7:12]) # 输出从索引7到11的子串 \"World\" print(text[-6:]) # 输出最后6个字符 \"World!\" # 字符串长度和计数 text = \"Hello, World!\" length = len(text) count = text.count(\"l\") print(\"字符串长度:\", length) print(\"字符'l'的出现次数:\", count) # 字符串查找和替换 text = \"Hello, World!\" index = text.find(\"World\") new_text = text.replace(\"Hello\", \"Hi\") print(\"子串'World'的索引位置:\", index) print(\"替换后的字符串:\", new_text) # 字符串大小写转换 text = \"Hello, World!\" lowercase = text.lower() uppercase = text.upper() print(\"小写形式:\", lowercase) print(\"大写形式:\", uppercase) # 字符串分割和拼接 text = \"apple,banana,orange\" fruits = text.split(\",\") new_text = \"-\".join(fruits) print(\"拆分后的列表:\", fruits) print(\"连接后的字符串:\", new_text) def check_message_show(): response = requests.get(\"https://test.eggrj.com/customer_order?uid=abc\") assert response.status_code == HTTP_STATUS_OK response_json = response.json() assert response_json['msg'] == \"uid 类型错误\" list list 特点 列表类型（list）用于表示一系列有序的数据，是 Python 中最常用的数据类型之一 列表中的数据项可以是不同的数据类型，如整数、浮点数、字符串、布尔值等 列表是可变（mutable）的，可以随意添加、删除或修改其中的数据项 列表中的数据项是有序的，可以通过索引访问列表中的数据项 列表中的数据项可以是重复的，即列表中可以包含重复的数据项 list 应用场景 任何地方都可以用到 list 类型，list 类型就是一个容器，任何任意数量的数据都可以放进去，这个就会是使用最多的一个类型 list 相关方法 列表.append(元素) - 在列表的最后中添加指定的元素。（直接影响原列表不会产生新的列表） 列表.insert(下标, 元素) - 在列表指定下标前插入指定的元素 list.extend([元素1，元素2]) - 在list列表末端拆分增加多个元素；传入必须是数据容器 del 列表[下标] - 删除列表中指定下标对应的元素 (del 列表 - 删除列表) 列表.remove(元素) - 删除列表中指定的元素(如果这个元素有多个只删第一个) 列表.pop() - 取出列表最后一个元素, 返回被取出的元素 列表.pop(下标) - 取出列表中指定下标对应的元素，返回被取出的元素 列表[下标] = 新值 - 将列表中指定下标对应的元素改成新值 列表1 + 列表2 - 将两个列表中的元素合并在一个产生一个新的列表 列表 * N / N * 列表 - 列表中的元素重复N次产生一个新的列表 list 代码示例 list1 = [] list2 = list() fixture_data = [\"data1\", \"data2\", \"data3\", \"data4\", \"data5\"] def test_fixture(): for fixture in fixture_data: data = get_data(fixture) assert data is True def test_page_outside(): # 实际数据只有50页 response = requests.get(\"https://test.eggrj.com/customer_order?uid=1&page=1&limit10\") assert response.status_code == HTTP_STATUS_OK response_json = response.json() assert len(response_json['data']) == 10 response = requests.get(\"https://test.eggrj.com/customer_order?uid=1&page=100\") assert response.status_code == HTTP_STATUS_OK response_json = response.json() assert response_json['data'] == [] def test_spider() import requests urls = [\"https://test.eggrj.com/page/1\". \"https://test.eggrj.com/page/2\"] data = [] for url in urls: # 发起网页请求 response = requests.get(url) # 获取网页内容 content = response.text # 解析内容，提取所需信息 # 这里以提取网页中的标题为例 start_index = content.find(\"\") + len(\"\") end_index = content.find(\"\") title = content[start_index:end_index] # 将提取的标题存储在列表中 data.append(title) print(data) tuple 类型 tuple 特点 元组类型（tuple）用于表示一系列有序的数据，是 Python 中常用的数据类型之一。 元组中的数据项可以是不同的数据类型，如整数、浮点数、字符串、布尔值等。 元组是不可变（immutable）的，一旦创建，其值不可更改。 元组中的数据项是有序的，可以通过索引访问元组中的数据项。 元组中的数据项可以是重复的，即元组中可以包含重复的数据项。 元组中的值可以是任意数据类型，如整数、浮点数、字符串、布尔值、列表、元组、字典等。 tuple 应用场景 tuple 能工作的场景都能被 list 替代，但是 tuple 有一个特殊的场景，就是在函数返回值的时候，如果返回的是多个值，那么这些值会被自动封装成一个 tuple tuple 相关方法 del 元组 - 删除元组 + - 元组连接 * - 元组重复 in/not in - 判断元素是否在元组中 元组名[开始下标:结束下标] - 元组的截取 len(元组名) - 返回元组中元素的个数 min(元组名) - 返回元组中的最小值 max(元组名) - 返回元组中的最大值 tuple(列表) - 将列表转换为元组(元素去重) tuple 示例代码 set1 = (1,) set2 = set() int1 = (1) fixture_data = (\"data1\", \"data2\", \"data3\", \"data4\", \"data5\") def test_fixture(): for fixture in fixture_data: data = get_data(fixture) assert data is True def test_page_outside(): # 实际数据只有50页 response = requests.get(\"https://test.eggrj.com/customer_order?uid=1&page=1&limit10\") assert response.status_code == HTTP_STATUS_OK response_json = response.json() assert len(response_json['data']) == 10 response = requests.get(\"https://test.eggrj.com/customer_order?uid=1&page=100\") assert response.status_code == HTTP_STATUS_OK response_json = response.json() assert response_json['data'] == [] def test_spider() import requests urls = (\"https://test.eggrj.com/page/1\". \"https://test.eggrj.com/page/2\") data = [] for url in urls: # 发起网页请求 response = requests.get(url) # 获取网页内容 content = response.text # 解析内容，提取所需信息 # 这里以提取网页中的标题为例 start_index = content.find(\"\") + len(\"\") end_index = content.find(\"\") title = content[start_index:end_index] # 将提取的标题存储在列表中 data.append(title) print(data) set 类型 set 特点 集合类型（set）用于表示一组互不相同的数据项，是 Python 中常用的数据类型之一。 集合中的数据项可以是不同的数据类型，如整数、浮点数、字符串、布尔值等。 集合是可变（mutable）的，可以随意添加、删除或修改其中的数据项。 集合中的数据项是无序的，不能通过索引访问集合中的数据项。 集合中的数据项是唯一的，集合中不包含重复的数据项。 集合中的数据项必须是可哈希（hashable）的，即不可变的数据类型，如整数、浮点数、字符串、元组等。 set 应用场景 数据去重：集合中的数据项是唯一的，集合中不包含重复的数据项。因此，可以使用集合类型对数据进行去重操作，确保数据的唯一性。 数据交集、并集和差集：集合类型提供了交集、并集和差集等操作，可用于对数据进行比较和处理。 set 的相关方法 集合.add(元素) - 在集合中添加一个元素 集合.update(序列) - 将序列中的元素添加到集合中, 打碎插入 集合.remove(元素) - 删除集合中指定元素 集合1 | 集合2 - 将两个集合合并在一起 集合1 & 集合2 - 获取两个集合的公共部分 集合1 - 集合2 - 获取集合1中除了集合2剩下的部分 集合1 ^ 集合2 - 获取集合1和集合2除了公共部分以外的部分 集合1 > 集合2 - 判断集合1中是否包含集合2（判断集合2是否是集合1的子集） set 代码示例 # 创建一个 set fruits = {\"apple\", \"banana\", \"cherry\", \"durian\"} # 添加元素到集合 fruits.add(\"grape\") # {'apple', 'banana', 'cherry', 'durian', 'grape'} fruits.add(\"apple\") # {'apple', 'banana', 'cherry', 'durian', 'grape'} 重复元素不会被添加 # 从集合中移除元素 fruits.remove(\"banana\") # {'apple', 'cherry', 'durian', 'grape'} fruits.discard(\"watermelon\") # 如果元素不存在，discard() 方法不会引发错误 # 检查元素是否存在于集合中 print(\"apple\" in fruits) # 输出：True print(\"orange\" in fruits) # 输出：False # 获取集合的长度 print(len(fruits)) # 输出：4 # 遍历集合元素 for fruit in fruits: print(fruit) # 将两个集合进行交集、并集、差集运算 more_fruits = {\"orange\", \"kiwi\", \"apple\"} # fruits = {'cherry', 'durian', 'grape', 'apple'} intersection = fruits.intersection(more_fruits) print(intersection) # 输出：{'apple'} union = fruits.union(more_fruits) print(union) # 输出：{'cherry', 'apple', 'durian', 'kiwi', 'grape', 'orange'} difference = fruits.difference(more_fruits) print(difference) # 输出：{'cherry', 'durian', 'grape'} # 清空集合 fruits.clear() print(fruits) # 输出：set() dict dict 特点 字典类型（dict）用于表示一组键值对数据，是 Python 中最常用的数据类型之一。 字典中的数据项可以是不同的数据类型，如整数、浮点数、字符串、布尔值等。 字典是可变（mutable）的，可以随意添加、删除或修改其中的数据项。 字典中的数据项是无序的，不能通过索引访问字典中的数据项。 字典中的键是唯一的，字典中不包含重复的键。 字典中的键必须是可哈希（hashable）的，即不可变的数据类型，如整数、浮点数、字符串、元组等。 字典中的值可以是任意数据类型，如整数、浮点数、字符串、布尔值、列表、元组、字典等。 dict 的应用场景 数据存储：字典类型可用于存储和管理数据，如测试数据、配置数据、用户信息等。 数据解析：字典类型可用于解析和处理数据，如解析 JSON 数据、解析 XML 数据等。 dict 的相关方法 键 in 字典 - 判断字典中是否存在指定的键 del 字典[key] - 删除字典中指定key对应的键值对 len() - 计算字典键值对个数，即键的总数 dict(数据) - 将其他数据转换成字典;数据本身必须是序列，序列中的元素是小序列， 字典.pop(key) - 取出字典中指定key对应的值, 返回值就是被取出的值 字典.clear() - 删除字典中所有的键值对 字典.popitem() - 随机删除字典中的一对键值对 字典.clear() - 清空字典 字典.copy() - 拷贝字典产生一个新的字典(浅拷贝) dict.fromkeys(序列, 值) - 创建一个字典，将序列中的元素作为key，key对应的value都是指定的值 字典.items() - 将字典中所有的键值对都转换成元组作为一个序列的元素 字典.values() - 获取字典中所有的值，返回一个序列 字典.keys() - 获取字典中所有的键，返回一个序列 字典.setdefault(key, value) - 当key不存在的时候添加键值对（不会修改） 字典1.update(字典2) - 将字典2中的键值对添加到字典1中 zip(key, value) - 将key和value序列中的值一一对应生成元组对元素 dict 代码示例 student = { \"name\": \"John\", \"age\": 20, \"major\": \"Computer Science\", \"gpa\": 3.8 } # 访问字典中的值 print(student[\"name\"]) # 输出：John print(student[\"age\"]) # 输出：20 # 修改字典中的值 student[\"major\"] = \"Data Science\" print(student) # 输出：{'name': 'John', 'age': 20, 'major': 'Data Science', 'gpa': 3.8} # 添加新的键值对到字典 student[\"university\"] = \"ABC University\" print(student) # 输出：{'name': 'John', 'age': 20, 'major': 'Data Science', 'gpa': 3.8, 'university': 'ABC University'} # 删除字典中的键值对 del student[\"gpa\"] print(student) # 输出：{'name': 'John', 'age': 20, 'major': 'Data Science', 'university': 'ABC University'} # 检查字典中的键是否存在 print(\"age\" in student) # 输出：True print(\"gpa\" in student) # 输出：False # 获取字典的键和值 keys = student.keys() values = student.values() print(keys) # 输出：dict_keys(['name', 'age', 'major', 'university']) print(values) # 输出：dict_values(['John', 20, 'Data Science', 'ABC University']) # 遍历字典的键值对 for key, value in student.items(): print(key + \": \" + str(value)) # 清空字典 student.clear() print(student) # 输出：{} bool 类型 布尔类型（bool）用于表示真值，即 True 或 False。 实际上，布尔类型是整数类型的子类型，True 表示 1，False 表示 0。 def test_land_auth(): response = requests.get(\"https://test.eggrj.com/check_layout_auth?uid=77126\") assert response.status_code == HTTP_STATUS_OK response_json = response.json() assert response_json[\"data\"][\"permission_check\"] == True 其他数据类型 complex 复数类型（complex）用于表示复数，由实数部分和虚数部分组成。 复数类型可以表示正数、负数和零，没有固定大小限制，可以表示任意大的复数。 复数类型是不可变（immutable）的，一旦创建，其值不可更改。 复数类型的精度有限，可能会存在舍入误差。 j为虚数单位,j*j=-1 forzenset 不可变集合类型（frozenset）用于表示一组互不相同的数据项，是 Python 中不常用的数据类型之一。 与 set 的区别就是不可增删改元素，由于集合的特性，不可变类型不能进行数据校验，只能进行存储，所以不常用 最后代码 # 定义一个学生信息的字典 student = { \"name\": \"John\", \"age\": 20, \"major\": \"Computer Science\", \"gpa\": 3.8, \"is_active\": True, \"courses\": [\"Math\", \"English\", \"Physics\"], \"schedule\": (\"Mon\", \"Wed\", \"Fri\"), \"interests\": {\"coding\", \"reading\", \"music\"}, \"grades\": { \"Math\": 85, \"English\": 90, \"Physics\": 92 } } # 打印学生信息 print(\"Name:\", student[\"name\"]) print(\"Age:\", student[\"age\"]) print(\"Major:\", student[\"major\"]) print(\"GPA:\", student[\"gpa\"]) print(\"Is Active:\", student[\"is_active\"]) print(\"Courses:\", student[\"courses\"]) print(\"Schedule:\", student[\"schedule\"]) print(\"Interests:\", student[\"interests\"]) print(\"Grades:\", student[\"grades\"]) # 修改学生信息 student[\"age\"] = 21 student[\"gpa\"] = 3.9 student[\"is_active\"] = False student[\"courses\"].append(\"Chemistry\") student[\"schedule\"] = (\"Tue\", \"Thu\", \"Fri\") student[\"interests\"].add(\"swimming\") student[\"grades\"][\"Chemistry\"] = 88 # 打印修改后的学生信息 print(\"\\nUpdated Student Information:\") print(\"Age:\", student[\"age\"]) print(\"GPA:\", student[\"gpa\"]) print(\"Is Active:\", student[\"is_active\"]) print(\"Courses:\", student[\"courses\"]) print(\"Schedule:\", student[\"schedule\"]) print(\"Interests:\", student[\"interests\"]) print(\"Grades:\", student[\"grades\"]) Copyright © book.stolenzc.com 2021-2023 all right reserved，powered by GitbookFile Modify: 2023-06-27 07:48:51 "}}